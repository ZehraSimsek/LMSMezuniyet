/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-router-dom";
exports.ids = ["vendor-chunks/react-router-dom"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-router-dom/dist/umd/react-router-dom.development.js":
/*!********************************************************************************!*\
  !*** ./node_modules/react-router-dom/dist/umd/react-router-dom.development.js ***!
  \********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("/**\n * React Router DOM v6.22.0\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\n(function (global, factory) {\n   true ? factory(exports, __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"), __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\"), __webpack_require__(/*! react-router */ \"(ssr)/./node_modules/react-router/dist/main.js\"), __webpack_require__(/*! @remix-run/router */ \"(ssr)/./node_modules/@remix-run/router/dist/router.cjs.js\")) :\n  0;\n})(this, (function (exports, React, ReactDOM, reactRouter, router) { 'use strict';\n\n  function _interopNamespace(e) {\n    if (e && e.__esModule) return e;\n    var n = Object.create(null);\n    if (e) {\n      Object.keys(e).forEach(function (k) {\n        if (k !== 'default') {\n          var d = Object.getOwnPropertyDescriptor(e, k);\n          Object.defineProperty(n, k, d.get ? d : {\n            enumerable: true,\n            get: function () { return e[k]; }\n          });\n        }\n      });\n    }\n    n[\"default\"] = e;\n    return Object.freeze(n);\n  }\n\n  var React__namespace = /*#__PURE__*/_interopNamespace(React);\n  var ReactDOM__namespace = /*#__PURE__*/_interopNamespace(ReactDOM);\n\n  function _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function (target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i];\n        for (var key in source) {\n          if (Object.prototype.hasOwnProperty.call(source, key)) {\n            target[key] = source[key];\n          }\n        }\n      }\n      return target;\n    };\n    return _extends.apply(this, arguments);\n  }\n  function _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n    for (i = 0; i < sourceKeys.length; i++) {\n      key = sourceKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      target[key] = source[key];\n    }\n    return target;\n  }\n\n  const defaultMethod = \"get\";\n  const defaultEncType = \"application/x-www-form-urlencoded\";\n  function isHtmlElement(object) {\n    return object != null && typeof object.tagName === \"string\";\n  }\n  function isButtonElement(object) {\n    return isHtmlElement(object) && object.tagName.toLowerCase() === \"button\";\n  }\n  function isFormElement(object) {\n    return isHtmlElement(object) && object.tagName.toLowerCase() === \"form\";\n  }\n  function isInputElement(object) {\n    return isHtmlElement(object) && object.tagName.toLowerCase() === \"input\";\n  }\n  function isModifiedEvent(event) {\n    return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);\n  }\n  function shouldProcessLinkClick(event, target) {\n    return event.button === 0 && (\n    // Ignore everything but left clicks\n    !target || target === \"_self\") &&\n    // Let browser handle \"target=_blank\" etc.\n    !isModifiedEvent(event) // Ignore clicks with modifier keys\n    ;\n  }\n\n  /**\n   * Creates a URLSearchParams object using the given initializer.\n   *\n   * This is identical to `new URLSearchParams(init)` except it also\n   * supports arrays as values in the object form of the initializer\n   * instead of just strings. This is convenient when you need multiple\n   * values for a given key, but don't want to use an array initializer.\n   *\n   * For example, instead of:\n   *\n   *   let searchParams = new URLSearchParams([\n   *     ['sort', 'name'],\n   *     ['sort', 'price']\n   *   ]);\n   *\n   * you can do:\n   *\n   *   let searchParams = createSearchParams({\n   *     sort: ['name', 'price']\n   *   });\n   */\n  function createSearchParams(init) {\n    if (init === void 0) {\n      init = \"\";\n    }\n    return new URLSearchParams(typeof init === \"string\" || Array.isArray(init) || init instanceof URLSearchParams ? init : Object.keys(init).reduce((memo, key) => {\n      let value = init[key];\n      return memo.concat(Array.isArray(value) ? value.map(v => [key, v]) : [[key, value]]);\n    }, []));\n  }\n  function getSearchParamsForLocation(locationSearch, defaultSearchParams) {\n    let searchParams = createSearchParams(locationSearch);\n    if (defaultSearchParams) {\n      // Use `defaultSearchParams.forEach(...)` here instead of iterating of\n      // `defaultSearchParams.keys()` to work-around a bug in Firefox related to\n      // web extensions. Relevant Bugzilla tickets:\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=1414602\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=1023984\n      defaultSearchParams.forEach((_, key) => {\n        if (!searchParams.has(key)) {\n          defaultSearchParams.getAll(key).forEach(value => {\n            searchParams.append(key, value);\n          });\n        }\n      });\n    }\n    return searchParams;\n  }\n\n  // Thanks https://github.com/sindresorhus/type-fest!\n\n  // One-time check for submitter support\n  let _formDataSupportsSubmitter = null;\n  function isFormDataSubmitterSupported() {\n    if (_formDataSupportsSubmitter === null) {\n      try {\n        new FormData(document.createElement(\"form\"),\n        // @ts-expect-error if FormData supports the submitter parameter, this will throw\n        0);\n        _formDataSupportsSubmitter = false;\n      } catch (e) {\n        _formDataSupportsSubmitter = true;\n      }\n    }\n    return _formDataSupportsSubmitter;\n  }\n  const supportedFormEncTypes = new Set([\"application/x-www-form-urlencoded\", \"multipart/form-data\", \"text/plain\"]);\n  function getFormEncType(encType) {\n    if (encType != null && !supportedFormEncTypes.has(encType)) {\n      router.UNSAFE_warning(false, \"\\\"\" + encType + \"\\\" is not a valid `encType` for `<Form>`/`<fetcher.Form>` \" + (\"and will default to \\\"\" + defaultEncType + \"\\\"\")) ;\n      return null;\n    }\n    return encType;\n  }\n  function getFormSubmissionInfo(target, basename) {\n    let method;\n    let action;\n    let encType;\n    let formData;\n    let body;\n    if (isFormElement(target)) {\n      // When grabbing the action from the element, it will have had the basename\n      // prefixed to ensure non-JS scenarios work, so strip it since we'll\n      // re-prefix in the router\n      let attr = target.getAttribute(\"action\");\n      action = attr ? router.stripBasename(attr, basename) : null;\n      method = target.getAttribute(\"method\") || defaultMethod;\n      encType = getFormEncType(target.getAttribute(\"enctype\")) || defaultEncType;\n      formData = new FormData(target);\n    } else if (isButtonElement(target) || isInputElement(target) && (target.type === \"submit\" || target.type === \"image\")) {\n      let form = target.form;\n      if (form == null) {\n        throw new Error(\"Cannot submit a <button> or <input type=\\\"submit\\\"> without a <form>\");\n      }\n\n      // <button>/<input type=\"submit\"> may override attributes of <form>\n\n      // When grabbing the action from the element, it will have had the basename\n      // prefixed to ensure non-JS scenarios work, so strip it since we'll\n      // re-prefix in the router\n      let attr = target.getAttribute(\"formaction\") || form.getAttribute(\"action\");\n      action = attr ? router.stripBasename(attr, basename) : null;\n      method = target.getAttribute(\"formmethod\") || form.getAttribute(\"method\") || defaultMethod;\n      encType = getFormEncType(target.getAttribute(\"formenctype\")) || getFormEncType(form.getAttribute(\"enctype\")) || defaultEncType;\n\n      // Build a FormData object populated from a form and submitter\n      formData = new FormData(form, target);\n\n      // If this browser doesn't support the `FormData(el, submitter)` format,\n      // then tack on the submitter value at the end.  This is a lightweight\n      // solution that is not 100% spec compliant.  For complete support in older\n      // browsers, consider using the `formdata-submitter-polyfill` package\n      if (!isFormDataSubmitterSupported()) {\n        let {\n          name,\n          type,\n          value\n        } = target;\n        if (type === \"image\") {\n          let prefix = name ? name + \".\" : \"\";\n          formData.append(prefix + \"x\", \"0\");\n          formData.append(prefix + \"y\", \"0\");\n        } else if (name) {\n          formData.append(name, value);\n        }\n      }\n    } else if (isHtmlElement(target)) {\n      throw new Error(\"Cannot submit element that is not <form>, <button>, or \" + \"<input type=\\\"submit|image\\\">\");\n    } else {\n      method = defaultMethod;\n      action = null;\n      encType = defaultEncType;\n      body = target;\n    }\n\n    // Send body for <Form encType=\"text/plain\" so we encode it into text\n    if (formData && encType === \"text/plain\") {\n      body = formData;\n      formData = undefined;\n    }\n    return {\n      action,\n      method: method.toLowerCase(),\n      encType,\n      formData,\n      body\n    };\n  }\n\n  const _excluded = [\"onClick\", \"relative\", \"reloadDocument\", \"replace\", \"state\", \"target\", \"to\", \"preventScrollReset\", \"unstable_viewTransition\"],\n    _excluded2 = [\"aria-current\", \"caseSensitive\", \"className\", \"end\", \"style\", \"to\", \"unstable_viewTransition\", \"children\"],\n    _excluded3 = [\"fetcherKey\", \"navigate\", \"reloadDocument\", \"replace\", \"state\", \"method\", \"action\", \"onSubmit\", \"relative\", \"preventScrollReset\", \"unstable_viewTransition\"];\n  //#endregion\n  // HEY YOU! DON'T TOUCH THIS VARIABLE!\n  //\n  // It is replaced with the proper version at build time via a babel plugin in\n  // the rollup config.\n  //\n  // Export a global property onto the window for React Router detection by the\n  // Core Web Vitals Technology Report.  This way they can configure the `wappalyzer`\n  // to detect and properly classify live websites as being built with React Router:\n  // https://github.com/HTTPArchive/wappalyzer/blob/main/src/technologies/r.json\n  const REACT_ROUTER_VERSION = \"6\";\n  try {\n    window.__reactRouterVersion = REACT_ROUTER_VERSION;\n  } catch (e) {\n    // no-op\n  }\n\n  ////////////////////////////////////////////////////////////////////////////////\n  //#region Routers\n  ////////////////////////////////////////////////////////////////////////////////\n  function createBrowserRouter(routes, opts) {\n    return router.createRouter({\n      basename: opts == null ? void 0 : opts.basename,\n      future: _extends({}, opts == null ? void 0 : opts.future, {\n        v7_prependBasename: true\n      }),\n      history: router.createBrowserHistory({\n        window: opts == null ? void 0 : opts.window\n      }),\n      hydrationData: (opts == null ? void 0 : opts.hydrationData) || parseHydrationData(),\n      routes,\n      mapRouteProperties: reactRouter.UNSAFE_mapRouteProperties,\n      window: opts == null ? void 0 : opts.window\n    }).initialize();\n  }\n  function createHashRouter(routes, opts) {\n    return router.createRouter({\n      basename: opts == null ? void 0 : opts.basename,\n      future: _extends({}, opts == null ? void 0 : opts.future, {\n        v7_prependBasename: true\n      }),\n      history: router.createHashHistory({\n        window: opts == null ? void 0 : opts.window\n      }),\n      hydrationData: (opts == null ? void 0 : opts.hydrationData) || parseHydrationData(),\n      routes,\n      mapRouteProperties: reactRouter.UNSAFE_mapRouteProperties,\n      window: opts == null ? void 0 : opts.window\n    }).initialize();\n  }\n  function parseHydrationData() {\n    var _window;\n    let state = (_window = window) == null ? void 0 : _window.__staticRouterHydrationData;\n    if (state && state.errors) {\n      state = _extends({}, state, {\n        errors: deserializeErrors(state.errors)\n      });\n    }\n    return state;\n  }\n  function deserializeErrors(errors) {\n    if (!errors) return null;\n    let entries = Object.entries(errors);\n    let serialized = {};\n    for (let [key, val] of entries) {\n      // Hey you!  If you change this, please change the corresponding logic in\n      // serializeErrors in react-router-dom/server.tsx :)\n      if (val && val.__type === \"RouteErrorResponse\") {\n        serialized[key] = new router.UNSAFE_ErrorResponseImpl(val.status, val.statusText, val.data, val.internal === true);\n      } else if (val && val.__type === \"Error\") {\n        // Attempt to reconstruct the right type of Error (i.e., ReferenceError)\n        if (val.__subType) {\n          let ErrorConstructor = window[val.__subType];\n          if (typeof ErrorConstructor === \"function\") {\n            try {\n              // @ts-expect-error\n              let error = new ErrorConstructor(val.message);\n              // Wipe away the client-side stack trace.  Nothing to fill it in with\n              // because we don't serialize SSR stack traces for security reasons\n              error.stack = \"\";\n              serialized[key] = error;\n            } catch (e) {\n              // no-op - fall through and create a normal Error\n            }\n          }\n        }\n        if (serialized[key] == null) {\n          let error = new Error(val.message);\n          // Wipe away the client-side stack trace.  Nothing to fill it in with\n          // because we don't serialize SSR stack traces for security reasons\n          error.stack = \"\";\n          serialized[key] = error;\n        }\n      } else {\n        serialized[key] = val;\n      }\n    }\n    return serialized;\n  }\n\n  //#endregion\n\n  ////////////////////////////////////////////////////////////////////////////////\n  //#region Contexts\n  ////////////////////////////////////////////////////////////////////////////////\n  const ViewTransitionContext = /*#__PURE__*/React__namespace.createContext({\n    isTransitioning: false\n  });\n  {\n    ViewTransitionContext.displayName = \"ViewTransition\";\n  }\n\n  // TODO: (v7) Change the useFetcher data from `any` to `unknown`\n\n  const FetchersContext = /*#__PURE__*/React__namespace.createContext(new Map());\n  {\n    FetchersContext.displayName = \"Fetchers\";\n  }\n\n  //#endregion\n\n  ////////////////////////////////////////////////////////////////////////////////\n  //#region Components\n  ////////////////////////////////////////////////////////////////////////////////\n\n  /**\n    Webpack + React 17 fails to compile on any of the following because webpack\n    complains that `startTransition` doesn't exist in `React`:\n    * import { startTransition } from \"react\"\n    * import * as React from from \"react\";\n      \"startTransition\" in React ? React.startTransition(() => setState()) : setState()\n    * import * as React from from \"react\";\n      \"startTransition\" in React ? React[\"startTransition\"](() => setState()) : setState()\n\n    Moving it to a constant such as the following solves the Webpack/React 17 issue:\n    * import * as React from from \"react\";\n      const START_TRANSITION = \"startTransition\";\n      START_TRANSITION in React ? React[START_TRANSITION](() => setState()) : setState()\n\n    However, that introduces webpack/terser minification issues in production builds\n    in React 18 where minification/obfuscation ends up removing the call of\n    React.startTransition entirely from the first half of the ternary.  Grabbing\n    this exported reference once up front resolves that issue.\n\n    See https://github.com/remix-run/react-router/issues/10579\n  */\n  const START_TRANSITION = \"startTransition\";\n  const startTransitionImpl = React__namespace[START_TRANSITION];\n  const FLUSH_SYNC = \"flushSync\";\n  const flushSyncImpl = ReactDOM__namespace[FLUSH_SYNC];\n  const USE_ID = \"useId\";\n  const useIdImpl = React__namespace[USE_ID];\n  function startTransitionSafe(cb) {\n    if (startTransitionImpl) {\n      startTransitionImpl(cb);\n    } else {\n      cb();\n    }\n  }\n  function flushSyncSafe(cb) {\n    if (flushSyncImpl) {\n      flushSyncImpl(cb);\n    } else {\n      cb();\n    }\n  }\n  class Deferred {\n    // @ts-expect-error - no initializer\n\n    // @ts-expect-error - no initializer\n\n    constructor() {\n      this.status = \"pending\";\n      this.promise = new Promise((resolve, reject) => {\n        this.resolve = value => {\n          if (this.status === \"pending\") {\n            this.status = \"resolved\";\n            resolve(value);\n          }\n        };\n        this.reject = reason => {\n          if (this.status === \"pending\") {\n            this.status = \"rejected\";\n            reject(reason);\n          }\n        };\n      });\n    }\n  }\n\n  /**\n   * Given a Remix Router instance, render the appropriate UI\n   */\n  function RouterProvider(_ref) {\n    let {\n      fallbackElement,\n      router: router$1,\n      future\n    } = _ref;\n    let [state, setStateImpl] = React__namespace.useState(router$1.state);\n    let [pendingState, setPendingState] = React__namespace.useState();\n    let [vtContext, setVtContext] = React__namespace.useState({\n      isTransitioning: false\n    });\n    let [renderDfd, setRenderDfd] = React__namespace.useState();\n    let [transition, setTransition] = React__namespace.useState();\n    let [interruption, setInterruption] = React__namespace.useState();\n    let fetcherData = React__namespace.useRef(new Map());\n    let {\n      v7_startTransition\n    } = future || {};\n    let optInStartTransition = React__namespace.useCallback(cb => {\n      if (v7_startTransition) {\n        startTransitionSafe(cb);\n      } else {\n        cb();\n      }\n    }, [v7_startTransition]);\n    let setState = React__namespace.useCallback((newState, _ref2) => {\n      let {\n        deletedFetchers,\n        unstable_flushSync: flushSync,\n        unstable_viewTransitionOpts: viewTransitionOpts\n      } = _ref2;\n      deletedFetchers.forEach(key => fetcherData.current.delete(key));\n      newState.fetchers.forEach((fetcher, key) => {\n        if (fetcher.data !== undefined) {\n          fetcherData.current.set(key, fetcher.data);\n        }\n      });\n      let isViewTransitionUnavailable = router$1.window == null || typeof router$1.window.document.startViewTransition !== \"function\";\n\n      // If this isn't a view transition or it's not available in this browser,\n      // just update and be done with it\n      if (!viewTransitionOpts || isViewTransitionUnavailable) {\n        if (flushSync) {\n          flushSyncSafe(() => setStateImpl(newState));\n        } else {\n          optInStartTransition(() => setStateImpl(newState));\n        }\n        return;\n      }\n\n      // flushSync + startViewTransition\n      if (flushSync) {\n        // Flush through the context to mark DOM elements as transition=ing\n        flushSyncSafe(() => {\n          // Cancel any pending transitions\n          if (transition) {\n            renderDfd && renderDfd.resolve();\n            transition.skipTransition();\n          }\n          setVtContext({\n            isTransitioning: true,\n            flushSync: true,\n            currentLocation: viewTransitionOpts.currentLocation,\n            nextLocation: viewTransitionOpts.nextLocation\n          });\n        });\n\n        // Update the DOM\n        let t = router$1.window.document.startViewTransition(() => {\n          flushSyncSafe(() => setStateImpl(newState));\n        });\n\n        // Clean up after the animation completes\n        t.finished.finally(() => {\n          flushSyncSafe(() => {\n            setRenderDfd(undefined);\n            setTransition(undefined);\n            setPendingState(undefined);\n            setVtContext({\n              isTransitioning: false\n            });\n          });\n        });\n        flushSyncSafe(() => setTransition(t));\n        return;\n      }\n\n      // startTransition + startViewTransition\n      if (transition) {\n        // Interrupting an in-progress transition, cancel and let everything flush\n        // out, and then kick off a new transition from the interruption state\n        renderDfd && renderDfd.resolve();\n        transition.skipTransition();\n        setInterruption({\n          state: newState,\n          currentLocation: viewTransitionOpts.currentLocation,\n          nextLocation: viewTransitionOpts.nextLocation\n        });\n      } else {\n        // Completed navigation update with opted-in view transitions, let 'er rip\n        setPendingState(newState);\n        setVtContext({\n          isTransitioning: true,\n          flushSync: false,\n          currentLocation: viewTransitionOpts.currentLocation,\n          nextLocation: viewTransitionOpts.nextLocation\n        });\n      }\n    }, [router$1.window, transition, renderDfd, fetcherData, optInStartTransition]);\n\n    // Need to use a layout effect here so we are subscribed early enough to\n    // pick up on any render-driven redirects/navigations (useEffect/<Navigate>)\n    React__namespace.useLayoutEffect(() => router$1.subscribe(setState), [router$1, setState]);\n\n    // When we start a view transition, create a Deferred we can use for the\n    // eventual \"completed\" render\n    React__namespace.useEffect(() => {\n      if (vtContext.isTransitioning && !vtContext.flushSync) {\n        setRenderDfd(new Deferred());\n      }\n    }, [vtContext]);\n\n    // Once the deferred is created, kick off startViewTransition() to update the\n    // DOM and then wait on the Deferred to resolve (indicating the DOM update has\n    // happened)\n    React__namespace.useEffect(() => {\n      if (renderDfd && pendingState && router$1.window) {\n        let newState = pendingState;\n        let renderPromise = renderDfd.promise;\n        let transition = router$1.window.document.startViewTransition(async () => {\n          optInStartTransition(() => setStateImpl(newState));\n          await renderPromise;\n        });\n        transition.finished.finally(() => {\n          setRenderDfd(undefined);\n          setTransition(undefined);\n          setPendingState(undefined);\n          setVtContext({\n            isTransitioning: false\n          });\n        });\n        setTransition(transition);\n      }\n    }, [optInStartTransition, pendingState, renderDfd, router$1.window]);\n\n    // When the new location finally renders and is committed to the DOM, this\n    // effect will run to resolve the transition\n    React__namespace.useEffect(() => {\n      if (renderDfd && pendingState && state.location.key === pendingState.location.key) {\n        renderDfd.resolve();\n      }\n    }, [renderDfd, transition, state.location, pendingState]);\n\n    // If we get interrupted with a new navigation during a transition, we skip\n    // the active transition, let it cleanup, then kick it off again here\n    React__namespace.useEffect(() => {\n      if (!vtContext.isTransitioning && interruption) {\n        setPendingState(interruption.state);\n        setVtContext({\n          isTransitioning: true,\n          flushSync: false,\n          currentLocation: interruption.currentLocation,\n          nextLocation: interruption.nextLocation\n        });\n        setInterruption(undefined);\n      }\n    }, [vtContext.isTransitioning, interruption]);\n    React__namespace.useEffect(() => {\n      router.UNSAFE_warning(fallbackElement == null || !router$1.future.v7_partialHydration, \"`<RouterProvider fallbackElement>` is deprecated when using \" + \"`v7_partialHydration`, use a `HydrateFallback` component instead\") ;\n      // Only log this once on initial mount\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, []);\n    let navigator = React__namespace.useMemo(() => {\n      return {\n        createHref: router$1.createHref,\n        encodeLocation: router$1.encodeLocation,\n        go: n => router$1.navigate(n),\n        push: (to, state, opts) => router$1.navigate(to, {\n          state,\n          preventScrollReset: opts == null ? void 0 : opts.preventScrollReset\n        }),\n        replace: (to, state, opts) => router$1.navigate(to, {\n          replace: true,\n          state,\n          preventScrollReset: opts == null ? void 0 : opts.preventScrollReset\n        })\n      };\n    }, [router$1]);\n    let basename = router$1.basename || \"/\";\n    let dataRouterContext = React__namespace.useMemo(() => ({\n      router: router$1,\n      navigator,\n      static: false,\n      basename\n    }), [router$1, navigator, basename]);\n\n    // The fragment and {null} here are important!  We need them to keep React 18's\n    // useId happy when we are server-rendering since we may have a <script> here\n    // containing the hydrated server-side staticContext (from StaticRouterProvider).\n    // useId relies on the component tree structure to generate deterministic id's\n    // so we need to ensure it remains the same on the client even though\n    // we don't need the <script> tag\n    return /*#__PURE__*/React__namespace.createElement(React__namespace.Fragment, null, /*#__PURE__*/React__namespace.createElement(reactRouter.UNSAFE_DataRouterContext.Provider, {\n      value: dataRouterContext\n    }, /*#__PURE__*/React__namespace.createElement(reactRouter.UNSAFE_DataRouterStateContext.Provider, {\n      value: state\n    }, /*#__PURE__*/React__namespace.createElement(FetchersContext.Provider, {\n      value: fetcherData.current\n    }, /*#__PURE__*/React__namespace.createElement(ViewTransitionContext.Provider, {\n      value: vtContext\n    }, /*#__PURE__*/React__namespace.createElement(reactRouter.Router, {\n      basename: basename,\n      location: state.location,\n      navigationType: state.historyAction,\n      navigator: navigator,\n      future: {\n        v7_relativeSplatPath: router$1.future.v7_relativeSplatPath\n      }\n    }, state.initialized || router$1.future.v7_partialHydration ? /*#__PURE__*/React__namespace.createElement(DataRoutes, {\n      routes: router$1.routes,\n      future: router$1.future,\n      state: state\n    }) : fallbackElement))))), null);\n  }\n  function DataRoutes(_ref3) {\n    let {\n      routes,\n      future,\n      state\n    } = _ref3;\n    return reactRouter.UNSAFE_useRoutesImpl(routes, undefined, state, future);\n  }\n  /**\n   * A `<Router>` for use in web browsers. Provides the cleanest URLs.\n   */\n  function BrowserRouter(_ref4) {\n    let {\n      basename,\n      children,\n      future,\n      window\n    } = _ref4;\n    let historyRef = React__namespace.useRef();\n    if (historyRef.current == null) {\n      historyRef.current = router.createBrowserHistory({\n        window,\n        v5Compat: true\n      });\n    }\n    let history = historyRef.current;\n    let [state, setStateImpl] = React__namespace.useState({\n      action: history.action,\n      location: history.location\n    });\n    let {\n      v7_startTransition\n    } = future || {};\n    let setState = React__namespace.useCallback(newState => {\n      v7_startTransition && startTransitionImpl ? startTransitionImpl(() => setStateImpl(newState)) : setStateImpl(newState);\n    }, [setStateImpl, v7_startTransition]);\n    React__namespace.useLayoutEffect(() => history.listen(setState), [history, setState]);\n    return /*#__PURE__*/React__namespace.createElement(reactRouter.Router, {\n      basename: basename,\n      children: children,\n      location: state.location,\n      navigationType: state.action,\n      navigator: history,\n      future: future\n    });\n  }\n  /**\n   * A `<Router>` for use in web browsers. Stores the location in the hash\n   * portion of the URL so it is not sent to the server.\n   */\n  function HashRouter(_ref5) {\n    let {\n      basename,\n      children,\n      future,\n      window\n    } = _ref5;\n    let historyRef = React__namespace.useRef();\n    if (historyRef.current == null) {\n      historyRef.current = router.createHashHistory({\n        window,\n        v5Compat: true\n      });\n    }\n    let history = historyRef.current;\n    let [state, setStateImpl] = React__namespace.useState({\n      action: history.action,\n      location: history.location\n    });\n    let {\n      v7_startTransition\n    } = future || {};\n    let setState = React__namespace.useCallback(newState => {\n      v7_startTransition && startTransitionImpl ? startTransitionImpl(() => setStateImpl(newState)) : setStateImpl(newState);\n    }, [setStateImpl, v7_startTransition]);\n    React__namespace.useLayoutEffect(() => history.listen(setState), [history, setState]);\n    return /*#__PURE__*/React__namespace.createElement(reactRouter.Router, {\n      basename: basename,\n      children: children,\n      location: state.location,\n      navigationType: state.action,\n      navigator: history,\n      future: future\n    });\n  }\n  /**\n   * A `<Router>` that accepts a pre-instantiated history object. It's important\n   * to note that using your own history object is highly discouraged and may add\n   * two versions of the history library to your bundles unless you use the same\n   * version of the history library that React Router uses internally.\n   */\n  function HistoryRouter(_ref6) {\n    let {\n      basename,\n      children,\n      future,\n      history\n    } = _ref6;\n    let [state, setStateImpl] = React__namespace.useState({\n      action: history.action,\n      location: history.location\n    });\n    let {\n      v7_startTransition\n    } = future || {};\n    let setState = React__namespace.useCallback(newState => {\n      v7_startTransition && startTransitionImpl ? startTransitionImpl(() => setStateImpl(newState)) : setStateImpl(newState);\n    }, [setStateImpl, v7_startTransition]);\n    React__namespace.useLayoutEffect(() => history.listen(setState), [history, setState]);\n    return /*#__PURE__*/React__namespace.createElement(reactRouter.Router, {\n      basename: basename,\n      children: children,\n      location: state.location,\n      navigationType: state.action,\n      navigator: history,\n      future: future\n    });\n  }\n  {\n    HistoryRouter.displayName = \"unstable_HistoryRouter\";\n  }\n  const isBrowser = typeof window !== \"undefined\" && typeof window.document !== \"undefined\" && typeof window.document.createElement !== \"undefined\";\n  const ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\\/\\/)/i;\n\n  /**\n   * The public API for rendering a history-aware `<a>`.\n   */\n  const Link = /*#__PURE__*/React__namespace.forwardRef(function LinkWithRef(_ref7, ref) {\n    let {\n        onClick,\n        relative,\n        reloadDocument,\n        replace,\n        state,\n        target,\n        to,\n        preventScrollReset,\n        unstable_viewTransition\n      } = _ref7,\n      rest = _objectWithoutPropertiesLoose(_ref7, _excluded);\n    let {\n      basename\n    } = React__namespace.useContext(reactRouter.UNSAFE_NavigationContext);\n\n    // Rendered into <a href> for absolute URLs\n    let absoluteHref;\n    let isExternal = false;\n    if (typeof to === \"string\" && ABSOLUTE_URL_REGEX.test(to)) {\n      // Render the absolute href server- and client-side\n      absoluteHref = to;\n\n      // Only check for external origins client-side\n      if (isBrowser) {\n        try {\n          let currentUrl = new URL(window.location.href);\n          let targetUrl = to.startsWith(\"//\") ? new URL(currentUrl.protocol + to) : new URL(to);\n          let path = router.stripBasename(targetUrl.pathname, basename);\n          if (targetUrl.origin === currentUrl.origin && path != null) {\n            // Strip the protocol/origin/basename for same-origin absolute URLs\n            to = path + targetUrl.search + targetUrl.hash;\n          } else {\n            isExternal = true;\n          }\n        } catch (e) {\n          // We can't do external URL detection without a valid URL\n          router.UNSAFE_warning(false, \"<Link to=\\\"\" + to + \"\\\"> contains an invalid URL which will probably break \" + \"when clicked - please update to a valid URL path.\") ;\n        }\n      }\n    }\n\n    // Rendered into <a href> for relative URLs\n    let href = reactRouter.useHref(to, {\n      relative\n    });\n    let internalOnClick = useLinkClickHandler(to, {\n      replace,\n      state,\n      target,\n      preventScrollReset,\n      relative,\n      unstable_viewTransition\n    });\n    function handleClick(event) {\n      if (onClick) onClick(event);\n      if (!event.defaultPrevented) {\n        internalOnClick(event);\n      }\n    }\n    return (\n      /*#__PURE__*/\n      // eslint-disable-next-line jsx-a11y/anchor-has-content\n      React__namespace.createElement(\"a\", _extends({}, rest, {\n        href: absoluteHref || href,\n        onClick: isExternal || reloadDocument ? onClick : handleClick,\n        ref: ref,\n        target: target\n      }))\n    );\n  });\n  {\n    Link.displayName = \"Link\";\n  }\n  /**\n   * A `<Link>` wrapper that knows if it's \"active\" or not.\n   */\n  const NavLink = /*#__PURE__*/React__namespace.forwardRef(function NavLinkWithRef(_ref8, ref) {\n    let {\n        \"aria-current\": ariaCurrentProp = \"page\",\n        caseSensitive = false,\n        className: classNameProp = \"\",\n        end = false,\n        style: styleProp,\n        to,\n        unstable_viewTransition,\n        children\n      } = _ref8,\n      rest = _objectWithoutPropertiesLoose(_ref8, _excluded2);\n    let path = reactRouter.useResolvedPath(to, {\n      relative: rest.relative\n    });\n    let location = reactRouter.useLocation();\n    let routerState = React__namespace.useContext(reactRouter.UNSAFE_DataRouterStateContext);\n    let {\n      navigator,\n      basename\n    } = React__namespace.useContext(reactRouter.UNSAFE_NavigationContext);\n    let isTransitioning = routerState != null &&\n    // Conditional usage is OK here because the usage of a data router is static\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    useViewTransitionState(path) && unstable_viewTransition === true;\n    let toPathname = navigator.encodeLocation ? navigator.encodeLocation(path).pathname : path.pathname;\n    let locationPathname = location.pathname;\n    let nextLocationPathname = routerState && routerState.navigation && routerState.navigation.location ? routerState.navigation.location.pathname : null;\n    if (!caseSensitive) {\n      locationPathname = locationPathname.toLowerCase();\n      nextLocationPathname = nextLocationPathname ? nextLocationPathname.toLowerCase() : null;\n      toPathname = toPathname.toLowerCase();\n    }\n    if (nextLocationPathname && basename) {\n      nextLocationPathname = router.stripBasename(nextLocationPathname, basename) || nextLocationPathname;\n    }\n\n    // If the `to` has a trailing slash, look at that exact spot.  Otherwise,\n    // we're looking for a slash _after_ what's in `to`.  For example:\n    //\n    // <NavLink to=\"/users\"> and <NavLink to=\"/users/\">\n    // both want to look for a / at index 6 to match URL `/users/matt`\n    const endSlashPosition = toPathname !== \"/\" && toPathname.endsWith(\"/\") ? toPathname.length - 1 : toPathname.length;\n    let isActive = locationPathname === toPathname || !end && locationPathname.startsWith(toPathname) && locationPathname.charAt(endSlashPosition) === \"/\";\n    let isPending = nextLocationPathname != null && (nextLocationPathname === toPathname || !end && nextLocationPathname.startsWith(toPathname) && nextLocationPathname.charAt(toPathname.length) === \"/\");\n    let renderProps = {\n      isActive,\n      isPending,\n      isTransitioning\n    };\n    let ariaCurrent = isActive ? ariaCurrentProp : undefined;\n    let className;\n    if (typeof classNameProp === \"function\") {\n      className = classNameProp(renderProps);\n    } else {\n      // If the className prop is not a function, we use a default `active`\n      // class for <NavLink />s that are active. In v5 `active` was the default\n      // value for `activeClassName`, but we are removing that API and can still\n      // use the old default behavior for a cleaner upgrade path and keep the\n      // simple styling rules working as they currently do.\n      className = [classNameProp, isActive ? \"active\" : null, isPending ? \"pending\" : null, isTransitioning ? \"transitioning\" : null].filter(Boolean).join(\" \");\n    }\n    let style = typeof styleProp === \"function\" ? styleProp(renderProps) : styleProp;\n    return /*#__PURE__*/React__namespace.createElement(Link, _extends({}, rest, {\n      \"aria-current\": ariaCurrent,\n      className: className,\n      ref: ref,\n      style: style,\n      to: to,\n      unstable_viewTransition: unstable_viewTransition\n    }), typeof children === \"function\" ? children(renderProps) : children);\n  });\n  {\n    NavLink.displayName = \"NavLink\";\n  }\n  /**\n   * A `@remix-run/router`-aware `<form>`. It behaves like a normal form except\n   * that the interaction with the server is with `fetch` instead of new document\n   * requests, allowing components to add nicer UX to the page as the form is\n   * submitted and returns with data.\n   */\n  const Form = /*#__PURE__*/React__namespace.forwardRef((_ref9, forwardedRef) => {\n    let {\n        fetcherKey,\n        navigate,\n        reloadDocument,\n        replace,\n        state,\n        method = defaultMethod,\n        action,\n        onSubmit,\n        relative,\n        preventScrollReset,\n        unstable_viewTransition\n      } = _ref9,\n      props = _objectWithoutPropertiesLoose(_ref9, _excluded3);\n    let submit = useSubmit();\n    let formAction = useFormAction(action, {\n      relative\n    });\n    let formMethod = method.toLowerCase() === \"get\" ? \"get\" : \"post\";\n    let submitHandler = event => {\n      onSubmit && onSubmit(event);\n      if (event.defaultPrevented) return;\n      event.preventDefault();\n      let submitter = event.nativeEvent.submitter;\n      let submitMethod = (submitter == null ? void 0 : submitter.getAttribute(\"formmethod\")) || method;\n      submit(submitter || event.currentTarget, {\n        fetcherKey,\n        method: submitMethod,\n        navigate,\n        replace,\n        state,\n        relative,\n        preventScrollReset,\n        unstable_viewTransition\n      });\n    };\n    return /*#__PURE__*/React__namespace.createElement(\"form\", _extends({\n      ref: forwardedRef,\n      method: formMethod,\n      action: formAction,\n      onSubmit: reloadDocument ? onSubmit : submitHandler\n    }, props));\n  });\n  {\n    Form.displayName = \"Form\";\n  }\n  /**\n   * This component will emulate the browser's scroll restoration on location\n   * changes.\n   */\n  function ScrollRestoration(_ref10) {\n    let {\n      getKey,\n      storageKey\n    } = _ref10;\n    useScrollRestoration({\n      getKey,\n      storageKey\n    });\n    return null;\n  }\n  {\n    ScrollRestoration.displayName = \"ScrollRestoration\";\n  }\n  //#endregion\n\n  ////////////////////////////////////////////////////////////////////////////////\n  //#region Hooks\n  ////////////////////////////////////////////////////////////////////////////////\n  var DataRouterHook = /*#__PURE__*/function (DataRouterHook) {\n    DataRouterHook[\"UseScrollRestoration\"] = \"useScrollRestoration\";\n    DataRouterHook[\"UseSubmit\"] = \"useSubmit\";\n    DataRouterHook[\"UseSubmitFetcher\"] = \"useSubmitFetcher\";\n    DataRouterHook[\"UseFetcher\"] = \"useFetcher\";\n    DataRouterHook[\"useViewTransitionState\"] = \"useViewTransitionState\";\n    return DataRouterHook;\n  }(DataRouterHook || {});\n  var DataRouterStateHook = /*#__PURE__*/function (DataRouterStateHook) {\n    DataRouterStateHook[\"UseFetcher\"] = \"useFetcher\";\n    DataRouterStateHook[\"UseFetchers\"] = \"useFetchers\";\n    DataRouterStateHook[\"UseScrollRestoration\"] = \"useScrollRestoration\";\n    return DataRouterStateHook;\n  }(DataRouterStateHook || {}); // Internal hooks\n  function getDataRouterConsoleError(hookName) {\n    return hookName + \" must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.\";\n  }\n  function useDataRouterContext(hookName) {\n    let ctx = React__namespace.useContext(reactRouter.UNSAFE_DataRouterContext);\n    !ctx ? router.UNSAFE_invariant(false, getDataRouterConsoleError(hookName))  : void 0;\n    return ctx;\n  }\n  function useDataRouterState(hookName) {\n    let state = React__namespace.useContext(reactRouter.UNSAFE_DataRouterStateContext);\n    !state ? router.UNSAFE_invariant(false, getDataRouterConsoleError(hookName))  : void 0;\n    return state;\n  }\n\n  // External hooks\n\n  /**\n   * Handles the click behavior for router `<Link>` components. This is useful if\n   * you need to create custom `<Link>` components with the same click behavior we\n   * use in our exported `<Link>`.\n   */\n  function useLinkClickHandler(to, _temp) {\n    let {\n      target,\n      replace: replaceProp,\n      state,\n      preventScrollReset,\n      relative,\n      unstable_viewTransition\n    } = _temp === void 0 ? {} : _temp;\n    let navigate = reactRouter.useNavigate();\n    let location = reactRouter.useLocation();\n    let path = reactRouter.useResolvedPath(to, {\n      relative\n    });\n    return React__namespace.useCallback(event => {\n      if (shouldProcessLinkClick(event, target)) {\n        event.preventDefault();\n\n        // If the URL hasn't changed, a regular <a> will do a replace instead of\n        // a push, so do the same here unless the replace prop is explicitly set\n        let replace = replaceProp !== undefined ? replaceProp : reactRouter.createPath(location) === reactRouter.createPath(path);\n        navigate(to, {\n          replace,\n          state,\n          preventScrollReset,\n          relative,\n          unstable_viewTransition\n        });\n      }\n    }, [location, navigate, path, replaceProp, state, target, to, preventScrollReset, relative, unstable_viewTransition]);\n  }\n\n  /**\n   * A convenient wrapper for reading and writing search parameters via the\n   * URLSearchParams interface.\n   */\n  function useSearchParams(defaultInit) {\n    router.UNSAFE_warning(typeof URLSearchParams !== \"undefined\", \"You cannot use the `useSearchParams` hook in a browser that does not \" + \"support the URLSearchParams API. If you need to support Internet \" + \"Explorer 11, we recommend you load a polyfill such as \" + \"https://github.com/ungap/url-search-params\\n\\n\" + \"If you're unsure how to load polyfills, we recommend you check out \" + \"https://polyfill.io/v3/ which provides some recommendations about how \" + \"to load polyfills only for users that need them, instead of for every \" + \"user.\") ;\n    let defaultSearchParamsRef = React__namespace.useRef(createSearchParams(defaultInit));\n    let hasSetSearchParamsRef = React__namespace.useRef(false);\n    let location = reactRouter.useLocation();\n    let searchParams = React__namespace.useMemo(() =>\n    // Only merge in the defaults if we haven't yet called setSearchParams.\n    // Once we call that we want those to take precedence, otherwise you can't\n    // remove a param with setSearchParams({}) if it has an initial value\n    getSearchParamsForLocation(location.search, hasSetSearchParamsRef.current ? null : defaultSearchParamsRef.current), [location.search]);\n    let navigate = reactRouter.useNavigate();\n    let setSearchParams = React__namespace.useCallback((nextInit, navigateOptions) => {\n      const newSearchParams = createSearchParams(typeof nextInit === \"function\" ? nextInit(searchParams) : nextInit);\n      hasSetSearchParamsRef.current = true;\n      navigate(\"?\" + newSearchParams, navigateOptions);\n    }, [navigate, searchParams]);\n    return [searchParams, setSearchParams];\n  }\n\n  /**\n   * Submits a HTML `<form>` to the server without reloading the page.\n   */\n\n  /**\n   * Submits a fetcher `<form>` to the server without reloading the page.\n   */\n\n  function validateClientSideSubmission() {\n    if (typeof document === \"undefined\") {\n      throw new Error(\"You are calling submit during the server render. \" + \"Try calling submit within a `useEffect` or callback instead.\");\n    }\n  }\n  let fetcherId = 0;\n  let getUniqueFetcherId = () => \"__\" + String(++fetcherId) + \"__\";\n\n  /**\n   * Returns a function that may be used to programmatically submit a form (or\n   * some arbitrary data) to the server.\n   */\n  function useSubmit() {\n    let {\n      router\n    } = useDataRouterContext(DataRouterHook.UseSubmit);\n    let {\n      basename\n    } = React__namespace.useContext(reactRouter.UNSAFE_NavigationContext);\n    let currentRouteId = reactRouter.UNSAFE_useRouteId();\n    return React__namespace.useCallback(function (target, options) {\n      if (options === void 0) {\n        options = {};\n      }\n      validateClientSideSubmission();\n      let {\n        action,\n        method,\n        encType,\n        formData,\n        body\n      } = getFormSubmissionInfo(target, basename);\n      if (options.navigate === false) {\n        let key = options.fetcherKey || getUniqueFetcherId();\n        router.fetch(key, currentRouteId, options.action || action, {\n          preventScrollReset: options.preventScrollReset,\n          formData,\n          body,\n          formMethod: options.method || method,\n          formEncType: options.encType || encType,\n          unstable_flushSync: options.unstable_flushSync\n        });\n      } else {\n        router.navigate(options.action || action, {\n          preventScrollReset: options.preventScrollReset,\n          formData,\n          body,\n          formMethod: options.method || method,\n          formEncType: options.encType || encType,\n          replace: options.replace,\n          state: options.state,\n          fromRouteId: currentRouteId,\n          unstable_flushSync: options.unstable_flushSync,\n          unstable_viewTransition: options.unstable_viewTransition\n        });\n      }\n    }, [router, basename, currentRouteId]);\n  }\n\n  // v7: Eventually we should deprecate this entirely in favor of using the\n  // router method directly?\n  function useFormAction(action, _temp2) {\n    let {\n      relative\n    } = _temp2 === void 0 ? {} : _temp2;\n    let {\n      basename\n    } = React__namespace.useContext(reactRouter.UNSAFE_NavigationContext);\n    let routeContext = React__namespace.useContext(reactRouter.UNSAFE_RouteContext);\n    !routeContext ? router.UNSAFE_invariant(false, \"useFormAction must be used inside a RouteContext\")  : void 0;\n    let [match] = routeContext.matches.slice(-1);\n    // Shallow clone path so we can modify it below, otherwise we modify the\n    // object referenced by useMemo inside useResolvedPath\n    let path = _extends({}, reactRouter.useResolvedPath(action ? action : \".\", {\n      relative\n    }));\n\n    // If no action was specified, browsers will persist current search params\n    // when determining the path, so match that behavior\n    // https://github.com/remix-run/remix/issues/927\n    let location = reactRouter.useLocation();\n    if (action == null) {\n      // Safe to write to this directly here since if action was undefined, we\n      // would have called useResolvedPath(\".\") which will never include a search\n      path.search = location.search;\n\n      // When grabbing search params from the URL, remove any included ?index param\n      // since it might not apply to our contextual route.  We add it back based\n      // on match.route.index below\n      let params = new URLSearchParams(path.search);\n      if (params.has(\"index\") && params.get(\"index\") === \"\") {\n        params.delete(\"index\");\n        path.search = params.toString() ? \"?\" + params.toString() : \"\";\n      }\n    }\n    if ((!action || action === \".\") && match.route.index) {\n      path.search = path.search ? path.search.replace(/^\\?/, \"?index&\") : \"?index\";\n    }\n\n    // If we're operating within a basename, prepend it to the pathname prior\n    // to creating the form action.  If this is a root navigation, then just use\n    // the raw basename which allows the basename to have full control over the\n    // presence of a trailing slash on root actions\n    if (basename !== \"/\") {\n      path.pathname = path.pathname === \"/\" ? basename : router.joinPaths([basename, path.pathname]);\n    }\n    return reactRouter.createPath(path);\n  }\n  // TODO: (v7) Change the useFetcher generic default from `any` to `unknown`\n  /**\n   * Interacts with route loaders and actions without causing a navigation. Great\n   * for any interaction that stays on the same page.\n   */\n  function useFetcher(_temp3) {\n    var _route$matches;\n    let {\n      key\n    } = _temp3 === void 0 ? {} : _temp3;\n    let {\n      router: router$1\n    } = useDataRouterContext(DataRouterHook.UseFetcher);\n    let state = useDataRouterState(DataRouterStateHook.UseFetcher);\n    let fetcherData = React__namespace.useContext(FetchersContext);\n    let route = React__namespace.useContext(reactRouter.UNSAFE_RouteContext);\n    let routeId = (_route$matches = route.matches[route.matches.length - 1]) == null ? void 0 : _route$matches.route.id;\n    !fetcherData ? router.UNSAFE_invariant(false, \"useFetcher must be used inside a FetchersContext\")  : void 0;\n    !route ? router.UNSAFE_invariant(false, \"useFetcher must be used inside a RouteContext\")  : void 0;\n    !(routeId != null) ? router.UNSAFE_invariant(false, \"useFetcher can only be used on routes that contain a unique \\\"id\\\"\")  : void 0;\n\n    // Fetcher key handling\n    // OK to call conditionally to feature detect `useId`\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    let defaultKey = useIdImpl ? useIdImpl() : \"\";\n    let [fetcherKey, setFetcherKey] = React__namespace.useState(key || defaultKey);\n    if (key && key !== fetcherKey) {\n      setFetcherKey(key);\n    } else if (!fetcherKey) {\n      // We will only fall through here when `useId` is not available\n      setFetcherKey(getUniqueFetcherId());\n    }\n\n    // Registration/cleanup\n    React__namespace.useEffect(() => {\n      router$1.getFetcher(fetcherKey);\n      return () => {\n        // Tell the router we've unmounted - if v7_fetcherPersist is enabled this\n        // will not delete immediately but instead queue up a delete after the\n        // fetcher returns to an `idle` state\n        router$1.deleteFetcher(fetcherKey);\n      };\n    }, [router$1, fetcherKey]);\n\n    // Fetcher additions\n    let load = React__namespace.useCallback((href, opts) => {\n      !routeId ? router.UNSAFE_invariant(false, \"No routeId available for fetcher.load()\")  : void 0;\n      router$1.fetch(fetcherKey, routeId, href, opts);\n    }, [fetcherKey, routeId, router$1]);\n    let submitImpl = useSubmit();\n    let submit = React__namespace.useCallback((target, opts) => {\n      submitImpl(target, _extends({}, opts, {\n        navigate: false,\n        fetcherKey\n      }));\n    }, [fetcherKey, submitImpl]);\n    let FetcherForm = React__namespace.useMemo(() => {\n      let FetcherForm = /*#__PURE__*/React__namespace.forwardRef((props, ref) => {\n        return /*#__PURE__*/React__namespace.createElement(Form, _extends({}, props, {\n          navigate: false,\n          fetcherKey: fetcherKey,\n          ref: ref\n        }));\n      });\n      {\n        FetcherForm.displayName = \"fetcher.Form\";\n      }\n      return FetcherForm;\n    }, [fetcherKey]);\n\n    // Exposed FetcherWithComponents\n    let fetcher = state.fetchers.get(fetcherKey) || router.IDLE_FETCHER;\n    let data = fetcherData.get(fetcherKey);\n    let fetcherWithComponents = React__namespace.useMemo(() => _extends({\n      Form: FetcherForm,\n      submit,\n      load\n    }, fetcher, {\n      data\n    }), [FetcherForm, submit, load, fetcher, data]);\n    return fetcherWithComponents;\n  }\n\n  /**\n   * Provides all fetchers currently on the page. Useful for layouts and parent\n   * routes that need to provide pending/optimistic UI regarding the fetch.\n   */\n  function useFetchers() {\n    let state = useDataRouterState(DataRouterStateHook.UseFetchers);\n    return Array.from(state.fetchers.entries()).map(_ref11 => {\n      let [key, fetcher] = _ref11;\n      return _extends({}, fetcher, {\n        key\n      });\n    });\n  }\n  const SCROLL_RESTORATION_STORAGE_KEY = \"react-router-scroll-positions\";\n  let savedScrollPositions = {};\n\n  /**\n   * When rendered inside a RouterProvider, will restore scroll positions on navigations\n   */\n  function useScrollRestoration(_temp4) {\n    let {\n      getKey,\n      storageKey\n    } = _temp4 === void 0 ? {} : _temp4;\n    let {\n      router: router$1\n    } = useDataRouterContext(DataRouterHook.UseScrollRestoration);\n    let {\n      restoreScrollPosition,\n      preventScrollReset\n    } = useDataRouterState(DataRouterStateHook.UseScrollRestoration);\n    let {\n      basename\n    } = React__namespace.useContext(reactRouter.UNSAFE_NavigationContext);\n    let location = reactRouter.useLocation();\n    let matches = reactRouter.useMatches();\n    let navigation = reactRouter.useNavigation();\n\n    // Trigger manual scroll restoration while we're active\n    React__namespace.useEffect(() => {\n      window.history.scrollRestoration = \"manual\";\n      return () => {\n        window.history.scrollRestoration = \"auto\";\n      };\n    }, []);\n\n    // Save positions on pagehide\n    usePageHide(React__namespace.useCallback(() => {\n      if (navigation.state === \"idle\") {\n        let key = (getKey ? getKey(location, matches) : null) || location.key;\n        savedScrollPositions[key] = window.scrollY;\n      }\n      try {\n        sessionStorage.setItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY, JSON.stringify(savedScrollPositions));\n      } catch (error) {\n        router.UNSAFE_warning(false, \"Failed to save scroll positions in sessionStorage, <ScrollRestoration /> will not work properly (\" + error + \").\") ;\n      }\n      window.history.scrollRestoration = \"auto\";\n    }, [storageKey, getKey, navigation.state, location, matches]));\n\n    // Read in any saved scroll locations\n    if (typeof document !== \"undefined\") {\n      // eslint-disable-next-line react-hooks/rules-of-hooks\n      React__namespace.useLayoutEffect(() => {\n        try {\n          let sessionPositions = sessionStorage.getItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY);\n          if (sessionPositions) {\n            savedScrollPositions = JSON.parse(sessionPositions);\n          }\n        } catch (e) {\n          // no-op, use default empty object\n        }\n      }, [storageKey]);\n\n      // Enable scroll restoration in the router\n      // eslint-disable-next-line react-hooks/rules-of-hooks\n      React__namespace.useLayoutEffect(() => {\n        let getKeyWithoutBasename = getKey && basename !== \"/\" ? (location, matches) => getKey( // Strip the basename to match useLocation()\n        _extends({}, location, {\n          pathname: router.stripBasename(location.pathname, basename) || location.pathname\n        }), matches) : getKey;\n        let disableScrollRestoration = router$1 == null ? void 0 : router$1.enableScrollRestoration(savedScrollPositions, () => window.scrollY, getKeyWithoutBasename);\n        return () => disableScrollRestoration && disableScrollRestoration();\n      }, [router$1, basename, getKey]);\n\n      // Restore scrolling when state.restoreScrollPosition changes\n      // eslint-disable-next-line react-hooks/rules-of-hooks\n      React__namespace.useLayoutEffect(() => {\n        // Explicit false means don't do anything (used for submissions)\n        if (restoreScrollPosition === false) {\n          return;\n        }\n\n        // been here before, scroll to it\n        if (typeof restoreScrollPosition === \"number\") {\n          window.scrollTo(0, restoreScrollPosition);\n          return;\n        }\n\n        // try to scroll to the hash\n        if (location.hash) {\n          let el = document.getElementById(decodeURIComponent(location.hash.slice(1)));\n          if (el) {\n            el.scrollIntoView();\n            return;\n          }\n        }\n\n        // Don't reset if this navigation opted out\n        if (preventScrollReset === true) {\n          return;\n        }\n\n        // otherwise go to the top on new locations\n        window.scrollTo(0, 0);\n      }, [location, restoreScrollPosition, preventScrollReset]);\n    }\n  }\n\n  /**\n   * Setup a callback to be fired on the window's `beforeunload` event. This is\n   * useful for saving some data to `window.localStorage` just before the page\n   * refreshes.\n   *\n   * Note: The `callback` argument should be a function created with\n   * `React.useCallback()`.\n   */\n  function useBeforeUnload(callback, options) {\n    let {\n      capture\n    } = options || {};\n    React__namespace.useEffect(() => {\n      let opts = capture != null ? {\n        capture\n      } : undefined;\n      window.addEventListener(\"beforeunload\", callback, opts);\n      return () => {\n        window.removeEventListener(\"beforeunload\", callback, opts);\n      };\n    }, [callback, capture]);\n  }\n\n  /**\n   * Setup a callback to be fired on the window's `pagehide` event. This is\n   * useful for saving some data to `window.localStorage` just before the page\n   * refreshes.  This event is better supported than beforeunload across browsers.\n   *\n   * Note: The `callback` argument should be a function created with\n   * `React.useCallback()`.\n   */\n  function usePageHide(callback, options) {\n    let {\n      capture\n    } = options || {};\n    React__namespace.useEffect(() => {\n      let opts = capture != null ? {\n        capture\n      } : undefined;\n      window.addEventListener(\"pagehide\", callback, opts);\n      return () => {\n        window.removeEventListener(\"pagehide\", callback, opts);\n      };\n    }, [callback, capture]);\n  }\n\n  /**\n   * Wrapper around useBlocker to show a window.confirm prompt to users instead\n   * of building a custom UI with useBlocker.\n   *\n   * Warning: This has *a lot of rough edges* and behaves very differently (and\n   * very incorrectly in some cases) across browsers if user click addition\n   * back/forward navigations while the confirm is open.  Use at your own risk.\n   */\n  function usePrompt(_ref12) {\n    let {\n      when,\n      message\n    } = _ref12;\n    let blocker = reactRouter.useBlocker(when);\n    React__namespace.useEffect(() => {\n      if (blocker.state === \"blocked\") {\n        let proceed = window.confirm(message);\n        if (proceed) {\n          // This timeout is needed to avoid a weird \"race\" on POP navigations\n          // between the `window.history` revert navigation and the result of\n          // `window.confirm`\n          setTimeout(blocker.proceed, 0);\n        } else {\n          blocker.reset();\n        }\n      }\n    }, [blocker, message]);\n    React__namespace.useEffect(() => {\n      if (blocker.state === \"blocked\" && !when) {\n        blocker.reset();\n      }\n    }, [blocker, when]);\n  }\n\n  /**\n   * Return a boolean indicating if there is an active view transition to the\n   * given href.  You can use this value to render CSS classes or viewTransitionName\n   * styles onto your elements\n   *\n   * @param href The destination href\n   * @param [opts.relative] Relative routing type (\"route\" | \"path\")\n   */\n  function useViewTransitionState(to, opts) {\n    if (opts === void 0) {\n      opts = {};\n    }\n    let vtContext = React__namespace.useContext(ViewTransitionContext);\n    !(vtContext != null) ? router.UNSAFE_invariant(false, \"`unstable_useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  \" + \"Did you accidentally import `RouterProvider` from `react-router`?\")  : void 0;\n    let {\n      basename\n    } = useDataRouterContext(DataRouterHook.useViewTransitionState);\n    let path = reactRouter.useResolvedPath(to, {\n      relative: opts.relative\n    });\n    if (!vtContext.isTransitioning) {\n      return false;\n    }\n    let currentPath = router.stripBasename(vtContext.currentLocation.pathname, basename) || vtContext.currentLocation.pathname;\n    let nextPath = router.stripBasename(vtContext.nextLocation.pathname, basename) || vtContext.nextLocation.pathname;\n\n    // Transition is active if we're going to or coming from the indicated\n    // destination.  This ensures that other PUSH navigations that reverse\n    // an indicated transition apply.  I.e., on the list view you have:\n    //\n    //   <NavLink to=\"/details/1\" unstable_viewTransition>\n    //\n    // If you click the breadcrumb back to the list view:\n    //\n    //   <NavLink to=\"/list\" unstable_viewTransition>\n    //\n    // We should apply the transition because it's indicated as active going\n    // from /list -> /details/1 and therefore should be active on the reverse\n    // (even though this isn't strictly a POP reverse)\n    return router.matchPath(path.pathname, nextPath) != null || router.matchPath(path.pathname, currentPath) != null;\n  }\n\n  //#endregion\n\n  Object.defineProperty(exports, 'AbortedDeferredError', {\n    enumerable: true,\n    get: function () { return reactRouter.AbortedDeferredError; }\n  });\n  Object.defineProperty(exports, 'Await', {\n    enumerable: true,\n    get: function () { return reactRouter.Await; }\n  });\n  Object.defineProperty(exports, 'MemoryRouter', {\n    enumerable: true,\n    get: function () { return reactRouter.MemoryRouter; }\n  });\n  Object.defineProperty(exports, 'Navigate', {\n    enumerable: true,\n    get: function () { return reactRouter.Navigate; }\n  });\n  Object.defineProperty(exports, 'NavigationType', {\n    enumerable: true,\n    get: function () { return reactRouter.NavigationType; }\n  });\n  Object.defineProperty(exports, 'Outlet', {\n    enumerable: true,\n    get: function () { return reactRouter.Outlet; }\n  });\n  Object.defineProperty(exports, 'Route', {\n    enumerable: true,\n    get: function () { return reactRouter.Route; }\n  });\n  Object.defineProperty(exports, 'Router', {\n    enumerable: true,\n    get: function () { return reactRouter.Router; }\n  });\n  Object.defineProperty(exports, 'Routes', {\n    enumerable: true,\n    get: function () { return reactRouter.Routes; }\n  });\n  Object.defineProperty(exports, 'UNSAFE_DataRouterContext', {\n    enumerable: true,\n    get: function () { return reactRouter.UNSAFE_DataRouterContext; }\n  });\n  Object.defineProperty(exports, 'UNSAFE_DataRouterStateContext', {\n    enumerable: true,\n    get: function () { return reactRouter.UNSAFE_DataRouterStateContext; }\n  });\n  Object.defineProperty(exports, 'UNSAFE_LocationContext', {\n    enumerable: true,\n    get: function () { return reactRouter.UNSAFE_LocationContext; }\n  });\n  Object.defineProperty(exports, 'UNSAFE_NavigationContext', {\n    enumerable: true,\n    get: function () { return reactRouter.UNSAFE_NavigationContext; }\n  });\n  Object.defineProperty(exports, 'UNSAFE_RouteContext', {\n    enumerable: true,\n    get: function () { return reactRouter.UNSAFE_RouteContext; }\n  });\n  Object.defineProperty(exports, 'UNSAFE_useRouteId', {\n    enumerable: true,\n    get: function () { return reactRouter.UNSAFE_useRouteId; }\n  });\n  Object.defineProperty(exports, 'createMemoryRouter', {\n    enumerable: true,\n    get: function () { return reactRouter.createMemoryRouter; }\n  });\n  Object.defineProperty(exports, 'createPath', {\n    enumerable: true,\n    get: function () { return reactRouter.createPath; }\n  });\n  Object.defineProperty(exports, 'createRoutesFromChildren', {\n    enumerable: true,\n    get: function () { return reactRouter.createRoutesFromChildren; }\n  });\n  Object.defineProperty(exports, 'createRoutesFromElements', {\n    enumerable: true,\n    get: function () { return reactRouter.createRoutesFromElements; }\n  });\n  Object.defineProperty(exports, 'defer', {\n    enumerable: true,\n    get: function () { return reactRouter.defer; }\n  });\n  Object.defineProperty(exports, 'generatePath', {\n    enumerable: true,\n    get: function () { return reactRouter.generatePath; }\n  });\n  Object.defineProperty(exports, 'isRouteErrorResponse', {\n    enumerable: true,\n    get: function () { return reactRouter.isRouteErrorResponse; }\n  });\n  Object.defineProperty(exports, 'json', {\n    enumerable: true,\n    get: function () { return reactRouter.json; }\n  });\n  Object.defineProperty(exports, 'matchPath', {\n    enumerable: true,\n    get: function () { return reactRouter.matchPath; }\n  });\n  Object.defineProperty(exports, 'matchRoutes', {\n    enumerable: true,\n    get: function () { return reactRouter.matchRoutes; }\n  });\n  Object.defineProperty(exports, 'parsePath', {\n    enumerable: true,\n    get: function () { return reactRouter.parsePath; }\n  });\n  Object.defineProperty(exports, 'redirect', {\n    enumerable: true,\n    get: function () { return reactRouter.redirect; }\n  });\n  Object.defineProperty(exports, 'redirectDocument', {\n    enumerable: true,\n    get: function () { return reactRouter.redirectDocument; }\n  });\n  Object.defineProperty(exports, 'renderMatches', {\n    enumerable: true,\n    get: function () { return reactRouter.renderMatches; }\n  });\n  Object.defineProperty(exports, 'resolvePath', {\n    enumerable: true,\n    get: function () { return reactRouter.resolvePath; }\n  });\n  Object.defineProperty(exports, 'useActionData', {\n    enumerable: true,\n    get: function () { return reactRouter.useActionData; }\n  });\n  Object.defineProperty(exports, 'useAsyncError', {\n    enumerable: true,\n    get: function () { return reactRouter.useAsyncError; }\n  });\n  Object.defineProperty(exports, 'useAsyncValue', {\n    enumerable: true,\n    get: function () { return reactRouter.useAsyncValue; }\n  });\n  Object.defineProperty(exports, 'useBlocker', {\n    enumerable: true,\n    get: function () { return reactRouter.useBlocker; }\n  });\n  Object.defineProperty(exports, 'useHref', {\n    enumerable: true,\n    get: function () { return reactRouter.useHref; }\n  });\n  Object.defineProperty(exports, 'useInRouterContext', {\n    enumerable: true,\n    get: function () { return reactRouter.useInRouterContext; }\n  });\n  Object.defineProperty(exports, 'useLoaderData', {\n    enumerable: true,\n    get: function () { return reactRouter.useLoaderData; }\n  });\n  Object.defineProperty(exports, 'useLocation', {\n    enumerable: true,\n    get: function () { return reactRouter.useLocation; }\n  });\n  Object.defineProperty(exports, 'useMatch', {\n    enumerable: true,\n    get: function () { return reactRouter.useMatch; }\n  });\n  Object.defineProperty(exports, 'useMatches', {\n    enumerable: true,\n    get: function () { return reactRouter.useMatches; }\n  });\n  Object.defineProperty(exports, 'useNavigate', {\n    enumerable: true,\n    get: function () { return reactRouter.useNavigate; }\n  });\n  Object.defineProperty(exports, 'useNavigation', {\n    enumerable: true,\n    get: function () { return reactRouter.useNavigation; }\n  });\n  Object.defineProperty(exports, 'useNavigationType', {\n    enumerable: true,\n    get: function () { return reactRouter.useNavigationType; }\n  });\n  Object.defineProperty(exports, 'useOutlet', {\n    enumerable: true,\n    get: function () { return reactRouter.useOutlet; }\n  });\n  Object.defineProperty(exports, 'useOutletContext', {\n    enumerable: true,\n    get: function () { return reactRouter.useOutletContext; }\n  });\n  Object.defineProperty(exports, 'useParams', {\n    enumerable: true,\n    get: function () { return reactRouter.useParams; }\n  });\n  Object.defineProperty(exports, 'useResolvedPath', {\n    enumerable: true,\n    get: function () { return reactRouter.useResolvedPath; }\n  });\n  Object.defineProperty(exports, 'useRevalidator', {\n    enumerable: true,\n    get: function () { return reactRouter.useRevalidator; }\n  });\n  Object.defineProperty(exports, 'useRouteError', {\n    enumerable: true,\n    get: function () { return reactRouter.useRouteError; }\n  });\n  Object.defineProperty(exports, 'useRouteLoaderData', {\n    enumerable: true,\n    get: function () { return reactRouter.useRouteLoaderData; }\n  });\n  Object.defineProperty(exports, 'useRoutes', {\n    enumerable: true,\n    get: function () { return reactRouter.useRoutes; }\n  });\n  exports.BrowserRouter = BrowserRouter;\n  exports.Form = Form;\n  exports.HashRouter = HashRouter;\n  exports.Link = Link;\n  exports.NavLink = NavLink;\n  exports.RouterProvider = RouterProvider;\n  exports.ScrollRestoration = ScrollRestoration;\n  exports.UNSAFE_FetchersContext = FetchersContext;\n  exports.UNSAFE_ViewTransitionContext = ViewTransitionContext;\n  exports.UNSAFE_useScrollRestoration = useScrollRestoration;\n  exports.createBrowserRouter = createBrowserRouter;\n  exports.createHashRouter = createHashRouter;\n  exports.createSearchParams = createSearchParams;\n  exports.unstable_HistoryRouter = HistoryRouter;\n  exports.unstable_usePrompt = usePrompt;\n  exports.unstable_useViewTransitionState = useViewTransitionState;\n  exports.useBeforeUnload = useBeforeUnload;\n  exports.useFetcher = useFetcher;\n  exports.useFetchers = useFetchers;\n  exports.useFormAction = useFormAction;\n  exports.useLinkClickHandler = useLinkClickHandler;\n  exports.useSearchParams = useSearchParams;\n  exports.useSubmit = useSubmit;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n//# sourceMappingURL=react-router-dom.development.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9kaXN0L3VtZC9yZWFjdC1yb3V0ZXItZG9tLmRldmVsb3BtZW50LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEtBQTRELG9CQUFvQixtQkFBTyxDQUFDLHdHQUFPLEdBQUcsbUJBQU8sQ0FBQyxnSEFBVyxHQUFHLG1CQUFPLENBQUMsb0VBQWMsR0FBRyxtQkFBTyxDQUFDLG9GQUFtQjtBQUM5SyxFQUFFLENBQ3NMO0FBQ3hMLENBQUMsb0VBQW9FOztBQUVyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0IsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQixzQkFBc0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsdUJBQXVCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGtCQUFrQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUwseUJBQXlCLE1BQU07QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0U7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcscUJBQXFCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLDBCQUEwQixHQUFHO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSx3QkFBd0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0seUJBQXlCO0FBQy9CO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSx5QkFBeUI7QUFDL0I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQSw0RUFBNEU7QUFDNUU7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHlCQUF5QjtBQUMvQjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsR0FBRztBQUNIO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsR0FBRztBQUNIO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsR0FBRztBQUNIO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsR0FBRztBQUNIO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsR0FBRztBQUNIO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsR0FBRztBQUNIO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsR0FBRztBQUNIO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsR0FBRztBQUNIO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsR0FBRztBQUNIO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsR0FBRztBQUNIO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsR0FBRztBQUNIO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsR0FBRztBQUNIO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsR0FBRztBQUNIO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsR0FBRztBQUNIO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsR0FBRztBQUNIO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsR0FBRztBQUNIO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsR0FBRztBQUNIO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsR0FBRztBQUNIO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsR0FBRztBQUNIO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsR0FBRztBQUNIO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsR0FBRztBQUNIO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsR0FBRztBQUNIO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsR0FBRztBQUNIO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsR0FBRztBQUNIO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsR0FBRztBQUNIO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsR0FBRztBQUNIO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsR0FBRztBQUNIO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsR0FBRztBQUNIO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsR0FBRztBQUNIO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsR0FBRztBQUNIO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsR0FBRztBQUNIO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsR0FBRztBQUNIO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsR0FBRztBQUNIO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsR0FBRztBQUNIO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsR0FBRztBQUNIO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsR0FBRztBQUNIO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsR0FBRztBQUNIO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsR0FBRztBQUNIO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsR0FBRztBQUNIO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsR0FBRztBQUNIO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsR0FBRztBQUNIO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsR0FBRztBQUNIO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsR0FBRztBQUNIO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsR0FBRztBQUNIO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsR0FBRztBQUNIO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsR0FBRztBQUNIO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsR0FBRztBQUNIO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsR0FBRztBQUNIO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsR0FBRztBQUNIO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsR0FBRztBQUNIO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaURBQWlELGFBQWE7O0FBRTlELENBQUM7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL3RlbXAvLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9kaXN0L3VtZC9yZWFjdC1yb3V0ZXItZG9tLmRldmVsb3BtZW50LmpzP2RjODEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBSZWFjdCBSb3V0ZXIgRE9NIHY2LjIyLjBcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIFJlbWl4IFNvZnR3YXJlIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UubWQgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzLCByZXF1aXJlKCdyZWFjdCcpLCByZXF1aXJlKCdyZWFjdC1kb20nKSwgcmVxdWlyZSgncmVhY3Qtcm91dGVyJyksIHJlcXVpcmUoJ0ByZW1peC1ydW4vcm91dGVyJykpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cycsICdyZWFjdCcsICdyZWFjdC1kb20nLCAncmVhY3Qtcm91dGVyJywgJ0ByZW1peC1ydW4vcm91dGVyJ10sIGZhY3RvcnkpIDpcbiAgKGdsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiBnbG9iYWwgfHwgc2VsZiwgZmFjdG9yeShnbG9iYWwuUmVhY3RSb3V0ZXJET00gPSB7fSwgZ2xvYmFsLlJlYWN0LCBnbG9iYWwuUmVhY3RET00sIGdsb2JhbC5SZWFjdFJvdXRlciwgZ2xvYmFsLlJlbWl4Um91dGVyKSk7XG59KSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMsIFJlYWN0LCBSZWFjdERPTSwgcmVhY3RSb3V0ZXIsIHJvdXRlcikgeyAndXNlIHN0cmljdCc7XG5cbiAgZnVuY3Rpb24gX2ludGVyb3BOYW1lc3BhY2UoZSkge1xuICAgIGlmIChlICYmIGUuX19lc01vZHVsZSkgcmV0dXJuIGU7XG4gICAgdmFyIG4gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGlmIChlKSB7XG4gICAgICBPYmplY3Qua2V5cyhlKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIGlmIChrICE9PSAnZGVmYXVsdCcpIHtcbiAgICAgICAgICB2YXIgZCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgayk7XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIGssIGQuZ2V0ID8gZCA6IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVba107IH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIG5bXCJkZWZhdWx0XCJdID0gZTtcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZShuKTtcbiAgfVxuXG4gIHZhciBSZWFjdF9fbmFtZXNwYWNlID0gLyojX19QVVJFX18qL19pbnRlcm9wTmFtZXNwYWNlKFJlYWN0KTtcbiAgdmFyIFJlYWN0RE9NX19uYW1lc3BhY2UgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BOYW1lc3BhY2UoUmVhY3RET00pO1xuXG4gIGZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICAgIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9O1xuICAgIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG4gIGZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgICB2YXIgdGFyZ2V0ID0ge307XG4gICAgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICAgIHZhciBrZXksIGk7XG4gICAgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleSA9IHNvdXJjZUtleXNbaV07XG4gICAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuXG4gIGNvbnN0IGRlZmF1bHRNZXRob2QgPSBcImdldFwiO1xuICBjb25zdCBkZWZhdWx0RW5jVHlwZSA9IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCI7XG4gIGZ1bmN0aW9uIGlzSHRtbEVsZW1lbnQob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIHR5cGVvZiBvYmplY3QudGFnTmFtZSA9PT0gXCJzdHJpbmdcIjtcbiAgfVxuICBmdW5jdGlvbiBpc0J1dHRvbkVsZW1lbnQob2JqZWN0KSB7XG4gICAgcmV0dXJuIGlzSHRtbEVsZW1lbnQob2JqZWN0KSAmJiBvYmplY3QudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImJ1dHRvblwiO1xuICB9XG4gIGZ1bmN0aW9uIGlzRm9ybUVsZW1lbnQob2JqZWN0KSB7XG4gICAgcmV0dXJuIGlzSHRtbEVsZW1lbnQob2JqZWN0KSAmJiBvYmplY3QudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImZvcm1cIjtcbiAgfVxuICBmdW5jdGlvbiBpc0lucHV0RWxlbWVudChvYmplY3QpIHtcbiAgICByZXR1cm4gaXNIdG1sRWxlbWVudChvYmplY3QpICYmIG9iamVjdC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiaW5wdXRcIjtcbiAgfVxuICBmdW5jdGlvbiBpc01vZGlmaWVkRXZlbnQoZXZlbnQpIHtcbiAgICByZXR1cm4gISEoZXZlbnQubWV0YUtleSB8fCBldmVudC5hbHRLZXkgfHwgZXZlbnQuY3RybEtleSB8fCBldmVudC5zaGlmdEtleSk7XG4gIH1cbiAgZnVuY3Rpb24gc2hvdWxkUHJvY2Vzc0xpbmtDbGljayhldmVudCwgdGFyZ2V0KSB7XG4gICAgcmV0dXJuIGV2ZW50LmJ1dHRvbiA9PT0gMCAmJiAoXG4gICAgLy8gSWdub3JlIGV2ZXJ5dGhpbmcgYnV0IGxlZnQgY2xpY2tzXG4gICAgIXRhcmdldCB8fCB0YXJnZXQgPT09IFwiX3NlbGZcIikgJiZcbiAgICAvLyBMZXQgYnJvd3NlciBoYW5kbGUgXCJ0YXJnZXQ9X2JsYW5rXCIgZXRjLlxuICAgICFpc01vZGlmaWVkRXZlbnQoZXZlbnQpIC8vIElnbm9yZSBjbGlja3Mgd2l0aCBtb2RpZmllciBrZXlzXG4gICAgO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBVUkxTZWFyY2hQYXJhbXMgb2JqZWN0IHVzaW5nIHRoZSBnaXZlbiBpbml0aWFsaXplci5cbiAgICpcbiAgICogVGhpcyBpcyBpZGVudGljYWwgdG8gYG5ldyBVUkxTZWFyY2hQYXJhbXMoaW5pdClgIGV4Y2VwdCBpdCBhbHNvXG4gICAqIHN1cHBvcnRzIGFycmF5cyBhcyB2YWx1ZXMgaW4gdGhlIG9iamVjdCBmb3JtIG9mIHRoZSBpbml0aWFsaXplclxuICAgKiBpbnN0ZWFkIG9mIGp1c3Qgc3RyaW5ncy4gVGhpcyBpcyBjb252ZW5pZW50IHdoZW4geW91IG5lZWQgbXVsdGlwbGVcbiAgICogdmFsdWVzIGZvciBhIGdpdmVuIGtleSwgYnV0IGRvbid0IHdhbnQgdG8gdXNlIGFuIGFycmF5IGluaXRpYWxpemVyLlxuICAgKlxuICAgKiBGb3IgZXhhbXBsZSwgaW5zdGVhZCBvZjpcbiAgICpcbiAgICogICBsZXQgc2VhcmNoUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhbXG4gICAqICAgICBbJ3NvcnQnLCAnbmFtZSddLFxuICAgKiAgICAgWydzb3J0JywgJ3ByaWNlJ11cbiAgICogICBdKTtcbiAgICpcbiAgICogeW91IGNhbiBkbzpcbiAgICpcbiAgICogICBsZXQgc2VhcmNoUGFyYW1zID0gY3JlYXRlU2VhcmNoUGFyYW1zKHtcbiAgICogICAgIHNvcnQ6IFsnbmFtZScsICdwcmljZSddXG4gICAqICAgfSk7XG4gICAqL1xuICBmdW5jdGlvbiBjcmVhdGVTZWFyY2hQYXJhbXMoaW5pdCkge1xuICAgIGlmIChpbml0ID09PSB2b2lkIDApIHtcbiAgICAgIGluaXQgPSBcIlwiO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFVSTFNlYXJjaFBhcmFtcyh0eXBlb2YgaW5pdCA9PT0gXCJzdHJpbmdcIiB8fCBBcnJheS5pc0FycmF5KGluaXQpIHx8IGluaXQgaW5zdGFuY2VvZiBVUkxTZWFyY2hQYXJhbXMgPyBpbml0IDogT2JqZWN0LmtleXMoaW5pdCkucmVkdWNlKChtZW1vLCBrZXkpID0+IHtcbiAgICAgIGxldCB2YWx1ZSA9IGluaXRba2V5XTtcbiAgICAgIHJldHVybiBtZW1vLmNvbmNhdChBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlLm1hcCh2ID0+IFtrZXksIHZdKSA6IFtba2V5LCB2YWx1ZV1dKTtcbiAgICB9LCBbXSkpO1xuICB9XG4gIGZ1bmN0aW9uIGdldFNlYXJjaFBhcmFtc0ZvckxvY2F0aW9uKGxvY2F0aW9uU2VhcmNoLCBkZWZhdWx0U2VhcmNoUGFyYW1zKSB7XG4gICAgbGV0IHNlYXJjaFBhcmFtcyA9IGNyZWF0ZVNlYXJjaFBhcmFtcyhsb2NhdGlvblNlYXJjaCk7XG4gICAgaWYgKGRlZmF1bHRTZWFyY2hQYXJhbXMpIHtcbiAgICAgIC8vIFVzZSBgZGVmYXVsdFNlYXJjaFBhcmFtcy5mb3JFYWNoKC4uLilgIGhlcmUgaW5zdGVhZCBvZiBpdGVyYXRpbmcgb2ZcbiAgICAgIC8vIGBkZWZhdWx0U2VhcmNoUGFyYW1zLmtleXMoKWAgdG8gd29yay1hcm91bmQgYSBidWcgaW4gRmlyZWZveCByZWxhdGVkIHRvXG4gICAgICAvLyB3ZWIgZXh0ZW5zaW9ucy4gUmVsZXZhbnQgQnVnemlsbGEgdGlja2V0czpcbiAgICAgIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTE0MTQ2MDJcbiAgICAgIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTEwMjM5ODRcbiAgICAgIGRlZmF1bHRTZWFyY2hQYXJhbXMuZm9yRWFjaCgoXywga2V5KSA9PiB7XG4gICAgICAgIGlmICghc2VhcmNoUGFyYW1zLmhhcyhrZXkpKSB7XG4gICAgICAgICAgZGVmYXVsdFNlYXJjaFBhcmFtcy5nZXRBbGwoa2V5KS5mb3JFYWNoKHZhbHVlID0+IHtcbiAgICAgICAgICAgIHNlYXJjaFBhcmFtcy5hcHBlbmQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gc2VhcmNoUGFyYW1zO1xuICB9XG5cbiAgLy8gVGhhbmtzIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5kcmVzb3JodXMvdHlwZS1mZXN0IVxuXG4gIC8vIE9uZS10aW1lIGNoZWNrIGZvciBzdWJtaXR0ZXIgc3VwcG9ydFxuICBsZXQgX2Zvcm1EYXRhU3VwcG9ydHNTdWJtaXR0ZXIgPSBudWxsO1xuICBmdW5jdGlvbiBpc0Zvcm1EYXRhU3VibWl0dGVyU3VwcG9ydGVkKCkge1xuICAgIGlmIChfZm9ybURhdGFTdXBwb3J0c1N1Ym1pdHRlciA9PT0gbnVsbCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbmV3IEZvcm1EYXRhKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJmb3JtXCIpLFxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGlmIEZvcm1EYXRhIHN1cHBvcnRzIHRoZSBzdWJtaXR0ZXIgcGFyYW1ldGVyLCB0aGlzIHdpbGwgdGhyb3dcbiAgICAgICAgMCk7XG4gICAgICAgIF9mb3JtRGF0YVN1cHBvcnRzU3VibWl0dGVyID0gZmFsc2U7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIF9mb3JtRGF0YVN1cHBvcnRzU3VibWl0dGVyID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIF9mb3JtRGF0YVN1cHBvcnRzU3VibWl0dGVyO1xuICB9XG4gIGNvbnN0IHN1cHBvcnRlZEZvcm1FbmNUeXBlcyA9IG5ldyBTZXQoW1wiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIsIFwibXVsdGlwYXJ0L2Zvcm0tZGF0YVwiLCBcInRleHQvcGxhaW5cIl0pO1xuICBmdW5jdGlvbiBnZXRGb3JtRW5jVHlwZShlbmNUeXBlKSB7XG4gICAgaWYgKGVuY1R5cGUgIT0gbnVsbCAmJiAhc3VwcG9ydGVkRm9ybUVuY1R5cGVzLmhhcyhlbmNUeXBlKSkge1xuICAgICAgcm91dGVyLlVOU0FGRV93YXJuaW5nKGZhbHNlLCBcIlxcXCJcIiArIGVuY1R5cGUgKyBcIlxcXCIgaXMgbm90IGEgdmFsaWQgYGVuY1R5cGVgIGZvciBgPEZvcm0+YC9gPGZldGNoZXIuRm9ybT5gIFwiICsgKFwiYW5kIHdpbGwgZGVmYXVsdCB0byBcXFwiXCIgKyBkZWZhdWx0RW5jVHlwZSArIFwiXFxcIlwiKSkgO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBlbmNUeXBlO1xuICB9XG4gIGZ1bmN0aW9uIGdldEZvcm1TdWJtaXNzaW9uSW5mbyh0YXJnZXQsIGJhc2VuYW1lKSB7XG4gICAgbGV0IG1ldGhvZDtcbiAgICBsZXQgYWN0aW9uO1xuICAgIGxldCBlbmNUeXBlO1xuICAgIGxldCBmb3JtRGF0YTtcbiAgICBsZXQgYm9keTtcbiAgICBpZiAoaXNGb3JtRWxlbWVudCh0YXJnZXQpKSB7XG4gICAgICAvLyBXaGVuIGdyYWJiaW5nIHRoZSBhY3Rpb24gZnJvbSB0aGUgZWxlbWVudCwgaXQgd2lsbCBoYXZlIGhhZCB0aGUgYmFzZW5hbWVcbiAgICAgIC8vIHByZWZpeGVkIHRvIGVuc3VyZSBub24tSlMgc2NlbmFyaW9zIHdvcmssIHNvIHN0cmlwIGl0IHNpbmNlIHdlJ2xsXG4gICAgICAvLyByZS1wcmVmaXggaW4gdGhlIHJvdXRlclxuICAgICAgbGV0IGF0dHIgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKFwiYWN0aW9uXCIpO1xuICAgICAgYWN0aW9uID0gYXR0ciA/IHJvdXRlci5zdHJpcEJhc2VuYW1lKGF0dHIsIGJhc2VuYW1lKSA6IG51bGw7XG4gICAgICBtZXRob2QgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKFwibWV0aG9kXCIpIHx8IGRlZmF1bHRNZXRob2Q7XG4gICAgICBlbmNUeXBlID0gZ2V0Rm9ybUVuY1R5cGUodGFyZ2V0LmdldEF0dHJpYnV0ZShcImVuY3R5cGVcIikpIHx8IGRlZmF1bHRFbmNUeXBlO1xuICAgICAgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEodGFyZ2V0KTtcbiAgICB9IGVsc2UgaWYgKGlzQnV0dG9uRWxlbWVudCh0YXJnZXQpIHx8IGlzSW5wdXRFbGVtZW50KHRhcmdldCkgJiYgKHRhcmdldC50eXBlID09PSBcInN1Ym1pdFwiIHx8IHRhcmdldC50eXBlID09PSBcImltYWdlXCIpKSB7XG4gICAgICBsZXQgZm9ybSA9IHRhcmdldC5mb3JtO1xuICAgICAgaWYgKGZvcm0gPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc3VibWl0IGEgPGJ1dHRvbj4gb3IgPGlucHV0IHR5cGU9XFxcInN1Ym1pdFxcXCI+IHdpdGhvdXQgYSA8Zm9ybT5cIik7XG4gICAgICB9XG5cbiAgICAgIC8vIDxidXR0b24+LzxpbnB1dCB0eXBlPVwic3VibWl0XCI+IG1heSBvdmVycmlkZSBhdHRyaWJ1dGVzIG9mIDxmb3JtPlxuXG4gICAgICAvLyBXaGVuIGdyYWJiaW5nIHRoZSBhY3Rpb24gZnJvbSB0aGUgZWxlbWVudCwgaXQgd2lsbCBoYXZlIGhhZCB0aGUgYmFzZW5hbWVcbiAgICAgIC8vIHByZWZpeGVkIHRvIGVuc3VyZSBub24tSlMgc2NlbmFyaW9zIHdvcmssIHNvIHN0cmlwIGl0IHNpbmNlIHdlJ2xsXG4gICAgICAvLyByZS1wcmVmaXggaW4gdGhlIHJvdXRlclxuICAgICAgbGV0IGF0dHIgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKFwiZm9ybWFjdGlvblwiKSB8fCBmb3JtLmdldEF0dHJpYnV0ZShcImFjdGlvblwiKTtcbiAgICAgIGFjdGlvbiA9IGF0dHIgPyByb3V0ZXIuc3RyaXBCYXNlbmFtZShhdHRyLCBiYXNlbmFtZSkgOiBudWxsO1xuICAgICAgbWV0aG9kID0gdGFyZ2V0LmdldEF0dHJpYnV0ZShcImZvcm1tZXRob2RcIikgfHwgZm9ybS5nZXRBdHRyaWJ1dGUoXCJtZXRob2RcIikgfHwgZGVmYXVsdE1ldGhvZDtcbiAgICAgIGVuY1R5cGUgPSBnZXRGb3JtRW5jVHlwZSh0YXJnZXQuZ2V0QXR0cmlidXRlKFwiZm9ybWVuY3R5cGVcIikpIHx8IGdldEZvcm1FbmNUeXBlKGZvcm0uZ2V0QXR0cmlidXRlKFwiZW5jdHlwZVwiKSkgfHwgZGVmYXVsdEVuY1R5cGU7XG5cbiAgICAgIC8vIEJ1aWxkIGEgRm9ybURhdGEgb2JqZWN0IHBvcHVsYXRlZCBmcm9tIGEgZm9ybSBhbmQgc3VibWl0dGVyXG4gICAgICBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YShmb3JtLCB0YXJnZXQpO1xuXG4gICAgICAvLyBJZiB0aGlzIGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0IHRoZSBgRm9ybURhdGEoZWwsIHN1Ym1pdHRlcilgIGZvcm1hdCxcbiAgICAgIC8vIHRoZW4gdGFjayBvbiB0aGUgc3VibWl0dGVyIHZhbHVlIGF0IHRoZSBlbmQuICBUaGlzIGlzIGEgbGlnaHR3ZWlnaHRcbiAgICAgIC8vIHNvbHV0aW9uIHRoYXQgaXMgbm90IDEwMCUgc3BlYyBjb21wbGlhbnQuICBGb3IgY29tcGxldGUgc3VwcG9ydCBpbiBvbGRlclxuICAgICAgLy8gYnJvd3NlcnMsIGNvbnNpZGVyIHVzaW5nIHRoZSBgZm9ybWRhdGEtc3VibWl0dGVyLXBvbHlmaWxsYCBwYWNrYWdlXG4gICAgICBpZiAoIWlzRm9ybURhdGFTdWJtaXR0ZXJTdXBwb3J0ZWQoKSkge1xuICAgICAgICBsZXQge1xuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICB2YWx1ZVxuICAgICAgICB9ID0gdGFyZ2V0O1xuICAgICAgICBpZiAodHlwZSA9PT0gXCJpbWFnZVwiKSB7XG4gICAgICAgICAgbGV0IHByZWZpeCA9IG5hbWUgPyBuYW1lICsgXCIuXCIgOiBcIlwiO1xuICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChwcmVmaXggKyBcInhcIiwgXCIwXCIpO1xuICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChwcmVmaXggKyBcInlcIiwgXCIwXCIpO1xuICAgICAgICB9IGVsc2UgaWYgKG5hbWUpIHtcbiAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQobmFtZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc0h0bWxFbGVtZW50KHRhcmdldCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzdWJtaXQgZWxlbWVudCB0aGF0IGlzIG5vdCA8Zm9ybT4sIDxidXR0b24+LCBvciBcIiArIFwiPGlucHV0IHR5cGU9XFxcInN1Ym1pdHxpbWFnZVxcXCI+XCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtZXRob2QgPSBkZWZhdWx0TWV0aG9kO1xuICAgICAgYWN0aW9uID0gbnVsbDtcbiAgICAgIGVuY1R5cGUgPSBkZWZhdWx0RW5jVHlwZTtcbiAgICAgIGJvZHkgPSB0YXJnZXQ7XG4gICAgfVxuXG4gICAgLy8gU2VuZCBib2R5IGZvciA8Rm9ybSBlbmNUeXBlPVwidGV4dC9wbGFpblwiIHNvIHdlIGVuY29kZSBpdCBpbnRvIHRleHRcbiAgICBpZiAoZm9ybURhdGEgJiYgZW5jVHlwZSA9PT0gXCJ0ZXh0L3BsYWluXCIpIHtcbiAgICAgIGJvZHkgPSBmb3JtRGF0YTtcbiAgICAgIGZvcm1EYXRhID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgYWN0aW9uLFxuICAgICAgbWV0aG9kOiBtZXRob2QudG9Mb3dlckNhc2UoKSxcbiAgICAgIGVuY1R5cGUsXG4gICAgICBmb3JtRGF0YSxcbiAgICAgIGJvZHlcbiAgICB9O1xuICB9XG5cbiAgY29uc3QgX2V4Y2x1ZGVkID0gW1wib25DbGlja1wiLCBcInJlbGF0aXZlXCIsIFwicmVsb2FkRG9jdW1lbnRcIiwgXCJyZXBsYWNlXCIsIFwic3RhdGVcIiwgXCJ0YXJnZXRcIiwgXCJ0b1wiLCBcInByZXZlbnRTY3JvbGxSZXNldFwiLCBcInVuc3RhYmxlX3ZpZXdUcmFuc2l0aW9uXCJdLFxuICAgIF9leGNsdWRlZDIgPSBbXCJhcmlhLWN1cnJlbnRcIiwgXCJjYXNlU2Vuc2l0aXZlXCIsIFwiY2xhc3NOYW1lXCIsIFwiZW5kXCIsIFwic3R5bGVcIiwgXCJ0b1wiLCBcInVuc3RhYmxlX3ZpZXdUcmFuc2l0aW9uXCIsIFwiY2hpbGRyZW5cIl0sXG4gICAgX2V4Y2x1ZGVkMyA9IFtcImZldGNoZXJLZXlcIiwgXCJuYXZpZ2F0ZVwiLCBcInJlbG9hZERvY3VtZW50XCIsIFwicmVwbGFjZVwiLCBcInN0YXRlXCIsIFwibWV0aG9kXCIsIFwiYWN0aW9uXCIsIFwib25TdWJtaXRcIiwgXCJyZWxhdGl2ZVwiLCBcInByZXZlbnRTY3JvbGxSZXNldFwiLCBcInVuc3RhYmxlX3ZpZXdUcmFuc2l0aW9uXCJdO1xuICAvLyNlbmRyZWdpb25cbiAgLy8gSEVZIFlPVSEgRE9OJ1QgVE9VQ0ggVEhJUyBWQVJJQUJMRSFcbiAgLy9cbiAgLy8gSXQgaXMgcmVwbGFjZWQgd2l0aCB0aGUgcHJvcGVyIHZlcnNpb24gYXQgYnVpbGQgdGltZSB2aWEgYSBiYWJlbCBwbHVnaW4gaW5cbiAgLy8gdGhlIHJvbGx1cCBjb25maWcuXG4gIC8vXG4gIC8vIEV4cG9ydCBhIGdsb2JhbCBwcm9wZXJ0eSBvbnRvIHRoZSB3aW5kb3cgZm9yIFJlYWN0IFJvdXRlciBkZXRlY3Rpb24gYnkgdGhlXG4gIC8vIENvcmUgV2ViIFZpdGFscyBUZWNobm9sb2d5IFJlcG9ydC4gIFRoaXMgd2F5IHRoZXkgY2FuIGNvbmZpZ3VyZSB0aGUgYHdhcHBhbHl6ZXJgXG4gIC8vIHRvIGRldGVjdCBhbmQgcHJvcGVybHkgY2xhc3NpZnkgbGl2ZSB3ZWJzaXRlcyBhcyBiZWluZyBidWlsdCB3aXRoIFJlYWN0IFJvdXRlcjpcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL0hUVFBBcmNoaXZlL3dhcHBhbHl6ZXIvYmxvYi9tYWluL3NyYy90ZWNobm9sb2dpZXMvci5qc29uXG4gIGNvbnN0IFJFQUNUX1JPVVRFUl9WRVJTSU9OID0gXCI2XCI7XG4gIHRyeSB7XG4gICAgd2luZG93Ll9fcmVhY3RSb3V0ZXJWZXJzaW9uID0gUkVBQ1RfUk9VVEVSX1ZFUlNJT047XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBuby1vcFxuICB9XG5cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgLy8jcmVnaW9uIFJvdXRlcnNcbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgZnVuY3Rpb24gY3JlYXRlQnJvd3NlclJvdXRlcihyb3V0ZXMsIG9wdHMpIHtcbiAgICByZXR1cm4gcm91dGVyLmNyZWF0ZVJvdXRlcih7XG4gICAgICBiYXNlbmFtZTogb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5iYXNlbmFtZSxcbiAgICAgIGZ1dHVyZTogX2V4dGVuZHMoe30sIG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMuZnV0dXJlLCB7XG4gICAgICAgIHY3X3ByZXBlbmRCYXNlbmFtZTogdHJ1ZVxuICAgICAgfSksXG4gICAgICBoaXN0b3J5OiByb3V0ZXIuY3JlYXRlQnJvd3Nlckhpc3Rvcnkoe1xuICAgICAgICB3aW5kb3c6IG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMud2luZG93XG4gICAgICB9KSxcbiAgICAgIGh5ZHJhdGlvbkRhdGE6IChvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLmh5ZHJhdGlvbkRhdGEpIHx8IHBhcnNlSHlkcmF0aW9uRGF0YSgpLFxuICAgICAgcm91dGVzLFxuICAgICAgbWFwUm91dGVQcm9wZXJ0aWVzOiByZWFjdFJvdXRlci5VTlNBRkVfbWFwUm91dGVQcm9wZXJ0aWVzLFxuICAgICAgd2luZG93OiBvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLndpbmRvd1xuICAgIH0pLmluaXRpYWxpemUoKTtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVIYXNoUm91dGVyKHJvdXRlcywgb3B0cykge1xuICAgIHJldHVybiByb3V0ZXIuY3JlYXRlUm91dGVyKHtcbiAgICAgIGJhc2VuYW1lOiBvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLmJhc2VuYW1lLFxuICAgICAgZnV0dXJlOiBfZXh0ZW5kcyh7fSwgb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5mdXR1cmUsIHtcbiAgICAgICAgdjdfcHJlcGVuZEJhc2VuYW1lOiB0cnVlXG4gICAgICB9KSxcbiAgICAgIGhpc3Rvcnk6IHJvdXRlci5jcmVhdGVIYXNoSGlzdG9yeSh7XG4gICAgICAgIHdpbmRvdzogb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy53aW5kb3dcbiAgICAgIH0pLFxuICAgICAgaHlkcmF0aW9uRGF0YTogKG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMuaHlkcmF0aW9uRGF0YSkgfHwgcGFyc2VIeWRyYXRpb25EYXRhKCksXG4gICAgICByb3V0ZXMsXG4gICAgICBtYXBSb3V0ZVByb3BlcnRpZXM6IHJlYWN0Um91dGVyLlVOU0FGRV9tYXBSb3V0ZVByb3BlcnRpZXMsXG4gICAgICB3aW5kb3c6IG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMud2luZG93XG4gICAgfSkuaW5pdGlhbGl6ZSgpO1xuICB9XG4gIGZ1bmN0aW9uIHBhcnNlSHlkcmF0aW9uRGF0YSgpIHtcbiAgICB2YXIgX3dpbmRvdztcbiAgICBsZXQgc3RhdGUgPSAoX3dpbmRvdyA9IHdpbmRvdykgPT0gbnVsbCA/IHZvaWQgMCA6IF93aW5kb3cuX19zdGF0aWNSb3V0ZXJIeWRyYXRpb25EYXRhO1xuICAgIGlmIChzdGF0ZSAmJiBzdGF0ZS5lcnJvcnMpIHtcbiAgICAgIHN0YXRlID0gX2V4dGVuZHMoe30sIHN0YXRlLCB7XG4gICAgICAgIGVycm9yczogZGVzZXJpYWxpemVFcnJvcnMoc3RhdGUuZXJyb3JzKVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuICBmdW5jdGlvbiBkZXNlcmlhbGl6ZUVycm9ycyhlcnJvcnMpIHtcbiAgICBpZiAoIWVycm9ycykgcmV0dXJuIG51bGw7XG4gICAgbGV0IGVudHJpZXMgPSBPYmplY3QuZW50cmllcyhlcnJvcnMpO1xuICAgIGxldCBzZXJpYWxpemVkID0ge307XG4gICAgZm9yIChsZXQgW2tleSwgdmFsXSBvZiBlbnRyaWVzKSB7XG4gICAgICAvLyBIZXkgeW91ISAgSWYgeW91IGNoYW5nZSB0aGlzLCBwbGVhc2UgY2hhbmdlIHRoZSBjb3JyZXNwb25kaW5nIGxvZ2ljIGluXG4gICAgICAvLyBzZXJpYWxpemVFcnJvcnMgaW4gcmVhY3Qtcm91dGVyLWRvbS9zZXJ2ZXIudHN4IDopXG4gICAgICBpZiAodmFsICYmIHZhbC5fX3R5cGUgPT09IFwiUm91dGVFcnJvclJlc3BvbnNlXCIpIHtcbiAgICAgICAgc2VyaWFsaXplZFtrZXldID0gbmV3IHJvdXRlci5VTlNBRkVfRXJyb3JSZXNwb25zZUltcGwodmFsLnN0YXR1cywgdmFsLnN0YXR1c1RleHQsIHZhbC5kYXRhLCB2YWwuaW50ZXJuYWwgPT09IHRydWUpO1xuICAgICAgfSBlbHNlIGlmICh2YWwgJiYgdmFsLl9fdHlwZSA9PT0gXCJFcnJvclwiKSB7XG4gICAgICAgIC8vIEF0dGVtcHQgdG8gcmVjb25zdHJ1Y3QgdGhlIHJpZ2h0IHR5cGUgb2YgRXJyb3IgKGkuZS4sIFJlZmVyZW5jZUVycm9yKVxuICAgICAgICBpZiAodmFsLl9fc3ViVHlwZSkge1xuICAgICAgICAgIGxldCBFcnJvckNvbnN0cnVjdG9yID0gd2luZG93W3ZhbC5fX3N1YlR5cGVdO1xuICAgICAgICAgIGlmICh0eXBlb2YgRXJyb3JDb25zdHJ1Y3RvciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgIGxldCBlcnJvciA9IG5ldyBFcnJvckNvbnN0cnVjdG9yKHZhbC5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgLy8gV2lwZSBhd2F5IHRoZSBjbGllbnQtc2lkZSBzdGFjayB0cmFjZS4gIE5vdGhpbmcgdG8gZmlsbCBpdCBpbiB3aXRoXG4gICAgICAgICAgICAgIC8vIGJlY2F1c2Ugd2UgZG9uJ3Qgc2VyaWFsaXplIFNTUiBzdGFjayB0cmFjZXMgZm9yIHNlY3VyaXR5IHJlYXNvbnNcbiAgICAgICAgICAgICAgZXJyb3Iuc3RhY2sgPSBcIlwiO1xuICAgICAgICAgICAgICBzZXJpYWxpemVkW2tleV0gPSBlcnJvcjtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgLy8gbm8tb3AgLSBmYWxsIHRocm91Z2ggYW5kIGNyZWF0ZSBhIG5vcm1hbCBFcnJvclxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VyaWFsaXplZFtrZXldID09IG51bGwpIHtcbiAgICAgICAgICBsZXQgZXJyb3IgPSBuZXcgRXJyb3IodmFsLm1lc3NhZ2UpO1xuICAgICAgICAgIC8vIFdpcGUgYXdheSB0aGUgY2xpZW50LXNpZGUgc3RhY2sgdHJhY2UuICBOb3RoaW5nIHRvIGZpbGwgaXQgaW4gd2l0aFxuICAgICAgICAgIC8vIGJlY2F1c2Ugd2UgZG9uJ3Qgc2VyaWFsaXplIFNTUiBzdGFjayB0cmFjZXMgZm9yIHNlY3VyaXR5IHJlYXNvbnNcbiAgICAgICAgICBlcnJvci5zdGFjayA9IFwiXCI7XG4gICAgICAgICAgc2VyaWFsaXplZFtrZXldID0gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlcmlhbGl6ZWRba2V5XSA9IHZhbDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG4gIH1cblxuICAvLyNlbmRyZWdpb25cblxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAvLyNyZWdpb24gQ29udGV4dHNcbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgY29uc3QgVmlld1RyYW5zaXRpb25Db250ZXh0ID0gLyojX19QVVJFX18qL1JlYWN0X19uYW1lc3BhY2UuY3JlYXRlQ29udGV4dCh7XG4gICAgaXNUcmFuc2l0aW9uaW5nOiBmYWxzZVxuICB9KTtcbiAge1xuICAgIFZpZXdUcmFuc2l0aW9uQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiVmlld1RyYW5zaXRpb25cIjtcbiAgfVxuXG4gIC8vIFRPRE86ICh2NykgQ2hhbmdlIHRoZSB1c2VGZXRjaGVyIGRhdGEgZnJvbSBgYW55YCB0byBgdW5rbm93bmBcblxuICBjb25zdCBGZXRjaGVyc0NvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVDb250ZXh0KG5ldyBNYXAoKSk7XG4gIHtcbiAgICBGZXRjaGVyc0NvbnRleHQuZGlzcGxheU5hbWUgPSBcIkZldGNoZXJzXCI7XG4gIH1cblxuICAvLyNlbmRyZWdpb25cblxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAvLyNyZWdpb24gQ29tcG9uZW50c1xuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gIC8qKlxuICAgIFdlYnBhY2sgKyBSZWFjdCAxNyBmYWlscyB0byBjb21waWxlIG9uIGFueSBvZiB0aGUgZm9sbG93aW5nIGJlY2F1c2Ugd2VicGFja1xuICAgIGNvbXBsYWlucyB0aGF0IGBzdGFydFRyYW5zaXRpb25gIGRvZXNuJ3QgZXhpc3QgaW4gYFJlYWN0YDpcbiAgICAqIGltcG9ydCB7IHN0YXJ0VHJhbnNpdGlvbiB9IGZyb20gXCJyZWFjdFwiXG4gICAgKiBpbXBvcnQgKiBhcyBSZWFjdCBmcm9tIGZyb20gXCJyZWFjdFwiO1xuICAgICAgXCJzdGFydFRyYW5zaXRpb25cIiBpbiBSZWFjdCA/IFJlYWN0LnN0YXJ0VHJhbnNpdGlvbigoKSA9PiBzZXRTdGF0ZSgpKSA6IHNldFN0YXRlKClcbiAgICAqIGltcG9ydCAqIGFzIFJlYWN0IGZyb20gZnJvbSBcInJlYWN0XCI7XG4gICAgICBcInN0YXJ0VHJhbnNpdGlvblwiIGluIFJlYWN0ID8gUmVhY3RbXCJzdGFydFRyYW5zaXRpb25cIl0oKCkgPT4gc2V0U3RhdGUoKSkgOiBzZXRTdGF0ZSgpXG5cbiAgICBNb3ZpbmcgaXQgdG8gYSBjb25zdGFudCBzdWNoIGFzIHRoZSBmb2xsb3dpbmcgc29sdmVzIHRoZSBXZWJwYWNrL1JlYWN0IDE3IGlzc3VlOlxuICAgICogaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBmcm9tIFwicmVhY3RcIjtcbiAgICAgIGNvbnN0IFNUQVJUX1RSQU5TSVRJT04gPSBcInN0YXJ0VHJhbnNpdGlvblwiO1xuICAgICAgU1RBUlRfVFJBTlNJVElPTiBpbiBSZWFjdCA/IFJlYWN0W1NUQVJUX1RSQU5TSVRJT05dKCgpID0+IHNldFN0YXRlKCkpIDogc2V0U3RhdGUoKVxuXG4gICAgSG93ZXZlciwgdGhhdCBpbnRyb2R1Y2VzIHdlYnBhY2svdGVyc2VyIG1pbmlmaWNhdGlvbiBpc3N1ZXMgaW4gcHJvZHVjdGlvbiBidWlsZHNcbiAgICBpbiBSZWFjdCAxOCB3aGVyZSBtaW5pZmljYXRpb24vb2JmdXNjYXRpb24gZW5kcyB1cCByZW1vdmluZyB0aGUgY2FsbCBvZlxuICAgIFJlYWN0LnN0YXJ0VHJhbnNpdGlvbiBlbnRpcmVseSBmcm9tIHRoZSBmaXJzdCBoYWxmIG9mIHRoZSB0ZXJuYXJ5LiAgR3JhYmJpbmdcbiAgICB0aGlzIGV4cG9ydGVkIHJlZmVyZW5jZSBvbmNlIHVwIGZyb250IHJlc29sdmVzIHRoYXQgaXNzdWUuXG5cbiAgICBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3JlbWl4LXJ1bi9yZWFjdC1yb3V0ZXIvaXNzdWVzLzEwNTc5XG4gICovXG4gIGNvbnN0IFNUQVJUX1RSQU5TSVRJT04gPSBcInN0YXJ0VHJhbnNpdGlvblwiO1xuICBjb25zdCBzdGFydFRyYW5zaXRpb25JbXBsID0gUmVhY3RfX25hbWVzcGFjZVtTVEFSVF9UUkFOU0lUSU9OXTtcbiAgY29uc3QgRkxVU0hfU1lOQyA9IFwiZmx1c2hTeW5jXCI7XG4gIGNvbnN0IGZsdXNoU3luY0ltcGwgPSBSZWFjdERPTV9fbmFtZXNwYWNlW0ZMVVNIX1NZTkNdO1xuICBjb25zdCBVU0VfSUQgPSBcInVzZUlkXCI7XG4gIGNvbnN0IHVzZUlkSW1wbCA9IFJlYWN0X19uYW1lc3BhY2VbVVNFX0lEXTtcbiAgZnVuY3Rpb24gc3RhcnRUcmFuc2l0aW9uU2FmZShjYikge1xuICAgIGlmIChzdGFydFRyYW5zaXRpb25JbXBsKSB7XG4gICAgICBzdGFydFRyYW5zaXRpb25JbXBsKGNiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2IoKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZmx1c2hTeW5jU2FmZShjYikge1xuICAgIGlmIChmbHVzaFN5bmNJbXBsKSB7XG4gICAgICBmbHVzaFN5bmNJbXBsKGNiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2IoKTtcbiAgICB9XG4gIH1cbiAgY2xhc3MgRGVmZXJyZWQge1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLSBubyBpbml0aWFsaXplclxuXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciAtIG5vIGluaXRpYWxpemVyXG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIHRoaXMuc3RhdHVzID0gXCJwZW5kaW5nXCI7XG4gICAgICB0aGlzLnByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHRoaXMucmVzb2x2ZSA9IHZhbHVlID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT09IFwicGVuZGluZ1wiKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXR1cyA9IFwicmVzb2x2ZWRcIjtcbiAgICAgICAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5yZWplY3QgPSByZWFzb24gPT4ge1xuICAgICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gXCJwZW5kaW5nXCIpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzID0gXCJyZWplY3RlZFwiO1xuICAgICAgICAgICAgcmVqZWN0KHJlYXNvbik7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdpdmVuIGEgUmVtaXggUm91dGVyIGluc3RhbmNlLCByZW5kZXIgdGhlIGFwcHJvcHJpYXRlIFVJXG4gICAqL1xuICBmdW5jdGlvbiBSb3V0ZXJQcm92aWRlcihfcmVmKSB7XG4gICAgbGV0IHtcbiAgICAgIGZhbGxiYWNrRWxlbWVudCxcbiAgICAgIHJvdXRlcjogcm91dGVyJDEsXG4gICAgICBmdXR1cmVcbiAgICB9ID0gX3JlZjtcbiAgICBsZXQgW3N0YXRlLCBzZXRTdGF0ZUltcGxdID0gUmVhY3RfX25hbWVzcGFjZS51c2VTdGF0ZShyb3V0ZXIkMS5zdGF0ZSk7XG4gICAgbGV0IFtwZW5kaW5nU3RhdGUsIHNldFBlbmRpbmdTdGF0ZV0gPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVN0YXRlKCk7XG4gICAgbGV0IFt2dENvbnRleHQsIHNldFZ0Q29udGV4dF0gPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVN0YXRlKHtcbiAgICAgIGlzVHJhbnNpdGlvbmluZzogZmFsc2VcbiAgICB9KTtcbiAgICBsZXQgW3JlbmRlckRmZCwgc2V0UmVuZGVyRGZkXSA9IFJlYWN0X19uYW1lc3BhY2UudXNlU3RhdGUoKTtcbiAgICBsZXQgW3RyYW5zaXRpb24sIHNldFRyYW5zaXRpb25dID0gUmVhY3RfX25hbWVzcGFjZS51c2VTdGF0ZSgpO1xuICAgIGxldCBbaW50ZXJydXB0aW9uLCBzZXRJbnRlcnJ1cHRpb25dID0gUmVhY3RfX25hbWVzcGFjZS51c2VTdGF0ZSgpO1xuICAgIGxldCBmZXRjaGVyRGF0YSA9IFJlYWN0X19uYW1lc3BhY2UudXNlUmVmKG5ldyBNYXAoKSk7XG4gICAgbGV0IHtcbiAgICAgIHY3X3N0YXJ0VHJhbnNpdGlvblxuICAgIH0gPSBmdXR1cmUgfHwge307XG4gICAgbGV0IG9wdEluU3RhcnRUcmFuc2l0aW9uID0gUmVhY3RfX25hbWVzcGFjZS51c2VDYWxsYmFjayhjYiA9PiB7XG4gICAgICBpZiAodjdfc3RhcnRUcmFuc2l0aW9uKSB7XG4gICAgICAgIHN0YXJ0VHJhbnNpdGlvblNhZmUoY2IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2IoKTtcbiAgICAgIH1cbiAgICB9LCBbdjdfc3RhcnRUcmFuc2l0aW9uXSk7XG4gICAgbGV0IHNldFN0YXRlID0gUmVhY3RfX25hbWVzcGFjZS51c2VDYWxsYmFjaygobmV3U3RhdGUsIF9yZWYyKSA9PiB7XG4gICAgICBsZXQge1xuICAgICAgICBkZWxldGVkRmV0Y2hlcnMsXG4gICAgICAgIHVuc3RhYmxlX2ZsdXNoU3luYzogZmx1c2hTeW5jLFxuICAgICAgICB1bnN0YWJsZV92aWV3VHJhbnNpdGlvbk9wdHM6IHZpZXdUcmFuc2l0aW9uT3B0c1xuICAgICAgfSA9IF9yZWYyO1xuICAgICAgZGVsZXRlZEZldGNoZXJzLmZvckVhY2goa2V5ID0+IGZldGNoZXJEYXRhLmN1cnJlbnQuZGVsZXRlKGtleSkpO1xuICAgICAgbmV3U3RhdGUuZmV0Y2hlcnMuZm9yRWFjaCgoZmV0Y2hlciwga2V5KSA9PiB7XG4gICAgICAgIGlmIChmZXRjaGVyLmRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGZldGNoZXJEYXRhLmN1cnJlbnQuc2V0KGtleSwgZmV0Y2hlci5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBsZXQgaXNWaWV3VHJhbnNpdGlvblVuYXZhaWxhYmxlID0gcm91dGVyJDEud2luZG93ID09IG51bGwgfHwgdHlwZW9mIHJvdXRlciQxLndpbmRvdy5kb2N1bWVudC5zdGFydFZpZXdUcmFuc2l0aW9uICE9PSBcImZ1bmN0aW9uXCI7XG5cbiAgICAgIC8vIElmIHRoaXMgaXNuJ3QgYSB2aWV3IHRyYW5zaXRpb24gb3IgaXQncyBub3QgYXZhaWxhYmxlIGluIHRoaXMgYnJvd3NlcixcbiAgICAgIC8vIGp1c3QgdXBkYXRlIGFuZCBiZSBkb25lIHdpdGggaXRcbiAgICAgIGlmICghdmlld1RyYW5zaXRpb25PcHRzIHx8IGlzVmlld1RyYW5zaXRpb25VbmF2YWlsYWJsZSkge1xuICAgICAgICBpZiAoZmx1c2hTeW5jKSB7XG4gICAgICAgICAgZmx1c2hTeW5jU2FmZSgoKSA9PiBzZXRTdGF0ZUltcGwobmV3U3RhdGUpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvcHRJblN0YXJ0VHJhbnNpdGlvbigoKSA9PiBzZXRTdGF0ZUltcGwobmV3U3RhdGUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIGZsdXNoU3luYyArIHN0YXJ0Vmlld1RyYW5zaXRpb25cbiAgICAgIGlmIChmbHVzaFN5bmMpIHtcbiAgICAgICAgLy8gRmx1c2ggdGhyb3VnaCB0aGUgY29udGV4dCB0byBtYXJrIERPTSBlbGVtZW50cyBhcyB0cmFuc2l0aW9uPWluZ1xuICAgICAgICBmbHVzaFN5bmNTYWZlKCgpID0+IHtcbiAgICAgICAgICAvLyBDYW5jZWwgYW55IHBlbmRpbmcgdHJhbnNpdGlvbnNcbiAgICAgICAgICBpZiAodHJhbnNpdGlvbikge1xuICAgICAgICAgICAgcmVuZGVyRGZkICYmIHJlbmRlckRmZC5yZXNvbHZlKCk7XG4gICAgICAgICAgICB0cmFuc2l0aW9uLnNraXBUcmFuc2l0aW9uKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNldFZ0Q29udGV4dCh7XG4gICAgICAgICAgICBpc1RyYW5zaXRpb25pbmc6IHRydWUsXG4gICAgICAgICAgICBmbHVzaFN5bmM6IHRydWUsXG4gICAgICAgICAgICBjdXJyZW50TG9jYXRpb246IHZpZXdUcmFuc2l0aW9uT3B0cy5jdXJyZW50TG9jYXRpb24sXG4gICAgICAgICAgICBuZXh0TG9jYXRpb246IHZpZXdUcmFuc2l0aW9uT3B0cy5uZXh0TG9jYXRpb25cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gVXBkYXRlIHRoZSBET01cbiAgICAgICAgbGV0IHQgPSByb3V0ZXIkMS53aW5kb3cuZG9jdW1lbnQuc3RhcnRWaWV3VHJhbnNpdGlvbigoKSA9PiB7XG4gICAgICAgICAgZmx1c2hTeW5jU2FmZSgoKSA9PiBzZXRTdGF0ZUltcGwobmV3U3RhdGUpKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQ2xlYW4gdXAgYWZ0ZXIgdGhlIGFuaW1hdGlvbiBjb21wbGV0ZXNcbiAgICAgICAgdC5maW5pc2hlZC5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgICBmbHVzaFN5bmNTYWZlKCgpID0+IHtcbiAgICAgICAgICAgIHNldFJlbmRlckRmZCh1bmRlZmluZWQpO1xuICAgICAgICAgICAgc2V0VHJhbnNpdGlvbih1bmRlZmluZWQpO1xuICAgICAgICAgICAgc2V0UGVuZGluZ1N0YXRlKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICBzZXRWdENvbnRleHQoe1xuICAgICAgICAgICAgICBpc1RyYW5zaXRpb25pbmc6IGZhbHNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGZsdXNoU3luY1NhZmUoKCkgPT4gc2V0VHJhbnNpdGlvbih0KSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gc3RhcnRUcmFuc2l0aW9uICsgc3RhcnRWaWV3VHJhbnNpdGlvblxuICAgICAgaWYgKHRyYW5zaXRpb24pIHtcbiAgICAgICAgLy8gSW50ZXJydXB0aW5nIGFuIGluLXByb2dyZXNzIHRyYW5zaXRpb24sIGNhbmNlbCBhbmQgbGV0IGV2ZXJ5dGhpbmcgZmx1c2hcbiAgICAgICAgLy8gb3V0LCBhbmQgdGhlbiBraWNrIG9mZiBhIG5ldyB0cmFuc2l0aW9uIGZyb20gdGhlIGludGVycnVwdGlvbiBzdGF0ZVxuICAgICAgICByZW5kZXJEZmQgJiYgcmVuZGVyRGZkLnJlc29sdmUoKTtcbiAgICAgICAgdHJhbnNpdGlvbi5za2lwVHJhbnNpdGlvbigpO1xuICAgICAgICBzZXRJbnRlcnJ1cHRpb24oe1xuICAgICAgICAgIHN0YXRlOiBuZXdTdGF0ZSxcbiAgICAgICAgICBjdXJyZW50TG9jYXRpb246IHZpZXdUcmFuc2l0aW9uT3B0cy5jdXJyZW50TG9jYXRpb24sXG4gICAgICAgICAgbmV4dExvY2F0aW9uOiB2aWV3VHJhbnNpdGlvbk9wdHMubmV4dExvY2F0aW9uXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQ29tcGxldGVkIG5hdmlnYXRpb24gdXBkYXRlIHdpdGggb3B0ZWQtaW4gdmlldyB0cmFuc2l0aW9ucywgbGV0ICdlciByaXBcbiAgICAgICAgc2V0UGVuZGluZ1N0YXRlKG5ld1N0YXRlKTtcbiAgICAgICAgc2V0VnRDb250ZXh0KHtcbiAgICAgICAgICBpc1RyYW5zaXRpb25pbmc6IHRydWUsXG4gICAgICAgICAgZmx1c2hTeW5jOiBmYWxzZSxcbiAgICAgICAgICBjdXJyZW50TG9jYXRpb246IHZpZXdUcmFuc2l0aW9uT3B0cy5jdXJyZW50TG9jYXRpb24sXG4gICAgICAgICAgbmV4dExvY2F0aW9uOiB2aWV3VHJhbnNpdGlvbk9wdHMubmV4dExvY2F0aW9uXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIFtyb3V0ZXIkMS53aW5kb3csIHRyYW5zaXRpb24sIHJlbmRlckRmZCwgZmV0Y2hlckRhdGEsIG9wdEluU3RhcnRUcmFuc2l0aW9uXSk7XG5cbiAgICAvLyBOZWVkIHRvIHVzZSBhIGxheW91dCBlZmZlY3QgaGVyZSBzbyB3ZSBhcmUgc3Vic2NyaWJlZCBlYXJseSBlbm91Z2ggdG9cbiAgICAvLyBwaWNrIHVwIG9uIGFueSByZW5kZXItZHJpdmVuIHJlZGlyZWN0cy9uYXZpZ2F0aW9ucyAodXNlRWZmZWN0LzxOYXZpZ2F0ZT4pXG4gICAgUmVhY3RfX25hbWVzcGFjZS51c2VMYXlvdXRFZmZlY3QoKCkgPT4gcm91dGVyJDEuc3Vic2NyaWJlKHNldFN0YXRlKSwgW3JvdXRlciQxLCBzZXRTdGF0ZV0pO1xuXG4gICAgLy8gV2hlbiB3ZSBzdGFydCBhIHZpZXcgdHJhbnNpdGlvbiwgY3JlYXRlIGEgRGVmZXJyZWQgd2UgY2FuIHVzZSBmb3IgdGhlXG4gICAgLy8gZXZlbnR1YWwgXCJjb21wbGV0ZWRcIiByZW5kZXJcbiAgICBSZWFjdF9fbmFtZXNwYWNlLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICBpZiAodnRDb250ZXh0LmlzVHJhbnNpdGlvbmluZyAmJiAhdnRDb250ZXh0LmZsdXNoU3luYykge1xuICAgICAgICBzZXRSZW5kZXJEZmQobmV3IERlZmVycmVkKCkpO1xuICAgICAgfVxuICAgIH0sIFt2dENvbnRleHRdKTtcblxuICAgIC8vIE9uY2UgdGhlIGRlZmVycmVkIGlzIGNyZWF0ZWQsIGtpY2sgb2ZmIHN0YXJ0Vmlld1RyYW5zaXRpb24oKSB0byB1cGRhdGUgdGhlXG4gICAgLy8gRE9NIGFuZCB0aGVuIHdhaXQgb24gdGhlIERlZmVycmVkIHRvIHJlc29sdmUgKGluZGljYXRpbmcgdGhlIERPTSB1cGRhdGUgaGFzXG4gICAgLy8gaGFwcGVuZWQpXG4gICAgUmVhY3RfX25hbWVzcGFjZS51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgaWYgKHJlbmRlckRmZCAmJiBwZW5kaW5nU3RhdGUgJiYgcm91dGVyJDEud2luZG93KSB7XG4gICAgICAgIGxldCBuZXdTdGF0ZSA9IHBlbmRpbmdTdGF0ZTtcbiAgICAgICAgbGV0IHJlbmRlclByb21pc2UgPSByZW5kZXJEZmQucHJvbWlzZTtcbiAgICAgICAgbGV0IHRyYW5zaXRpb24gPSByb3V0ZXIkMS53aW5kb3cuZG9jdW1lbnQuc3RhcnRWaWV3VHJhbnNpdGlvbihhc3luYyAoKSA9PiB7XG4gICAgICAgICAgb3B0SW5TdGFydFRyYW5zaXRpb24oKCkgPT4gc2V0U3RhdGVJbXBsKG5ld1N0YXRlKSk7XG4gICAgICAgICAgYXdhaXQgcmVuZGVyUHJvbWlzZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRyYW5zaXRpb24uZmluaXNoZWQuZmluYWxseSgoKSA9PiB7XG4gICAgICAgICAgc2V0UmVuZGVyRGZkKHVuZGVmaW5lZCk7XG4gICAgICAgICAgc2V0VHJhbnNpdGlvbih1bmRlZmluZWQpO1xuICAgICAgICAgIHNldFBlbmRpbmdTdGF0ZSh1bmRlZmluZWQpO1xuICAgICAgICAgIHNldFZ0Q29udGV4dCh7XG4gICAgICAgICAgICBpc1RyYW5zaXRpb25pbmc6IGZhbHNlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBzZXRUcmFuc2l0aW9uKHRyYW5zaXRpb24pO1xuICAgICAgfVxuICAgIH0sIFtvcHRJblN0YXJ0VHJhbnNpdGlvbiwgcGVuZGluZ1N0YXRlLCByZW5kZXJEZmQsIHJvdXRlciQxLndpbmRvd10pO1xuXG4gICAgLy8gV2hlbiB0aGUgbmV3IGxvY2F0aW9uIGZpbmFsbHkgcmVuZGVycyBhbmQgaXMgY29tbWl0dGVkIHRvIHRoZSBET00sIHRoaXNcbiAgICAvLyBlZmZlY3Qgd2lsbCBydW4gdG8gcmVzb2x2ZSB0aGUgdHJhbnNpdGlvblxuICAgIFJlYWN0X19uYW1lc3BhY2UudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgIGlmIChyZW5kZXJEZmQgJiYgcGVuZGluZ1N0YXRlICYmIHN0YXRlLmxvY2F0aW9uLmtleSA9PT0gcGVuZGluZ1N0YXRlLmxvY2F0aW9uLmtleSkge1xuICAgICAgICByZW5kZXJEZmQucmVzb2x2ZSgpO1xuICAgICAgfVxuICAgIH0sIFtyZW5kZXJEZmQsIHRyYW5zaXRpb24sIHN0YXRlLmxvY2F0aW9uLCBwZW5kaW5nU3RhdGVdKTtcblxuICAgIC8vIElmIHdlIGdldCBpbnRlcnJ1cHRlZCB3aXRoIGEgbmV3IG5hdmlnYXRpb24gZHVyaW5nIGEgdHJhbnNpdGlvbiwgd2Ugc2tpcFxuICAgIC8vIHRoZSBhY3RpdmUgdHJhbnNpdGlvbiwgbGV0IGl0IGNsZWFudXAsIHRoZW4ga2ljayBpdCBvZmYgYWdhaW4gaGVyZVxuICAgIFJlYWN0X19uYW1lc3BhY2UudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgIGlmICghdnRDb250ZXh0LmlzVHJhbnNpdGlvbmluZyAmJiBpbnRlcnJ1cHRpb24pIHtcbiAgICAgICAgc2V0UGVuZGluZ1N0YXRlKGludGVycnVwdGlvbi5zdGF0ZSk7XG4gICAgICAgIHNldFZ0Q29udGV4dCh7XG4gICAgICAgICAgaXNUcmFuc2l0aW9uaW5nOiB0cnVlLFxuICAgICAgICAgIGZsdXNoU3luYzogZmFsc2UsXG4gICAgICAgICAgY3VycmVudExvY2F0aW9uOiBpbnRlcnJ1cHRpb24uY3VycmVudExvY2F0aW9uLFxuICAgICAgICAgIG5leHRMb2NhdGlvbjogaW50ZXJydXB0aW9uLm5leHRMb2NhdGlvblxuICAgICAgICB9KTtcbiAgICAgICAgc2V0SW50ZXJydXB0aW9uKHVuZGVmaW5lZCk7XG4gICAgICB9XG4gICAgfSwgW3Z0Q29udGV4dC5pc1RyYW5zaXRpb25pbmcsIGludGVycnVwdGlvbl0pO1xuICAgIFJlYWN0X19uYW1lc3BhY2UudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgIHJvdXRlci5VTlNBRkVfd2FybmluZyhmYWxsYmFja0VsZW1lbnQgPT0gbnVsbCB8fCAhcm91dGVyJDEuZnV0dXJlLnY3X3BhcnRpYWxIeWRyYXRpb24sIFwiYDxSb3V0ZXJQcm92aWRlciBmYWxsYmFja0VsZW1lbnQ+YCBpcyBkZXByZWNhdGVkIHdoZW4gdXNpbmcgXCIgKyBcImB2N19wYXJ0aWFsSHlkcmF0aW9uYCwgdXNlIGEgYEh5ZHJhdGVGYWxsYmFja2AgY29tcG9uZW50IGluc3RlYWRcIikgO1xuICAgICAgLy8gT25seSBsb2cgdGhpcyBvbmNlIG9uIGluaXRpYWwgbW91bnRcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICB9LCBbXSk7XG4gICAgbGV0IG5hdmlnYXRvciA9IFJlYWN0X19uYW1lc3BhY2UudXNlTWVtbygoKSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjcmVhdGVIcmVmOiByb3V0ZXIkMS5jcmVhdGVIcmVmLFxuICAgICAgICBlbmNvZGVMb2NhdGlvbjogcm91dGVyJDEuZW5jb2RlTG9jYXRpb24sXG4gICAgICAgIGdvOiBuID0+IHJvdXRlciQxLm5hdmlnYXRlKG4pLFxuICAgICAgICBwdXNoOiAodG8sIHN0YXRlLCBvcHRzKSA9PiByb3V0ZXIkMS5uYXZpZ2F0ZSh0bywge1xuICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgIHByZXZlbnRTY3JvbGxSZXNldDogb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5wcmV2ZW50U2Nyb2xsUmVzZXRcbiAgICAgICAgfSksXG4gICAgICAgIHJlcGxhY2U6ICh0bywgc3RhdGUsIG9wdHMpID0+IHJvdXRlciQxLm5hdmlnYXRlKHRvLCB7XG4gICAgICAgICAgcmVwbGFjZTogdHJ1ZSxcbiAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQ6IG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMucHJldmVudFNjcm9sbFJlc2V0XG4gICAgICAgIH0pXG4gICAgICB9O1xuICAgIH0sIFtyb3V0ZXIkMV0pO1xuICAgIGxldCBiYXNlbmFtZSA9IHJvdXRlciQxLmJhc2VuYW1lIHx8IFwiL1wiO1xuICAgIGxldCBkYXRhUm91dGVyQ29udGV4dCA9IFJlYWN0X19uYW1lc3BhY2UudXNlTWVtbygoKSA9PiAoe1xuICAgICAgcm91dGVyOiByb3V0ZXIkMSxcbiAgICAgIG5hdmlnYXRvcixcbiAgICAgIHN0YXRpYzogZmFsc2UsXG4gICAgICBiYXNlbmFtZVxuICAgIH0pLCBbcm91dGVyJDEsIG5hdmlnYXRvciwgYmFzZW5hbWVdKTtcblxuICAgIC8vIFRoZSBmcmFnbWVudCBhbmQge251bGx9IGhlcmUgYXJlIGltcG9ydGFudCEgIFdlIG5lZWQgdGhlbSB0byBrZWVwIFJlYWN0IDE4J3NcbiAgICAvLyB1c2VJZCBoYXBweSB3aGVuIHdlIGFyZSBzZXJ2ZXItcmVuZGVyaW5nIHNpbmNlIHdlIG1heSBoYXZlIGEgPHNjcmlwdD4gaGVyZVxuICAgIC8vIGNvbnRhaW5pbmcgdGhlIGh5ZHJhdGVkIHNlcnZlci1zaWRlIHN0YXRpY0NvbnRleHQgKGZyb20gU3RhdGljUm91dGVyUHJvdmlkZXIpLlxuICAgIC8vIHVzZUlkIHJlbGllcyBvbiB0aGUgY29tcG9uZW50IHRyZWUgc3RydWN0dXJlIHRvIGdlbmVyYXRlIGRldGVybWluaXN0aWMgaWQnc1xuICAgIC8vIHNvIHdlIG5lZWQgdG8gZW5zdXJlIGl0IHJlbWFpbnMgdGhlIHNhbWUgb24gdGhlIGNsaWVudCBldmVuIHRob3VnaFxuICAgIC8vIHdlIGRvbid0IG5lZWQgdGhlIDxzY3JpcHQ+IHRhZ1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFJlYWN0X19uYW1lc3BhY2UuRnJhZ21lbnQsIG51bGwsIC8qI19fUFVSRV9fKi9SZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQocmVhY3RSb3V0ZXIuVU5TQUZFX0RhdGFSb3V0ZXJDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICB2YWx1ZTogZGF0YVJvdXRlckNvbnRleHRcbiAgICB9LCAvKiNfX1BVUkVfXyovUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KHJlYWN0Um91dGVyLlVOU0FGRV9EYXRhUm91dGVyU3RhdGVDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICB2YWx1ZTogc3RhdGVcbiAgICB9LCAvKiNfX1BVUkVfXyovUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KEZldGNoZXJzQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgdmFsdWU6IGZldGNoZXJEYXRhLmN1cnJlbnRcbiAgICB9LCAvKiNfX1BVUkVfXyovUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFZpZXdUcmFuc2l0aW9uQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgdmFsdWU6IHZ0Q29udGV4dFxuICAgIH0sIC8qI19fUFVSRV9fKi9SZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQocmVhY3RSb3V0ZXIuUm91dGVyLCB7XG4gICAgICBiYXNlbmFtZTogYmFzZW5hbWUsXG4gICAgICBsb2NhdGlvbjogc3RhdGUubG9jYXRpb24sXG4gICAgICBuYXZpZ2F0aW9uVHlwZTogc3RhdGUuaGlzdG9yeUFjdGlvbixcbiAgICAgIG5hdmlnYXRvcjogbmF2aWdhdG9yLFxuICAgICAgZnV0dXJlOiB7XG4gICAgICAgIHY3X3JlbGF0aXZlU3BsYXRQYXRoOiByb3V0ZXIkMS5mdXR1cmUudjdfcmVsYXRpdmVTcGxhdFBhdGhcbiAgICAgIH1cbiAgICB9LCBzdGF0ZS5pbml0aWFsaXplZCB8fCByb3V0ZXIkMS5mdXR1cmUudjdfcGFydGlhbEh5ZHJhdGlvbiA/IC8qI19fUFVSRV9fKi9SZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoRGF0YVJvdXRlcywge1xuICAgICAgcm91dGVzOiByb3V0ZXIkMS5yb3V0ZXMsXG4gICAgICBmdXR1cmU6IHJvdXRlciQxLmZ1dHVyZSxcbiAgICAgIHN0YXRlOiBzdGF0ZVxuICAgIH0pIDogZmFsbGJhY2tFbGVtZW50KSkpKSksIG51bGwpO1xuICB9XG4gIGZ1bmN0aW9uIERhdGFSb3V0ZXMoX3JlZjMpIHtcbiAgICBsZXQge1xuICAgICAgcm91dGVzLFxuICAgICAgZnV0dXJlLFxuICAgICAgc3RhdGVcbiAgICB9ID0gX3JlZjM7XG4gICAgcmV0dXJuIHJlYWN0Um91dGVyLlVOU0FGRV91c2VSb3V0ZXNJbXBsKHJvdXRlcywgdW5kZWZpbmVkLCBzdGF0ZSwgZnV0dXJlKTtcbiAgfVxuICAvKipcbiAgICogQSBgPFJvdXRlcj5gIGZvciB1c2UgaW4gd2ViIGJyb3dzZXJzLiBQcm92aWRlcyB0aGUgY2xlYW5lc3QgVVJMcy5cbiAgICovXG4gIGZ1bmN0aW9uIEJyb3dzZXJSb3V0ZXIoX3JlZjQpIHtcbiAgICBsZXQge1xuICAgICAgYmFzZW5hbWUsXG4gICAgICBjaGlsZHJlbixcbiAgICAgIGZ1dHVyZSxcbiAgICAgIHdpbmRvd1xuICAgIH0gPSBfcmVmNDtcbiAgICBsZXQgaGlzdG9yeVJlZiA9IFJlYWN0X19uYW1lc3BhY2UudXNlUmVmKCk7XG4gICAgaWYgKGhpc3RvcnlSZWYuY3VycmVudCA9PSBudWxsKSB7XG4gICAgICBoaXN0b3J5UmVmLmN1cnJlbnQgPSByb3V0ZXIuY3JlYXRlQnJvd3Nlckhpc3Rvcnkoe1xuICAgICAgICB3aW5kb3csXG4gICAgICAgIHY1Q29tcGF0OiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgbGV0IGhpc3RvcnkgPSBoaXN0b3J5UmVmLmN1cnJlbnQ7XG4gICAgbGV0IFtzdGF0ZSwgc2V0U3RhdGVJbXBsXSA9IFJlYWN0X19uYW1lc3BhY2UudXNlU3RhdGUoe1xuICAgICAgYWN0aW9uOiBoaXN0b3J5LmFjdGlvbixcbiAgICAgIGxvY2F0aW9uOiBoaXN0b3J5LmxvY2F0aW9uXG4gICAgfSk7XG4gICAgbGV0IHtcbiAgICAgIHY3X3N0YXJ0VHJhbnNpdGlvblxuICAgIH0gPSBmdXR1cmUgfHwge307XG4gICAgbGV0IHNldFN0YXRlID0gUmVhY3RfX25hbWVzcGFjZS51c2VDYWxsYmFjayhuZXdTdGF0ZSA9PiB7XG4gICAgICB2N19zdGFydFRyYW5zaXRpb24gJiYgc3RhcnRUcmFuc2l0aW9uSW1wbCA/IHN0YXJ0VHJhbnNpdGlvbkltcGwoKCkgPT4gc2V0U3RhdGVJbXBsKG5ld1N0YXRlKSkgOiBzZXRTdGF0ZUltcGwobmV3U3RhdGUpO1xuICAgIH0sIFtzZXRTdGF0ZUltcGwsIHY3X3N0YXJ0VHJhbnNpdGlvbl0pO1xuICAgIFJlYWN0X19uYW1lc3BhY2UudXNlTGF5b3V0RWZmZWN0KCgpID0+IGhpc3RvcnkubGlzdGVuKHNldFN0YXRlKSwgW2hpc3RvcnksIHNldFN0YXRlXSk7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQocmVhY3RSb3V0ZXIuUm91dGVyLCB7XG4gICAgICBiYXNlbmFtZTogYmFzZW5hbWUsXG4gICAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgICBsb2NhdGlvbjogc3RhdGUubG9jYXRpb24sXG4gICAgICBuYXZpZ2F0aW9uVHlwZTogc3RhdGUuYWN0aW9uLFxuICAgICAgbmF2aWdhdG9yOiBoaXN0b3J5LFxuICAgICAgZnV0dXJlOiBmdXR1cmVcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQSBgPFJvdXRlcj5gIGZvciB1c2UgaW4gd2ViIGJyb3dzZXJzLiBTdG9yZXMgdGhlIGxvY2F0aW9uIGluIHRoZSBoYXNoXG4gICAqIHBvcnRpb24gb2YgdGhlIFVSTCBzbyBpdCBpcyBub3Qgc2VudCB0byB0aGUgc2VydmVyLlxuICAgKi9cbiAgZnVuY3Rpb24gSGFzaFJvdXRlcihfcmVmNSkge1xuICAgIGxldCB7XG4gICAgICBiYXNlbmFtZSxcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgZnV0dXJlLFxuICAgICAgd2luZG93XG4gICAgfSA9IF9yZWY1O1xuICAgIGxldCBoaXN0b3J5UmVmID0gUmVhY3RfX25hbWVzcGFjZS51c2VSZWYoKTtcbiAgICBpZiAoaGlzdG9yeVJlZi5jdXJyZW50ID09IG51bGwpIHtcbiAgICAgIGhpc3RvcnlSZWYuY3VycmVudCA9IHJvdXRlci5jcmVhdGVIYXNoSGlzdG9yeSh7XG4gICAgICAgIHdpbmRvdyxcbiAgICAgICAgdjVDb21wYXQ6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICBsZXQgaGlzdG9yeSA9IGhpc3RvcnlSZWYuY3VycmVudDtcbiAgICBsZXQgW3N0YXRlLCBzZXRTdGF0ZUltcGxdID0gUmVhY3RfX25hbWVzcGFjZS51c2VTdGF0ZSh7XG4gICAgICBhY3Rpb246IGhpc3RvcnkuYWN0aW9uLFxuICAgICAgbG9jYXRpb246IGhpc3RvcnkubG9jYXRpb25cbiAgICB9KTtcbiAgICBsZXQge1xuICAgICAgdjdfc3RhcnRUcmFuc2l0aW9uXG4gICAgfSA9IGZ1dHVyZSB8fCB7fTtcbiAgICBsZXQgc2V0U3RhdGUgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZUNhbGxiYWNrKG5ld1N0YXRlID0+IHtcbiAgICAgIHY3X3N0YXJ0VHJhbnNpdGlvbiAmJiBzdGFydFRyYW5zaXRpb25JbXBsID8gc3RhcnRUcmFuc2l0aW9uSW1wbCgoKSA9PiBzZXRTdGF0ZUltcGwobmV3U3RhdGUpKSA6IHNldFN0YXRlSW1wbChuZXdTdGF0ZSk7XG4gICAgfSwgW3NldFN0YXRlSW1wbCwgdjdfc3RhcnRUcmFuc2l0aW9uXSk7XG4gICAgUmVhY3RfX25hbWVzcGFjZS51c2VMYXlvdXRFZmZlY3QoKCkgPT4gaGlzdG9yeS5saXN0ZW4oc2V0U3RhdGUpLCBbaGlzdG9yeSwgc2V0U3RhdGVdKTtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChyZWFjdFJvdXRlci5Sb3V0ZXIsIHtcbiAgICAgIGJhc2VuYW1lOiBiYXNlbmFtZSxcbiAgICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICAgIGxvY2F0aW9uOiBzdGF0ZS5sb2NhdGlvbixcbiAgICAgIG5hdmlnYXRpb25UeXBlOiBzdGF0ZS5hY3Rpb24sXG4gICAgICBuYXZpZ2F0b3I6IGhpc3RvcnksXG4gICAgICBmdXR1cmU6IGZ1dHVyZVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBBIGA8Um91dGVyPmAgdGhhdCBhY2NlcHRzIGEgcHJlLWluc3RhbnRpYXRlZCBoaXN0b3J5IG9iamVjdC4gSXQncyBpbXBvcnRhbnRcbiAgICogdG8gbm90ZSB0aGF0IHVzaW5nIHlvdXIgb3duIGhpc3Rvcnkgb2JqZWN0IGlzIGhpZ2hseSBkaXNjb3VyYWdlZCBhbmQgbWF5IGFkZFxuICAgKiB0d28gdmVyc2lvbnMgb2YgdGhlIGhpc3RvcnkgbGlicmFyeSB0byB5b3VyIGJ1bmRsZXMgdW5sZXNzIHlvdSB1c2UgdGhlIHNhbWVcbiAgICogdmVyc2lvbiBvZiB0aGUgaGlzdG9yeSBsaWJyYXJ5IHRoYXQgUmVhY3QgUm91dGVyIHVzZXMgaW50ZXJuYWxseS5cbiAgICovXG4gIGZ1bmN0aW9uIEhpc3RvcnlSb3V0ZXIoX3JlZjYpIHtcbiAgICBsZXQge1xuICAgICAgYmFzZW5hbWUsXG4gICAgICBjaGlsZHJlbixcbiAgICAgIGZ1dHVyZSxcbiAgICAgIGhpc3RvcnlcbiAgICB9ID0gX3JlZjY7XG4gICAgbGV0IFtzdGF0ZSwgc2V0U3RhdGVJbXBsXSA9IFJlYWN0X19uYW1lc3BhY2UudXNlU3RhdGUoe1xuICAgICAgYWN0aW9uOiBoaXN0b3J5LmFjdGlvbixcbiAgICAgIGxvY2F0aW9uOiBoaXN0b3J5LmxvY2F0aW9uXG4gICAgfSk7XG4gICAgbGV0IHtcbiAgICAgIHY3X3N0YXJ0VHJhbnNpdGlvblxuICAgIH0gPSBmdXR1cmUgfHwge307XG4gICAgbGV0IHNldFN0YXRlID0gUmVhY3RfX25hbWVzcGFjZS51c2VDYWxsYmFjayhuZXdTdGF0ZSA9PiB7XG4gICAgICB2N19zdGFydFRyYW5zaXRpb24gJiYgc3RhcnRUcmFuc2l0aW9uSW1wbCA/IHN0YXJ0VHJhbnNpdGlvbkltcGwoKCkgPT4gc2V0U3RhdGVJbXBsKG5ld1N0YXRlKSkgOiBzZXRTdGF0ZUltcGwobmV3U3RhdGUpO1xuICAgIH0sIFtzZXRTdGF0ZUltcGwsIHY3X3N0YXJ0VHJhbnNpdGlvbl0pO1xuICAgIFJlYWN0X19uYW1lc3BhY2UudXNlTGF5b3V0RWZmZWN0KCgpID0+IGhpc3RvcnkubGlzdGVuKHNldFN0YXRlKSwgW2hpc3RvcnksIHNldFN0YXRlXSk7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQocmVhY3RSb3V0ZXIuUm91dGVyLCB7XG4gICAgICBiYXNlbmFtZTogYmFzZW5hbWUsXG4gICAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgICBsb2NhdGlvbjogc3RhdGUubG9jYXRpb24sXG4gICAgICBuYXZpZ2F0aW9uVHlwZTogc3RhdGUuYWN0aW9uLFxuICAgICAgbmF2aWdhdG9yOiBoaXN0b3J5LFxuICAgICAgZnV0dXJlOiBmdXR1cmVcbiAgICB9KTtcbiAgfVxuICB7XG4gICAgSGlzdG9yeVJvdXRlci5kaXNwbGF5TmFtZSA9IFwidW5zdGFibGVfSGlzdG9yeVJvdXRlclwiO1xuICB9XG4gIGNvbnN0IGlzQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgIT09IFwidW5kZWZpbmVkXCI7XG4gIGNvbnN0IEFCU09MVVRFX1VSTF9SRUdFWCA9IC9eKD86W2Etel1bYS16MC05Ky4tXSo6fFxcL1xcLykvaTtcblxuICAvKipcbiAgICogVGhlIHB1YmxpYyBBUEkgZm9yIHJlbmRlcmluZyBhIGhpc3RvcnktYXdhcmUgYDxhPmAuXG4gICAqL1xuICBjb25zdCBMaW5rID0gLyojX19QVVJFX18qL1JlYWN0X19uYW1lc3BhY2UuZm9yd2FyZFJlZihmdW5jdGlvbiBMaW5rV2l0aFJlZihfcmVmNywgcmVmKSB7XG4gICAgbGV0IHtcbiAgICAgICAgb25DbGljayxcbiAgICAgICAgcmVsYXRpdmUsXG4gICAgICAgIHJlbG9hZERvY3VtZW50LFxuICAgICAgICByZXBsYWNlLFxuICAgICAgICBzdGF0ZSxcbiAgICAgICAgdGFyZ2V0LFxuICAgICAgICB0byxcbiAgICAgICAgcHJldmVudFNjcm9sbFJlc2V0LFxuICAgICAgICB1bnN0YWJsZV92aWV3VHJhbnNpdGlvblxuICAgICAgfSA9IF9yZWY3LFxuICAgICAgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF9yZWY3LCBfZXhjbHVkZWQpO1xuICAgIGxldCB7XG4gICAgICBiYXNlbmFtZVxuICAgIH0gPSBSZWFjdF9fbmFtZXNwYWNlLnVzZUNvbnRleHQocmVhY3RSb3V0ZXIuVU5TQUZFX05hdmlnYXRpb25Db250ZXh0KTtcblxuICAgIC8vIFJlbmRlcmVkIGludG8gPGEgaHJlZj4gZm9yIGFic29sdXRlIFVSTHNcbiAgICBsZXQgYWJzb2x1dGVIcmVmO1xuICAgIGxldCBpc0V4dGVybmFsID0gZmFsc2U7XG4gICAgaWYgKHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiAmJiBBQlNPTFVURV9VUkxfUkVHRVgudGVzdCh0bykpIHtcbiAgICAgIC8vIFJlbmRlciB0aGUgYWJzb2x1dGUgaHJlZiBzZXJ2ZXItIGFuZCBjbGllbnQtc2lkZVxuICAgICAgYWJzb2x1dGVIcmVmID0gdG87XG5cbiAgICAgIC8vIE9ubHkgY2hlY2sgZm9yIGV4dGVybmFsIG9yaWdpbnMgY2xpZW50LXNpZGVcbiAgICAgIGlmIChpc0Jyb3dzZXIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBsZXQgY3VycmVudFVybCA9IG5ldyBVUkwod2luZG93LmxvY2F0aW9uLmhyZWYpO1xuICAgICAgICAgIGxldCB0YXJnZXRVcmwgPSB0by5zdGFydHNXaXRoKFwiLy9cIikgPyBuZXcgVVJMKGN1cnJlbnRVcmwucHJvdG9jb2wgKyB0bykgOiBuZXcgVVJMKHRvKTtcbiAgICAgICAgICBsZXQgcGF0aCA9IHJvdXRlci5zdHJpcEJhc2VuYW1lKHRhcmdldFVybC5wYXRobmFtZSwgYmFzZW5hbWUpO1xuICAgICAgICAgIGlmICh0YXJnZXRVcmwub3JpZ2luID09PSBjdXJyZW50VXJsLm9yaWdpbiAmJiBwYXRoICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFN0cmlwIHRoZSBwcm90b2NvbC9vcmlnaW4vYmFzZW5hbWUgZm9yIHNhbWUtb3JpZ2luIGFic29sdXRlIFVSTHNcbiAgICAgICAgICAgIHRvID0gcGF0aCArIHRhcmdldFVybC5zZWFyY2ggKyB0YXJnZXRVcmwuaGFzaDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaXNFeHRlcm5hbCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLy8gV2UgY2FuJ3QgZG8gZXh0ZXJuYWwgVVJMIGRldGVjdGlvbiB3aXRob3V0IGEgdmFsaWQgVVJMXG4gICAgICAgICAgcm91dGVyLlVOU0FGRV93YXJuaW5nKGZhbHNlLCBcIjxMaW5rIHRvPVxcXCJcIiArIHRvICsgXCJcXFwiPiBjb250YWlucyBhbiBpbnZhbGlkIFVSTCB3aGljaCB3aWxsIHByb2JhYmx5IGJyZWFrIFwiICsgXCJ3aGVuIGNsaWNrZWQgLSBwbGVhc2UgdXBkYXRlIHRvIGEgdmFsaWQgVVJMIHBhdGguXCIpIDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJlbmRlcmVkIGludG8gPGEgaHJlZj4gZm9yIHJlbGF0aXZlIFVSTHNcbiAgICBsZXQgaHJlZiA9IHJlYWN0Um91dGVyLnVzZUhyZWYodG8sIHtcbiAgICAgIHJlbGF0aXZlXG4gICAgfSk7XG4gICAgbGV0IGludGVybmFsT25DbGljayA9IHVzZUxpbmtDbGlja0hhbmRsZXIodG8sIHtcbiAgICAgIHJlcGxhY2UsXG4gICAgICBzdGF0ZSxcbiAgICAgIHRhcmdldCxcbiAgICAgIHByZXZlbnRTY3JvbGxSZXNldCxcbiAgICAgIHJlbGF0aXZlLFxuICAgICAgdW5zdGFibGVfdmlld1RyYW5zaXRpb25cbiAgICB9KTtcbiAgICBmdW5jdGlvbiBoYW5kbGVDbGljayhldmVudCkge1xuICAgICAgaWYgKG9uQ2xpY2spIG9uQ2xpY2soZXZlbnQpO1xuICAgICAgaWYgKCFldmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgIGludGVybmFsT25DbGljayhldmVudCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAoXG4gICAgICAvKiNfX1BVUkVfXyovXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUganN4LWExMXkvYW5jaG9yLWhhcy1jb250ZW50XG4gICAgICBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJhXCIsIF9leHRlbmRzKHt9LCByZXN0LCB7XG4gICAgICAgIGhyZWY6IGFic29sdXRlSHJlZiB8fCBocmVmLFxuICAgICAgICBvbkNsaWNrOiBpc0V4dGVybmFsIHx8IHJlbG9hZERvY3VtZW50ID8gb25DbGljayA6IGhhbmRsZUNsaWNrLFxuICAgICAgICByZWY6IHJlZixcbiAgICAgICAgdGFyZ2V0OiB0YXJnZXRcbiAgICAgIH0pKVxuICAgICk7XG4gIH0pO1xuICB7XG4gICAgTGluay5kaXNwbGF5TmFtZSA9IFwiTGlua1wiO1xuICB9XG4gIC8qKlxuICAgKiBBIGA8TGluaz5gIHdyYXBwZXIgdGhhdCBrbm93cyBpZiBpdCdzIFwiYWN0aXZlXCIgb3Igbm90LlxuICAgKi9cbiAgY29uc3QgTmF2TGluayA9IC8qI19fUFVSRV9fKi9SZWFjdF9fbmFtZXNwYWNlLmZvcndhcmRSZWYoZnVuY3Rpb24gTmF2TGlua1dpdGhSZWYoX3JlZjgsIHJlZikge1xuICAgIGxldCB7XG4gICAgICAgIFwiYXJpYS1jdXJyZW50XCI6IGFyaWFDdXJyZW50UHJvcCA9IFwicGFnZVwiLFxuICAgICAgICBjYXNlU2Vuc2l0aXZlID0gZmFsc2UsXG4gICAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lUHJvcCA9IFwiXCIsXG4gICAgICAgIGVuZCA9IGZhbHNlLFxuICAgICAgICBzdHlsZTogc3R5bGVQcm9wLFxuICAgICAgICB0byxcbiAgICAgICAgdW5zdGFibGVfdmlld1RyYW5zaXRpb24sXG4gICAgICAgIGNoaWxkcmVuXG4gICAgICB9ID0gX3JlZjgsXG4gICAgICByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3JlZjgsIF9leGNsdWRlZDIpO1xuICAgIGxldCBwYXRoID0gcmVhY3RSb3V0ZXIudXNlUmVzb2x2ZWRQYXRoKHRvLCB7XG4gICAgICByZWxhdGl2ZTogcmVzdC5yZWxhdGl2ZVxuICAgIH0pO1xuICAgIGxldCBsb2NhdGlvbiA9IHJlYWN0Um91dGVyLnVzZUxvY2F0aW9uKCk7XG4gICAgbGV0IHJvdXRlclN0YXRlID0gUmVhY3RfX25hbWVzcGFjZS51c2VDb250ZXh0KHJlYWN0Um91dGVyLlVOU0FGRV9EYXRhUm91dGVyU3RhdGVDb250ZXh0KTtcbiAgICBsZXQge1xuICAgICAgbmF2aWdhdG9yLFxuICAgICAgYmFzZW5hbWVcbiAgICB9ID0gUmVhY3RfX25hbWVzcGFjZS51c2VDb250ZXh0KHJlYWN0Um91dGVyLlVOU0FGRV9OYXZpZ2F0aW9uQ29udGV4dCk7XG4gICAgbGV0IGlzVHJhbnNpdGlvbmluZyA9IHJvdXRlclN0YXRlICE9IG51bGwgJiZcbiAgICAvLyBDb25kaXRpb25hbCB1c2FnZSBpcyBPSyBoZXJlIGJlY2F1c2UgdGhlIHVzYWdlIG9mIGEgZGF0YSByb3V0ZXIgaXMgc3RhdGljXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gICAgdXNlVmlld1RyYW5zaXRpb25TdGF0ZShwYXRoKSAmJiB1bnN0YWJsZV92aWV3VHJhbnNpdGlvbiA9PT0gdHJ1ZTtcbiAgICBsZXQgdG9QYXRobmFtZSA9IG5hdmlnYXRvci5lbmNvZGVMb2NhdGlvbiA/IG5hdmlnYXRvci5lbmNvZGVMb2NhdGlvbihwYXRoKS5wYXRobmFtZSA6IHBhdGgucGF0aG5hbWU7XG4gICAgbGV0IGxvY2F0aW9uUGF0aG5hbWUgPSBsb2NhdGlvbi5wYXRobmFtZTtcbiAgICBsZXQgbmV4dExvY2F0aW9uUGF0aG5hbWUgPSByb3V0ZXJTdGF0ZSAmJiByb3V0ZXJTdGF0ZS5uYXZpZ2F0aW9uICYmIHJvdXRlclN0YXRlLm5hdmlnYXRpb24ubG9jYXRpb24gPyByb3V0ZXJTdGF0ZS5uYXZpZ2F0aW9uLmxvY2F0aW9uLnBhdGhuYW1lIDogbnVsbDtcbiAgICBpZiAoIWNhc2VTZW5zaXRpdmUpIHtcbiAgICAgIGxvY2F0aW9uUGF0aG5hbWUgPSBsb2NhdGlvblBhdGhuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICBuZXh0TG9jYXRpb25QYXRobmFtZSA9IG5leHRMb2NhdGlvblBhdGhuYW1lID8gbmV4dExvY2F0aW9uUGF0aG5hbWUudG9Mb3dlckNhc2UoKSA6IG51bGw7XG4gICAgICB0b1BhdGhuYW1lID0gdG9QYXRobmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgICBpZiAobmV4dExvY2F0aW9uUGF0aG5hbWUgJiYgYmFzZW5hbWUpIHtcbiAgICAgIG5leHRMb2NhdGlvblBhdGhuYW1lID0gcm91dGVyLnN0cmlwQmFzZW5hbWUobmV4dExvY2F0aW9uUGF0aG5hbWUsIGJhc2VuYW1lKSB8fCBuZXh0TG9jYXRpb25QYXRobmFtZTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgYHRvYCBoYXMgYSB0cmFpbGluZyBzbGFzaCwgbG9vayBhdCB0aGF0IGV4YWN0IHNwb3QuICBPdGhlcndpc2UsXG4gICAgLy8gd2UncmUgbG9va2luZyBmb3IgYSBzbGFzaCBfYWZ0ZXJfIHdoYXQncyBpbiBgdG9gLiAgRm9yIGV4YW1wbGU6XG4gICAgLy9cbiAgICAvLyA8TmF2TGluayB0bz1cIi91c2Vyc1wiPiBhbmQgPE5hdkxpbmsgdG89XCIvdXNlcnMvXCI+XG4gICAgLy8gYm90aCB3YW50IHRvIGxvb2sgZm9yIGEgLyBhdCBpbmRleCA2IHRvIG1hdGNoIFVSTCBgL3VzZXJzL21hdHRgXG4gICAgY29uc3QgZW5kU2xhc2hQb3NpdGlvbiA9IHRvUGF0aG5hbWUgIT09IFwiL1wiICYmIHRvUGF0aG5hbWUuZW5kc1dpdGgoXCIvXCIpID8gdG9QYXRobmFtZS5sZW5ndGggLSAxIDogdG9QYXRobmFtZS5sZW5ndGg7XG4gICAgbGV0IGlzQWN0aXZlID0gbG9jYXRpb25QYXRobmFtZSA9PT0gdG9QYXRobmFtZSB8fCAhZW5kICYmIGxvY2F0aW9uUGF0aG5hbWUuc3RhcnRzV2l0aCh0b1BhdGhuYW1lKSAmJiBsb2NhdGlvblBhdGhuYW1lLmNoYXJBdChlbmRTbGFzaFBvc2l0aW9uKSA9PT0gXCIvXCI7XG4gICAgbGV0IGlzUGVuZGluZyA9IG5leHRMb2NhdGlvblBhdGhuYW1lICE9IG51bGwgJiYgKG5leHRMb2NhdGlvblBhdGhuYW1lID09PSB0b1BhdGhuYW1lIHx8ICFlbmQgJiYgbmV4dExvY2F0aW9uUGF0aG5hbWUuc3RhcnRzV2l0aCh0b1BhdGhuYW1lKSAmJiBuZXh0TG9jYXRpb25QYXRobmFtZS5jaGFyQXQodG9QYXRobmFtZS5sZW5ndGgpID09PSBcIi9cIik7XG4gICAgbGV0IHJlbmRlclByb3BzID0ge1xuICAgICAgaXNBY3RpdmUsXG4gICAgICBpc1BlbmRpbmcsXG4gICAgICBpc1RyYW5zaXRpb25pbmdcbiAgICB9O1xuICAgIGxldCBhcmlhQ3VycmVudCA9IGlzQWN0aXZlID8gYXJpYUN1cnJlbnRQcm9wIDogdW5kZWZpbmVkO1xuICAgIGxldCBjbGFzc05hbWU7XG4gICAgaWYgKHR5cGVvZiBjbGFzc05hbWVQcm9wID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGNsYXNzTmFtZSA9IGNsYXNzTmFtZVByb3AocmVuZGVyUHJvcHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiB0aGUgY2xhc3NOYW1lIHByb3AgaXMgbm90IGEgZnVuY3Rpb24sIHdlIHVzZSBhIGRlZmF1bHQgYGFjdGl2ZWBcbiAgICAgIC8vIGNsYXNzIGZvciA8TmF2TGluayAvPnMgdGhhdCBhcmUgYWN0aXZlLiBJbiB2NSBgYWN0aXZlYCB3YXMgdGhlIGRlZmF1bHRcbiAgICAgIC8vIHZhbHVlIGZvciBgYWN0aXZlQ2xhc3NOYW1lYCwgYnV0IHdlIGFyZSByZW1vdmluZyB0aGF0IEFQSSBhbmQgY2FuIHN0aWxsXG4gICAgICAvLyB1c2UgdGhlIG9sZCBkZWZhdWx0IGJlaGF2aW9yIGZvciBhIGNsZWFuZXIgdXBncmFkZSBwYXRoIGFuZCBrZWVwIHRoZVxuICAgICAgLy8gc2ltcGxlIHN0eWxpbmcgcnVsZXMgd29ya2luZyBhcyB0aGV5IGN1cnJlbnRseSBkby5cbiAgICAgIGNsYXNzTmFtZSA9IFtjbGFzc05hbWVQcm9wLCBpc0FjdGl2ZSA/IFwiYWN0aXZlXCIgOiBudWxsLCBpc1BlbmRpbmcgPyBcInBlbmRpbmdcIiA6IG51bGwsIGlzVHJhbnNpdGlvbmluZyA/IFwidHJhbnNpdGlvbmluZ1wiIDogbnVsbF0uZmlsdGVyKEJvb2xlYW4pLmpvaW4oXCIgXCIpO1xuICAgIH1cbiAgICBsZXQgc3R5bGUgPSB0eXBlb2Ygc3R5bGVQcm9wID09PSBcImZ1bmN0aW9uXCIgPyBzdHlsZVByb3AocmVuZGVyUHJvcHMpIDogc3R5bGVQcm9wO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KExpbmssIF9leHRlbmRzKHt9LCByZXN0LCB7XG4gICAgICBcImFyaWEtY3VycmVudFwiOiBhcmlhQ3VycmVudCxcbiAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lLFxuICAgICAgcmVmOiByZWYsXG4gICAgICBzdHlsZTogc3R5bGUsXG4gICAgICB0bzogdG8sXG4gICAgICB1bnN0YWJsZV92aWV3VHJhbnNpdGlvbjogdW5zdGFibGVfdmlld1RyYW5zaXRpb25cbiAgICB9KSwgdHlwZW9mIGNoaWxkcmVuID09PSBcImZ1bmN0aW9uXCIgPyBjaGlsZHJlbihyZW5kZXJQcm9wcykgOiBjaGlsZHJlbik7XG4gIH0pO1xuICB7XG4gICAgTmF2TGluay5kaXNwbGF5TmFtZSA9IFwiTmF2TGlua1wiO1xuICB9XG4gIC8qKlxuICAgKiBBIGBAcmVtaXgtcnVuL3JvdXRlcmAtYXdhcmUgYDxmb3JtPmAuIEl0IGJlaGF2ZXMgbGlrZSBhIG5vcm1hbCBmb3JtIGV4Y2VwdFxuICAgKiB0aGF0IHRoZSBpbnRlcmFjdGlvbiB3aXRoIHRoZSBzZXJ2ZXIgaXMgd2l0aCBgZmV0Y2hgIGluc3RlYWQgb2YgbmV3IGRvY3VtZW50XG4gICAqIHJlcXVlc3RzLCBhbGxvd2luZyBjb21wb25lbnRzIHRvIGFkZCBuaWNlciBVWCB0byB0aGUgcGFnZSBhcyB0aGUgZm9ybSBpc1xuICAgKiBzdWJtaXR0ZWQgYW5kIHJldHVybnMgd2l0aCBkYXRhLlxuICAgKi9cbiAgY29uc3QgRm9ybSA9IC8qI19fUFVSRV9fKi9SZWFjdF9fbmFtZXNwYWNlLmZvcndhcmRSZWYoKF9yZWY5LCBmb3J3YXJkZWRSZWYpID0+IHtcbiAgICBsZXQge1xuICAgICAgICBmZXRjaGVyS2V5LFxuICAgICAgICBuYXZpZ2F0ZSxcbiAgICAgICAgcmVsb2FkRG9jdW1lbnQsXG4gICAgICAgIHJlcGxhY2UsXG4gICAgICAgIHN0YXRlLFxuICAgICAgICBtZXRob2QgPSBkZWZhdWx0TWV0aG9kLFxuICAgICAgICBhY3Rpb24sXG4gICAgICAgIG9uU3VibWl0LFxuICAgICAgICByZWxhdGl2ZSxcbiAgICAgICAgcHJldmVudFNjcm9sbFJlc2V0LFxuICAgICAgICB1bnN0YWJsZV92aWV3VHJhbnNpdGlvblxuICAgICAgfSA9IF9yZWY5LFxuICAgICAgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfcmVmOSwgX2V4Y2x1ZGVkMyk7XG4gICAgbGV0IHN1Ym1pdCA9IHVzZVN1Ym1pdCgpO1xuICAgIGxldCBmb3JtQWN0aW9uID0gdXNlRm9ybUFjdGlvbihhY3Rpb24sIHtcbiAgICAgIHJlbGF0aXZlXG4gICAgfSk7XG4gICAgbGV0IGZvcm1NZXRob2QgPSBtZXRob2QudG9Mb3dlckNhc2UoKSA9PT0gXCJnZXRcIiA/IFwiZ2V0XCIgOiBcInBvc3RcIjtcbiAgICBsZXQgc3VibWl0SGFuZGxlciA9IGV2ZW50ID0+IHtcbiAgICAgIG9uU3VibWl0ICYmIG9uU3VibWl0KGV2ZW50KTtcbiAgICAgIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkKSByZXR1cm47XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgbGV0IHN1Ym1pdHRlciA9IGV2ZW50Lm5hdGl2ZUV2ZW50LnN1Ym1pdHRlcjtcbiAgICAgIGxldCBzdWJtaXRNZXRob2QgPSAoc3VibWl0dGVyID09IG51bGwgPyB2b2lkIDAgOiBzdWJtaXR0ZXIuZ2V0QXR0cmlidXRlKFwiZm9ybW1ldGhvZFwiKSkgfHwgbWV0aG9kO1xuICAgICAgc3VibWl0KHN1Ym1pdHRlciB8fCBldmVudC5jdXJyZW50VGFyZ2V0LCB7XG4gICAgICAgIGZldGNoZXJLZXksXG4gICAgICAgIG1ldGhvZDogc3VibWl0TWV0aG9kLFxuICAgICAgICBuYXZpZ2F0ZSxcbiAgICAgICAgcmVwbGFjZSxcbiAgICAgICAgc3RhdGUsXG4gICAgICAgIHJlbGF0aXZlLFxuICAgICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgICAgIHVuc3RhYmxlX3ZpZXdUcmFuc2l0aW9uXG4gICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwiZm9ybVwiLCBfZXh0ZW5kcyh7XG4gICAgICByZWY6IGZvcndhcmRlZFJlZixcbiAgICAgIG1ldGhvZDogZm9ybU1ldGhvZCxcbiAgICAgIGFjdGlvbjogZm9ybUFjdGlvbixcbiAgICAgIG9uU3VibWl0OiByZWxvYWREb2N1bWVudCA/IG9uU3VibWl0IDogc3VibWl0SGFuZGxlclxuICAgIH0sIHByb3BzKSk7XG4gIH0pO1xuICB7XG4gICAgRm9ybS5kaXNwbGF5TmFtZSA9IFwiRm9ybVwiO1xuICB9XG4gIC8qKlxuICAgKiBUaGlzIGNvbXBvbmVudCB3aWxsIGVtdWxhdGUgdGhlIGJyb3dzZXIncyBzY3JvbGwgcmVzdG9yYXRpb24gb24gbG9jYXRpb25cbiAgICogY2hhbmdlcy5cbiAgICovXG4gIGZ1bmN0aW9uIFNjcm9sbFJlc3RvcmF0aW9uKF9yZWYxMCkge1xuICAgIGxldCB7XG4gICAgICBnZXRLZXksXG4gICAgICBzdG9yYWdlS2V5XG4gICAgfSA9IF9yZWYxMDtcbiAgICB1c2VTY3JvbGxSZXN0b3JhdGlvbih7XG4gICAgICBnZXRLZXksXG4gICAgICBzdG9yYWdlS2V5XG4gICAgfSk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAge1xuICAgIFNjcm9sbFJlc3RvcmF0aW9uLmRpc3BsYXlOYW1lID0gXCJTY3JvbGxSZXN0b3JhdGlvblwiO1xuICB9XG4gIC8vI2VuZHJlZ2lvblxuXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIC8vI3JlZ2lvbiBIb29rc1xuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICB2YXIgRGF0YVJvdXRlckhvb2sgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKERhdGFSb3V0ZXJIb29rKSB7XG4gICAgRGF0YVJvdXRlckhvb2tbXCJVc2VTY3JvbGxSZXN0b3JhdGlvblwiXSA9IFwidXNlU2Nyb2xsUmVzdG9yYXRpb25cIjtcbiAgICBEYXRhUm91dGVySG9va1tcIlVzZVN1Ym1pdFwiXSA9IFwidXNlU3VibWl0XCI7XG4gICAgRGF0YVJvdXRlckhvb2tbXCJVc2VTdWJtaXRGZXRjaGVyXCJdID0gXCJ1c2VTdWJtaXRGZXRjaGVyXCI7XG4gICAgRGF0YVJvdXRlckhvb2tbXCJVc2VGZXRjaGVyXCJdID0gXCJ1c2VGZXRjaGVyXCI7XG4gICAgRGF0YVJvdXRlckhvb2tbXCJ1c2VWaWV3VHJhbnNpdGlvblN0YXRlXCJdID0gXCJ1c2VWaWV3VHJhbnNpdGlvblN0YXRlXCI7XG4gICAgcmV0dXJuIERhdGFSb3V0ZXJIb29rO1xuICB9KERhdGFSb3V0ZXJIb29rIHx8IHt9KTtcbiAgdmFyIERhdGFSb3V0ZXJTdGF0ZUhvb2sgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKERhdGFSb3V0ZXJTdGF0ZUhvb2spIHtcbiAgICBEYXRhUm91dGVyU3RhdGVIb29rW1wiVXNlRmV0Y2hlclwiXSA9IFwidXNlRmV0Y2hlclwiO1xuICAgIERhdGFSb3V0ZXJTdGF0ZUhvb2tbXCJVc2VGZXRjaGVyc1wiXSA9IFwidXNlRmV0Y2hlcnNcIjtcbiAgICBEYXRhUm91dGVyU3RhdGVIb29rW1wiVXNlU2Nyb2xsUmVzdG9yYXRpb25cIl0gPSBcInVzZVNjcm9sbFJlc3RvcmF0aW9uXCI7XG4gICAgcmV0dXJuIERhdGFSb3V0ZXJTdGF0ZUhvb2s7XG4gIH0oRGF0YVJvdXRlclN0YXRlSG9vayB8fCB7fSk7IC8vIEludGVybmFsIGhvb2tzXG4gIGZ1bmN0aW9uIGdldERhdGFSb3V0ZXJDb25zb2xlRXJyb3IoaG9va05hbWUpIHtcbiAgICByZXR1cm4gaG9va05hbWUgKyBcIiBtdXN0IGJlIHVzZWQgd2l0aGluIGEgZGF0YSByb3V0ZXIuICBTZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vcm91dGVycy9waWNraW5nLWEtcm91dGVyLlwiO1xuICB9XG4gIGZ1bmN0aW9uIHVzZURhdGFSb3V0ZXJDb250ZXh0KGhvb2tOYW1lKSB7XG4gICAgbGV0IGN0eCA9IFJlYWN0X19uYW1lc3BhY2UudXNlQ29udGV4dChyZWFjdFJvdXRlci5VTlNBRkVfRGF0YVJvdXRlckNvbnRleHQpO1xuICAgICFjdHggPyByb3V0ZXIuVU5TQUZFX2ludmFyaWFudChmYWxzZSwgZ2V0RGF0YVJvdXRlckNvbnNvbGVFcnJvcihob29rTmFtZSkpICA6IHZvaWQgMDtcbiAgICByZXR1cm4gY3R4O1xuICB9XG4gIGZ1bmN0aW9uIHVzZURhdGFSb3V0ZXJTdGF0ZShob29rTmFtZSkge1xuICAgIGxldCBzdGF0ZSA9IFJlYWN0X19uYW1lc3BhY2UudXNlQ29udGV4dChyZWFjdFJvdXRlci5VTlNBRkVfRGF0YVJvdXRlclN0YXRlQ29udGV4dCk7XG4gICAgIXN0YXRlID8gcm91dGVyLlVOU0FGRV9pbnZhcmlhbnQoZmFsc2UsIGdldERhdGFSb3V0ZXJDb25zb2xlRXJyb3IoaG9va05hbWUpKSAgOiB2b2lkIDA7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG5cbiAgLy8gRXh0ZXJuYWwgaG9va3NcblxuICAvKipcbiAgICogSGFuZGxlcyB0aGUgY2xpY2sgYmVoYXZpb3IgZm9yIHJvdXRlciBgPExpbms+YCBjb21wb25lbnRzLiBUaGlzIGlzIHVzZWZ1bCBpZlxuICAgKiB5b3UgbmVlZCB0byBjcmVhdGUgY3VzdG9tIGA8TGluaz5gIGNvbXBvbmVudHMgd2l0aCB0aGUgc2FtZSBjbGljayBiZWhhdmlvciB3ZVxuICAgKiB1c2UgaW4gb3VyIGV4cG9ydGVkIGA8TGluaz5gLlxuICAgKi9cbiAgZnVuY3Rpb24gdXNlTGlua0NsaWNrSGFuZGxlcih0bywgX3RlbXApIHtcbiAgICBsZXQge1xuICAgICAgdGFyZ2V0LFxuICAgICAgcmVwbGFjZTogcmVwbGFjZVByb3AsXG4gICAgICBzdGF0ZSxcbiAgICAgIHByZXZlbnRTY3JvbGxSZXNldCxcbiAgICAgIHJlbGF0aXZlLFxuICAgICAgdW5zdGFibGVfdmlld1RyYW5zaXRpb25cbiAgICB9ID0gX3RlbXAgPT09IHZvaWQgMCA/IHt9IDogX3RlbXA7XG4gICAgbGV0IG5hdmlnYXRlID0gcmVhY3RSb3V0ZXIudXNlTmF2aWdhdGUoKTtcbiAgICBsZXQgbG9jYXRpb24gPSByZWFjdFJvdXRlci51c2VMb2NhdGlvbigpO1xuICAgIGxldCBwYXRoID0gcmVhY3RSb3V0ZXIudXNlUmVzb2x2ZWRQYXRoKHRvLCB7XG4gICAgICByZWxhdGl2ZVxuICAgIH0pO1xuICAgIHJldHVybiBSZWFjdF9fbmFtZXNwYWNlLnVzZUNhbGxiYWNrKGV2ZW50ID0+IHtcbiAgICAgIGlmIChzaG91bGRQcm9jZXNzTGlua0NsaWNrKGV2ZW50LCB0YXJnZXQpKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgLy8gSWYgdGhlIFVSTCBoYXNuJ3QgY2hhbmdlZCwgYSByZWd1bGFyIDxhPiB3aWxsIGRvIGEgcmVwbGFjZSBpbnN0ZWFkIG9mXG4gICAgICAgIC8vIGEgcHVzaCwgc28gZG8gdGhlIHNhbWUgaGVyZSB1bmxlc3MgdGhlIHJlcGxhY2UgcHJvcCBpcyBleHBsaWNpdGx5IHNldFxuICAgICAgICBsZXQgcmVwbGFjZSA9IHJlcGxhY2VQcm9wICE9PSB1bmRlZmluZWQgPyByZXBsYWNlUHJvcCA6IHJlYWN0Um91dGVyLmNyZWF0ZVBhdGgobG9jYXRpb24pID09PSByZWFjdFJvdXRlci5jcmVhdGVQYXRoKHBhdGgpO1xuICAgICAgICBuYXZpZ2F0ZSh0bywge1xuICAgICAgICAgIHJlcGxhY2UsXG4gICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgcHJldmVudFNjcm9sbFJlc2V0LFxuICAgICAgICAgIHJlbGF0aXZlLFxuICAgICAgICAgIHVuc3RhYmxlX3ZpZXdUcmFuc2l0aW9uXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIFtsb2NhdGlvbiwgbmF2aWdhdGUsIHBhdGgsIHJlcGxhY2VQcm9wLCBzdGF0ZSwgdGFyZ2V0LCB0bywgcHJldmVudFNjcm9sbFJlc2V0LCByZWxhdGl2ZSwgdW5zdGFibGVfdmlld1RyYW5zaXRpb25dKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIGNvbnZlbmllbnQgd3JhcHBlciBmb3IgcmVhZGluZyBhbmQgd3JpdGluZyBzZWFyY2ggcGFyYW1ldGVycyB2aWEgdGhlXG4gICAqIFVSTFNlYXJjaFBhcmFtcyBpbnRlcmZhY2UuXG4gICAqL1xuICBmdW5jdGlvbiB1c2VTZWFyY2hQYXJhbXMoZGVmYXVsdEluaXQpIHtcbiAgICByb3V0ZXIuVU5TQUZFX3dhcm5pbmcodHlwZW9mIFVSTFNlYXJjaFBhcmFtcyAhPT0gXCJ1bmRlZmluZWRcIiwgXCJZb3UgY2Fubm90IHVzZSB0aGUgYHVzZVNlYXJjaFBhcmFtc2AgaG9vayBpbiBhIGJyb3dzZXIgdGhhdCBkb2VzIG5vdCBcIiArIFwic3VwcG9ydCB0aGUgVVJMU2VhcmNoUGFyYW1zIEFQSS4gSWYgeW91IG5lZWQgdG8gc3VwcG9ydCBJbnRlcm5ldCBcIiArIFwiRXhwbG9yZXIgMTEsIHdlIHJlY29tbWVuZCB5b3UgbG9hZCBhIHBvbHlmaWxsIHN1Y2ggYXMgXCIgKyBcImh0dHBzOi8vZ2l0aHViLmNvbS91bmdhcC91cmwtc2VhcmNoLXBhcmFtc1xcblxcblwiICsgXCJJZiB5b3UncmUgdW5zdXJlIGhvdyB0byBsb2FkIHBvbHlmaWxscywgd2UgcmVjb21tZW5kIHlvdSBjaGVjayBvdXQgXCIgKyBcImh0dHBzOi8vcG9seWZpbGwuaW8vdjMvIHdoaWNoIHByb3ZpZGVzIHNvbWUgcmVjb21tZW5kYXRpb25zIGFib3V0IGhvdyBcIiArIFwidG8gbG9hZCBwb2x5ZmlsbHMgb25seSBmb3IgdXNlcnMgdGhhdCBuZWVkIHRoZW0sIGluc3RlYWQgb2YgZm9yIGV2ZXJ5IFwiICsgXCJ1c2VyLlwiKSA7XG4gICAgbGV0IGRlZmF1bHRTZWFyY2hQYXJhbXNSZWYgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVJlZihjcmVhdGVTZWFyY2hQYXJhbXMoZGVmYXVsdEluaXQpKTtcbiAgICBsZXQgaGFzU2V0U2VhcmNoUGFyYW1zUmVmID0gUmVhY3RfX25hbWVzcGFjZS51c2VSZWYoZmFsc2UpO1xuICAgIGxldCBsb2NhdGlvbiA9IHJlYWN0Um91dGVyLnVzZUxvY2F0aW9uKCk7XG4gICAgbGV0IHNlYXJjaFBhcmFtcyA9IFJlYWN0X19uYW1lc3BhY2UudXNlTWVtbygoKSA9PlxuICAgIC8vIE9ubHkgbWVyZ2UgaW4gdGhlIGRlZmF1bHRzIGlmIHdlIGhhdmVuJ3QgeWV0IGNhbGxlZCBzZXRTZWFyY2hQYXJhbXMuXG4gICAgLy8gT25jZSB3ZSBjYWxsIHRoYXQgd2Ugd2FudCB0aG9zZSB0byB0YWtlIHByZWNlZGVuY2UsIG90aGVyd2lzZSB5b3UgY2FuJ3RcbiAgICAvLyByZW1vdmUgYSBwYXJhbSB3aXRoIHNldFNlYXJjaFBhcmFtcyh7fSkgaWYgaXQgaGFzIGFuIGluaXRpYWwgdmFsdWVcbiAgICBnZXRTZWFyY2hQYXJhbXNGb3JMb2NhdGlvbihsb2NhdGlvbi5zZWFyY2gsIGhhc1NldFNlYXJjaFBhcmFtc1JlZi5jdXJyZW50ID8gbnVsbCA6IGRlZmF1bHRTZWFyY2hQYXJhbXNSZWYuY3VycmVudCksIFtsb2NhdGlvbi5zZWFyY2hdKTtcbiAgICBsZXQgbmF2aWdhdGUgPSByZWFjdFJvdXRlci51c2VOYXZpZ2F0ZSgpO1xuICAgIGxldCBzZXRTZWFyY2hQYXJhbXMgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZUNhbGxiYWNrKChuZXh0SW5pdCwgbmF2aWdhdGVPcHRpb25zKSA9PiB7XG4gICAgICBjb25zdCBuZXdTZWFyY2hQYXJhbXMgPSBjcmVhdGVTZWFyY2hQYXJhbXModHlwZW9mIG5leHRJbml0ID09PSBcImZ1bmN0aW9uXCIgPyBuZXh0SW5pdChzZWFyY2hQYXJhbXMpIDogbmV4dEluaXQpO1xuICAgICAgaGFzU2V0U2VhcmNoUGFyYW1zUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgbmF2aWdhdGUoXCI/XCIgKyBuZXdTZWFyY2hQYXJhbXMsIG5hdmlnYXRlT3B0aW9ucyk7XG4gICAgfSwgW25hdmlnYXRlLCBzZWFyY2hQYXJhbXNdKTtcbiAgICByZXR1cm4gW3NlYXJjaFBhcmFtcywgc2V0U2VhcmNoUGFyYW1zXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdWJtaXRzIGEgSFRNTCBgPGZvcm0+YCB0byB0aGUgc2VydmVyIHdpdGhvdXQgcmVsb2FkaW5nIHRoZSBwYWdlLlxuICAgKi9cblxuICAvKipcbiAgICogU3VibWl0cyBhIGZldGNoZXIgYDxmb3JtPmAgdG8gdGhlIHNlcnZlciB3aXRob3V0IHJlbG9hZGluZyB0aGUgcGFnZS5cbiAgICovXG5cbiAgZnVuY3Rpb24gdmFsaWRhdGVDbGllbnRTaWRlU3VibWlzc2lvbigpIHtcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgYXJlIGNhbGxpbmcgc3VibWl0IGR1cmluZyB0aGUgc2VydmVyIHJlbmRlci4gXCIgKyBcIlRyeSBjYWxsaW5nIHN1Ym1pdCB3aXRoaW4gYSBgdXNlRWZmZWN0YCBvciBjYWxsYmFjayBpbnN0ZWFkLlwiKTtcbiAgICB9XG4gIH1cbiAgbGV0IGZldGNoZXJJZCA9IDA7XG4gIGxldCBnZXRVbmlxdWVGZXRjaGVySWQgPSAoKSA9PiBcIl9fXCIgKyBTdHJpbmcoKytmZXRjaGVySWQpICsgXCJfX1wiO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBtYXkgYmUgdXNlZCB0byBwcm9ncmFtbWF0aWNhbGx5IHN1Ym1pdCBhIGZvcm0gKG9yXG4gICAqIHNvbWUgYXJiaXRyYXJ5IGRhdGEpIHRvIHRoZSBzZXJ2ZXIuXG4gICAqL1xuICBmdW5jdGlvbiB1c2VTdWJtaXQoKSB7XG4gICAgbGV0IHtcbiAgICAgIHJvdXRlclxuICAgIH0gPSB1c2VEYXRhUm91dGVyQ29udGV4dChEYXRhUm91dGVySG9vay5Vc2VTdWJtaXQpO1xuICAgIGxldCB7XG4gICAgICBiYXNlbmFtZVxuICAgIH0gPSBSZWFjdF9fbmFtZXNwYWNlLnVzZUNvbnRleHQocmVhY3RSb3V0ZXIuVU5TQUZFX05hdmlnYXRpb25Db250ZXh0KTtcbiAgICBsZXQgY3VycmVudFJvdXRlSWQgPSByZWFjdFJvdXRlci5VTlNBRkVfdXNlUm91dGVJZCgpO1xuICAgIHJldHVybiBSZWFjdF9fbmFtZXNwYWNlLnVzZUNhbGxiYWNrKGZ1bmN0aW9uICh0YXJnZXQsIG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgfVxuICAgICAgdmFsaWRhdGVDbGllbnRTaWRlU3VibWlzc2lvbigpO1xuICAgICAgbGV0IHtcbiAgICAgICAgYWN0aW9uLFxuICAgICAgICBtZXRob2QsXG4gICAgICAgIGVuY1R5cGUsXG4gICAgICAgIGZvcm1EYXRhLFxuICAgICAgICBib2R5XG4gICAgICB9ID0gZ2V0Rm9ybVN1Ym1pc3Npb25JbmZvKHRhcmdldCwgYmFzZW5hbWUpO1xuICAgICAgaWYgKG9wdGlvbnMubmF2aWdhdGUgPT09IGZhbHNlKSB7XG4gICAgICAgIGxldCBrZXkgPSBvcHRpb25zLmZldGNoZXJLZXkgfHwgZ2V0VW5pcXVlRmV0Y2hlcklkKCk7XG4gICAgICAgIHJvdXRlci5mZXRjaChrZXksIGN1cnJlbnRSb3V0ZUlkLCBvcHRpb25zLmFjdGlvbiB8fCBhY3Rpb24sIHtcbiAgICAgICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQ6IG9wdGlvbnMucHJldmVudFNjcm9sbFJlc2V0LFxuICAgICAgICAgIGZvcm1EYXRhLFxuICAgICAgICAgIGJvZHksXG4gICAgICAgICAgZm9ybU1ldGhvZDogb3B0aW9ucy5tZXRob2QgfHwgbWV0aG9kLFxuICAgICAgICAgIGZvcm1FbmNUeXBlOiBvcHRpb25zLmVuY1R5cGUgfHwgZW5jVHlwZSxcbiAgICAgICAgICB1bnN0YWJsZV9mbHVzaFN5bmM6IG9wdGlvbnMudW5zdGFibGVfZmx1c2hTeW5jXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcm91dGVyLm5hdmlnYXRlKG9wdGlvbnMuYWN0aW9uIHx8IGFjdGlvbiwge1xuICAgICAgICAgIHByZXZlbnRTY3JvbGxSZXNldDogb3B0aW9ucy5wcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgICAgICAgZm9ybURhdGEsXG4gICAgICAgICAgYm9keSxcbiAgICAgICAgICBmb3JtTWV0aG9kOiBvcHRpb25zLm1ldGhvZCB8fCBtZXRob2QsXG4gICAgICAgICAgZm9ybUVuY1R5cGU6IG9wdGlvbnMuZW5jVHlwZSB8fCBlbmNUeXBlLFxuICAgICAgICAgIHJlcGxhY2U6IG9wdGlvbnMucmVwbGFjZSxcbiAgICAgICAgICBzdGF0ZTogb3B0aW9ucy5zdGF0ZSxcbiAgICAgICAgICBmcm9tUm91dGVJZDogY3VycmVudFJvdXRlSWQsXG4gICAgICAgICAgdW5zdGFibGVfZmx1c2hTeW5jOiBvcHRpb25zLnVuc3RhYmxlX2ZsdXNoU3luYyxcbiAgICAgICAgICB1bnN0YWJsZV92aWV3VHJhbnNpdGlvbjogb3B0aW9ucy51bnN0YWJsZV92aWV3VHJhbnNpdGlvblxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCBbcm91dGVyLCBiYXNlbmFtZSwgY3VycmVudFJvdXRlSWRdKTtcbiAgfVxuXG4gIC8vIHY3OiBFdmVudHVhbGx5IHdlIHNob3VsZCBkZXByZWNhdGUgdGhpcyBlbnRpcmVseSBpbiBmYXZvciBvZiB1c2luZyB0aGVcbiAgLy8gcm91dGVyIG1ldGhvZCBkaXJlY3RseT9cbiAgZnVuY3Rpb24gdXNlRm9ybUFjdGlvbihhY3Rpb24sIF90ZW1wMikge1xuICAgIGxldCB7XG4gICAgICByZWxhdGl2ZVxuICAgIH0gPSBfdGVtcDIgPT09IHZvaWQgMCA/IHt9IDogX3RlbXAyO1xuICAgIGxldCB7XG4gICAgICBiYXNlbmFtZVxuICAgIH0gPSBSZWFjdF9fbmFtZXNwYWNlLnVzZUNvbnRleHQocmVhY3RSb3V0ZXIuVU5TQUZFX05hdmlnYXRpb25Db250ZXh0KTtcbiAgICBsZXQgcm91dGVDb250ZXh0ID0gUmVhY3RfX25hbWVzcGFjZS51c2VDb250ZXh0KHJlYWN0Um91dGVyLlVOU0FGRV9Sb3V0ZUNvbnRleHQpO1xuICAgICFyb3V0ZUNvbnRleHQgPyByb3V0ZXIuVU5TQUZFX2ludmFyaWFudChmYWxzZSwgXCJ1c2VGb3JtQWN0aW9uIG11c3QgYmUgdXNlZCBpbnNpZGUgYSBSb3V0ZUNvbnRleHRcIikgIDogdm9pZCAwO1xuICAgIGxldCBbbWF0Y2hdID0gcm91dGVDb250ZXh0Lm1hdGNoZXMuc2xpY2UoLTEpO1xuICAgIC8vIFNoYWxsb3cgY2xvbmUgcGF0aCBzbyB3ZSBjYW4gbW9kaWZ5IGl0IGJlbG93LCBvdGhlcndpc2Ugd2UgbW9kaWZ5IHRoZVxuICAgIC8vIG9iamVjdCByZWZlcmVuY2VkIGJ5IHVzZU1lbW8gaW5zaWRlIHVzZVJlc29sdmVkUGF0aFxuICAgIGxldCBwYXRoID0gX2V4dGVuZHMoe30sIHJlYWN0Um91dGVyLnVzZVJlc29sdmVkUGF0aChhY3Rpb24gPyBhY3Rpb24gOiBcIi5cIiwge1xuICAgICAgcmVsYXRpdmVcbiAgICB9KSk7XG5cbiAgICAvLyBJZiBubyBhY3Rpb24gd2FzIHNwZWNpZmllZCwgYnJvd3NlcnMgd2lsbCBwZXJzaXN0IGN1cnJlbnQgc2VhcmNoIHBhcmFtc1xuICAgIC8vIHdoZW4gZGV0ZXJtaW5pbmcgdGhlIHBhdGgsIHNvIG1hdGNoIHRoYXQgYmVoYXZpb3JcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcmVtaXgtcnVuL3JlbWl4L2lzc3Vlcy85MjdcbiAgICBsZXQgbG9jYXRpb24gPSByZWFjdFJvdXRlci51c2VMb2NhdGlvbigpO1xuICAgIGlmIChhY3Rpb24gPT0gbnVsbCkge1xuICAgICAgLy8gU2FmZSB0byB3cml0ZSB0byB0aGlzIGRpcmVjdGx5IGhlcmUgc2luY2UgaWYgYWN0aW9uIHdhcyB1bmRlZmluZWQsIHdlXG4gICAgICAvLyB3b3VsZCBoYXZlIGNhbGxlZCB1c2VSZXNvbHZlZFBhdGgoXCIuXCIpIHdoaWNoIHdpbGwgbmV2ZXIgaW5jbHVkZSBhIHNlYXJjaFxuICAgICAgcGF0aC5zZWFyY2ggPSBsb2NhdGlvbi5zZWFyY2g7XG5cbiAgICAgIC8vIFdoZW4gZ3JhYmJpbmcgc2VhcmNoIHBhcmFtcyBmcm9tIHRoZSBVUkwsIHJlbW92ZSBhbnkgaW5jbHVkZWQgP2luZGV4IHBhcmFtXG4gICAgICAvLyBzaW5jZSBpdCBtaWdodCBub3QgYXBwbHkgdG8gb3VyIGNvbnRleHR1YWwgcm91dGUuICBXZSBhZGQgaXQgYmFjayBiYXNlZFxuICAgICAgLy8gb24gbWF0Y2gucm91dGUuaW5kZXggYmVsb3dcbiAgICAgIGxldCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHBhdGguc2VhcmNoKTtcbiAgICAgIGlmIChwYXJhbXMuaGFzKFwiaW5kZXhcIikgJiYgcGFyYW1zLmdldChcImluZGV4XCIpID09PSBcIlwiKSB7XG4gICAgICAgIHBhcmFtcy5kZWxldGUoXCJpbmRleFwiKTtcbiAgICAgICAgcGF0aC5zZWFyY2ggPSBwYXJhbXMudG9TdHJpbmcoKSA/IFwiP1wiICsgcGFyYW1zLnRvU3RyaW5nKCkgOiBcIlwiO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoKCFhY3Rpb24gfHwgYWN0aW9uID09PSBcIi5cIikgJiYgbWF0Y2gucm91dGUuaW5kZXgpIHtcbiAgICAgIHBhdGguc2VhcmNoID0gcGF0aC5zZWFyY2ggPyBwYXRoLnNlYXJjaC5yZXBsYWNlKC9eXFw/LywgXCI/aW5kZXgmXCIpIDogXCI/aW5kZXhcIjtcbiAgICB9XG5cbiAgICAvLyBJZiB3ZSdyZSBvcGVyYXRpbmcgd2l0aGluIGEgYmFzZW5hbWUsIHByZXBlbmQgaXQgdG8gdGhlIHBhdGhuYW1lIHByaW9yXG4gICAgLy8gdG8gY3JlYXRpbmcgdGhlIGZvcm0gYWN0aW9uLiAgSWYgdGhpcyBpcyBhIHJvb3QgbmF2aWdhdGlvbiwgdGhlbiBqdXN0IHVzZVxuICAgIC8vIHRoZSByYXcgYmFzZW5hbWUgd2hpY2ggYWxsb3dzIHRoZSBiYXNlbmFtZSB0byBoYXZlIGZ1bGwgY29udHJvbCBvdmVyIHRoZVxuICAgIC8vIHByZXNlbmNlIG9mIGEgdHJhaWxpbmcgc2xhc2ggb24gcm9vdCBhY3Rpb25zXG4gICAgaWYgKGJhc2VuYW1lICE9PSBcIi9cIikge1xuICAgICAgcGF0aC5wYXRobmFtZSA9IHBhdGgucGF0aG5hbWUgPT09IFwiL1wiID8gYmFzZW5hbWUgOiByb3V0ZXIuam9pblBhdGhzKFtiYXNlbmFtZSwgcGF0aC5wYXRobmFtZV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVhY3RSb3V0ZXIuY3JlYXRlUGF0aChwYXRoKTtcbiAgfVxuICAvLyBUT0RPOiAodjcpIENoYW5nZSB0aGUgdXNlRmV0Y2hlciBnZW5lcmljIGRlZmF1bHQgZnJvbSBgYW55YCB0byBgdW5rbm93bmBcbiAgLyoqXG4gICAqIEludGVyYWN0cyB3aXRoIHJvdXRlIGxvYWRlcnMgYW5kIGFjdGlvbnMgd2l0aG91dCBjYXVzaW5nIGEgbmF2aWdhdGlvbi4gR3JlYXRcbiAgICogZm9yIGFueSBpbnRlcmFjdGlvbiB0aGF0IHN0YXlzIG9uIHRoZSBzYW1lIHBhZ2UuXG4gICAqL1xuICBmdW5jdGlvbiB1c2VGZXRjaGVyKF90ZW1wMykge1xuICAgIHZhciBfcm91dGUkbWF0Y2hlcztcbiAgICBsZXQge1xuICAgICAga2V5XG4gICAgfSA9IF90ZW1wMyA9PT0gdm9pZCAwID8ge30gOiBfdGVtcDM7XG4gICAgbGV0IHtcbiAgICAgIHJvdXRlcjogcm91dGVyJDFcbiAgICB9ID0gdXNlRGF0YVJvdXRlckNvbnRleHQoRGF0YVJvdXRlckhvb2suVXNlRmV0Y2hlcik7XG4gICAgbGV0IHN0YXRlID0gdXNlRGF0YVJvdXRlclN0YXRlKERhdGFSb3V0ZXJTdGF0ZUhvb2suVXNlRmV0Y2hlcik7XG4gICAgbGV0IGZldGNoZXJEYXRhID0gUmVhY3RfX25hbWVzcGFjZS51c2VDb250ZXh0KEZldGNoZXJzQ29udGV4dCk7XG4gICAgbGV0IHJvdXRlID0gUmVhY3RfX25hbWVzcGFjZS51c2VDb250ZXh0KHJlYWN0Um91dGVyLlVOU0FGRV9Sb3V0ZUNvbnRleHQpO1xuICAgIGxldCByb3V0ZUlkID0gKF9yb3V0ZSRtYXRjaGVzID0gcm91dGUubWF0Y2hlc1tyb3V0ZS5tYXRjaGVzLmxlbmd0aCAtIDFdKSA9PSBudWxsID8gdm9pZCAwIDogX3JvdXRlJG1hdGNoZXMucm91dGUuaWQ7XG4gICAgIWZldGNoZXJEYXRhID8gcm91dGVyLlVOU0FGRV9pbnZhcmlhbnQoZmFsc2UsIFwidXNlRmV0Y2hlciBtdXN0IGJlIHVzZWQgaW5zaWRlIGEgRmV0Y2hlcnNDb250ZXh0XCIpICA6IHZvaWQgMDtcbiAgICAhcm91dGUgPyByb3V0ZXIuVU5TQUZFX2ludmFyaWFudChmYWxzZSwgXCJ1c2VGZXRjaGVyIG11c3QgYmUgdXNlZCBpbnNpZGUgYSBSb3V0ZUNvbnRleHRcIikgIDogdm9pZCAwO1xuICAgICEocm91dGVJZCAhPSBudWxsKSA/IHJvdXRlci5VTlNBRkVfaW52YXJpYW50KGZhbHNlLCBcInVzZUZldGNoZXIgY2FuIG9ubHkgYmUgdXNlZCBvbiByb3V0ZXMgdGhhdCBjb250YWluIGEgdW5pcXVlIFxcXCJpZFxcXCJcIikgIDogdm9pZCAwO1xuXG4gICAgLy8gRmV0Y2hlciBrZXkgaGFuZGxpbmdcbiAgICAvLyBPSyB0byBjYWxsIGNvbmRpdGlvbmFsbHkgdG8gZmVhdHVyZSBkZXRlY3QgYHVzZUlkYFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9ydWxlcy1vZi1ob29rc1xuICAgIGxldCBkZWZhdWx0S2V5ID0gdXNlSWRJbXBsID8gdXNlSWRJbXBsKCkgOiBcIlwiO1xuICAgIGxldCBbZmV0Y2hlcktleSwgc2V0RmV0Y2hlcktleV0gPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVN0YXRlKGtleSB8fCBkZWZhdWx0S2V5KTtcbiAgICBpZiAoa2V5ICYmIGtleSAhPT0gZmV0Y2hlcktleSkge1xuICAgICAgc2V0RmV0Y2hlcktleShrZXkpO1xuICAgIH0gZWxzZSBpZiAoIWZldGNoZXJLZXkpIHtcbiAgICAgIC8vIFdlIHdpbGwgb25seSBmYWxsIHRocm91Z2ggaGVyZSB3aGVuIGB1c2VJZGAgaXMgbm90IGF2YWlsYWJsZVxuICAgICAgc2V0RmV0Y2hlcktleShnZXRVbmlxdWVGZXRjaGVySWQoKSk7XG4gICAgfVxuXG4gICAgLy8gUmVnaXN0cmF0aW9uL2NsZWFudXBcbiAgICBSZWFjdF9fbmFtZXNwYWNlLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICByb3V0ZXIkMS5nZXRGZXRjaGVyKGZldGNoZXJLZXkpO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgLy8gVGVsbCB0aGUgcm91dGVyIHdlJ3ZlIHVubW91bnRlZCAtIGlmIHY3X2ZldGNoZXJQZXJzaXN0IGlzIGVuYWJsZWQgdGhpc1xuICAgICAgICAvLyB3aWxsIG5vdCBkZWxldGUgaW1tZWRpYXRlbHkgYnV0IGluc3RlYWQgcXVldWUgdXAgYSBkZWxldGUgYWZ0ZXIgdGhlXG4gICAgICAgIC8vIGZldGNoZXIgcmV0dXJucyB0byBhbiBgaWRsZWAgc3RhdGVcbiAgICAgICAgcm91dGVyJDEuZGVsZXRlRmV0Y2hlcihmZXRjaGVyS2V5KTtcbiAgICAgIH07XG4gICAgfSwgW3JvdXRlciQxLCBmZXRjaGVyS2V5XSk7XG5cbiAgICAvLyBGZXRjaGVyIGFkZGl0aW9uc1xuICAgIGxldCBsb2FkID0gUmVhY3RfX25hbWVzcGFjZS51c2VDYWxsYmFjaygoaHJlZiwgb3B0cykgPT4ge1xuICAgICAgIXJvdXRlSWQgPyByb3V0ZXIuVU5TQUZFX2ludmFyaWFudChmYWxzZSwgXCJObyByb3V0ZUlkIGF2YWlsYWJsZSBmb3IgZmV0Y2hlci5sb2FkKClcIikgIDogdm9pZCAwO1xuICAgICAgcm91dGVyJDEuZmV0Y2goZmV0Y2hlcktleSwgcm91dGVJZCwgaHJlZiwgb3B0cyk7XG4gICAgfSwgW2ZldGNoZXJLZXksIHJvdXRlSWQsIHJvdXRlciQxXSk7XG4gICAgbGV0IHN1Ym1pdEltcGwgPSB1c2VTdWJtaXQoKTtcbiAgICBsZXQgc3VibWl0ID0gUmVhY3RfX25hbWVzcGFjZS51c2VDYWxsYmFjaygodGFyZ2V0LCBvcHRzKSA9PiB7XG4gICAgICBzdWJtaXRJbXBsKHRhcmdldCwgX2V4dGVuZHMoe30sIG9wdHMsIHtcbiAgICAgICAgbmF2aWdhdGU6IGZhbHNlLFxuICAgICAgICBmZXRjaGVyS2V5XG4gICAgICB9KSk7XG4gICAgfSwgW2ZldGNoZXJLZXksIHN1Ym1pdEltcGxdKTtcbiAgICBsZXQgRmV0Y2hlckZvcm0gPSBSZWFjdF9fbmFtZXNwYWNlLnVzZU1lbW8oKCkgPT4ge1xuICAgICAgbGV0IEZldGNoZXJGb3JtID0gLyojX19QVVJFX18qL1JlYWN0X19uYW1lc3BhY2UuZm9yd2FyZFJlZigocHJvcHMsIHJlZikgPT4ge1xuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChGb3JtLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgICAgICAgICBuYXZpZ2F0ZTogZmFsc2UsXG4gICAgICAgICAgZmV0Y2hlcktleTogZmV0Y2hlcktleSxcbiAgICAgICAgICByZWY6IHJlZlxuICAgICAgICB9KSk7XG4gICAgICB9KTtcbiAgICAgIHtcbiAgICAgICAgRmV0Y2hlckZvcm0uZGlzcGxheU5hbWUgPSBcImZldGNoZXIuRm9ybVwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEZldGNoZXJGb3JtO1xuICAgIH0sIFtmZXRjaGVyS2V5XSk7XG5cbiAgICAvLyBFeHBvc2VkIEZldGNoZXJXaXRoQ29tcG9uZW50c1xuICAgIGxldCBmZXRjaGVyID0gc3RhdGUuZmV0Y2hlcnMuZ2V0KGZldGNoZXJLZXkpIHx8IHJvdXRlci5JRExFX0ZFVENIRVI7XG4gICAgbGV0IGRhdGEgPSBmZXRjaGVyRGF0YS5nZXQoZmV0Y2hlcktleSk7XG4gICAgbGV0IGZldGNoZXJXaXRoQ29tcG9uZW50cyA9IFJlYWN0X19uYW1lc3BhY2UudXNlTWVtbygoKSA9PiBfZXh0ZW5kcyh7XG4gICAgICBGb3JtOiBGZXRjaGVyRm9ybSxcbiAgICAgIHN1Ym1pdCxcbiAgICAgIGxvYWRcbiAgICB9LCBmZXRjaGVyLCB7XG4gICAgICBkYXRhXG4gICAgfSksIFtGZXRjaGVyRm9ybSwgc3VibWl0LCBsb2FkLCBmZXRjaGVyLCBkYXRhXSk7XG4gICAgcmV0dXJuIGZldGNoZXJXaXRoQ29tcG9uZW50cztcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm92aWRlcyBhbGwgZmV0Y2hlcnMgY3VycmVudGx5IG9uIHRoZSBwYWdlLiBVc2VmdWwgZm9yIGxheW91dHMgYW5kIHBhcmVudFxuICAgKiByb3V0ZXMgdGhhdCBuZWVkIHRvIHByb3ZpZGUgcGVuZGluZy9vcHRpbWlzdGljIFVJIHJlZ2FyZGluZyB0aGUgZmV0Y2guXG4gICAqL1xuICBmdW5jdGlvbiB1c2VGZXRjaGVycygpIHtcbiAgICBsZXQgc3RhdGUgPSB1c2VEYXRhUm91dGVyU3RhdGUoRGF0YVJvdXRlclN0YXRlSG9vay5Vc2VGZXRjaGVycyk7XG4gICAgcmV0dXJuIEFycmF5LmZyb20oc3RhdGUuZmV0Y2hlcnMuZW50cmllcygpKS5tYXAoX3JlZjExID0+IHtcbiAgICAgIGxldCBba2V5LCBmZXRjaGVyXSA9IF9yZWYxMTtcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgZmV0Y2hlciwge1xuICAgICAgICBrZXlcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIGNvbnN0IFNDUk9MTF9SRVNUT1JBVElPTl9TVE9SQUdFX0tFWSA9IFwicmVhY3Qtcm91dGVyLXNjcm9sbC1wb3NpdGlvbnNcIjtcbiAgbGV0IHNhdmVkU2Nyb2xsUG9zaXRpb25zID0ge307XG5cbiAgLyoqXG4gICAqIFdoZW4gcmVuZGVyZWQgaW5zaWRlIGEgUm91dGVyUHJvdmlkZXIsIHdpbGwgcmVzdG9yZSBzY3JvbGwgcG9zaXRpb25zIG9uIG5hdmlnYXRpb25zXG4gICAqL1xuICBmdW5jdGlvbiB1c2VTY3JvbGxSZXN0b3JhdGlvbihfdGVtcDQpIHtcbiAgICBsZXQge1xuICAgICAgZ2V0S2V5LFxuICAgICAgc3RvcmFnZUtleVxuICAgIH0gPSBfdGVtcDQgPT09IHZvaWQgMCA/IHt9IDogX3RlbXA0O1xuICAgIGxldCB7XG4gICAgICByb3V0ZXI6IHJvdXRlciQxXG4gICAgfSA9IHVzZURhdGFSb3V0ZXJDb250ZXh0KERhdGFSb3V0ZXJIb29rLlVzZVNjcm9sbFJlc3RvcmF0aW9uKTtcbiAgICBsZXQge1xuICAgICAgcmVzdG9yZVNjcm9sbFBvc2l0aW9uLFxuICAgICAgcHJldmVudFNjcm9sbFJlc2V0XG4gICAgfSA9IHVzZURhdGFSb3V0ZXJTdGF0ZShEYXRhUm91dGVyU3RhdGVIb29rLlVzZVNjcm9sbFJlc3RvcmF0aW9uKTtcbiAgICBsZXQge1xuICAgICAgYmFzZW5hbWVcbiAgICB9ID0gUmVhY3RfX25hbWVzcGFjZS51c2VDb250ZXh0KHJlYWN0Um91dGVyLlVOU0FGRV9OYXZpZ2F0aW9uQ29udGV4dCk7XG4gICAgbGV0IGxvY2F0aW9uID0gcmVhY3RSb3V0ZXIudXNlTG9jYXRpb24oKTtcbiAgICBsZXQgbWF0Y2hlcyA9IHJlYWN0Um91dGVyLnVzZU1hdGNoZXMoKTtcbiAgICBsZXQgbmF2aWdhdGlvbiA9IHJlYWN0Um91dGVyLnVzZU5hdmlnYXRpb24oKTtcblxuICAgIC8vIFRyaWdnZXIgbWFudWFsIHNjcm9sbCByZXN0b3JhdGlvbiB3aGlsZSB3ZSdyZSBhY3RpdmVcbiAgICBSZWFjdF9fbmFtZXNwYWNlLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICB3aW5kb3cuaGlzdG9yeS5zY3JvbGxSZXN0b3JhdGlvbiA9IFwibWFudWFsXCI7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICB3aW5kb3cuaGlzdG9yeS5zY3JvbGxSZXN0b3JhdGlvbiA9IFwiYXV0b1wiO1xuICAgICAgfTtcbiAgICB9LCBbXSk7XG5cbiAgICAvLyBTYXZlIHBvc2l0aW9ucyBvbiBwYWdlaGlkZVxuICAgIHVzZVBhZ2VIaWRlKFJlYWN0X19uYW1lc3BhY2UudXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgaWYgKG5hdmlnYXRpb24uc3RhdGUgPT09IFwiaWRsZVwiKSB7XG4gICAgICAgIGxldCBrZXkgPSAoZ2V0S2V5ID8gZ2V0S2V5KGxvY2F0aW9uLCBtYXRjaGVzKSA6IG51bGwpIHx8IGxvY2F0aW9uLmtleTtcbiAgICAgICAgc2F2ZWRTY3JvbGxQb3NpdGlvbnNba2V5XSA9IHdpbmRvdy5zY3JvbGxZO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShzdG9yYWdlS2V5IHx8IFNDUk9MTF9SRVNUT1JBVElPTl9TVE9SQUdFX0tFWSwgSlNPTi5zdHJpbmdpZnkoc2F2ZWRTY3JvbGxQb3NpdGlvbnMpKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJvdXRlci5VTlNBRkVfd2FybmluZyhmYWxzZSwgXCJGYWlsZWQgdG8gc2F2ZSBzY3JvbGwgcG9zaXRpb25zIGluIHNlc3Npb25TdG9yYWdlLCA8U2Nyb2xsUmVzdG9yYXRpb24gLz4gd2lsbCBub3Qgd29yayBwcm9wZXJseSAoXCIgKyBlcnJvciArIFwiKS5cIikgO1xuICAgICAgfVxuICAgICAgd2luZG93Lmhpc3Rvcnkuc2Nyb2xsUmVzdG9yYXRpb24gPSBcImF1dG9cIjtcbiAgICB9LCBbc3RvcmFnZUtleSwgZ2V0S2V5LCBuYXZpZ2F0aW9uLnN0YXRlLCBsb2NhdGlvbiwgbWF0Y2hlc10pKTtcblxuICAgIC8vIFJlYWQgaW4gYW55IHNhdmVkIHNjcm9sbCBsb2NhdGlvbnNcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgICAgIFJlYWN0X19uYW1lc3BhY2UudXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBsZXQgc2Vzc2lvblBvc2l0aW9ucyA9IHNlc3Npb25TdG9yYWdlLmdldEl0ZW0oc3RvcmFnZUtleSB8fCBTQ1JPTExfUkVTVE9SQVRJT05fU1RPUkFHRV9LRVkpO1xuICAgICAgICAgIGlmIChzZXNzaW9uUG9zaXRpb25zKSB7XG4gICAgICAgICAgICBzYXZlZFNjcm9sbFBvc2l0aW9ucyA9IEpTT04ucGFyc2Uoc2Vzc2lvblBvc2l0aW9ucyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLy8gbm8tb3AsIHVzZSBkZWZhdWx0IGVtcHR5IG9iamVjdFxuICAgICAgICB9XG4gICAgICB9LCBbc3RvcmFnZUtleV0pO1xuXG4gICAgICAvLyBFbmFibGUgc2Nyb2xsIHJlc3RvcmF0aW9uIGluIHRoZSByb3V0ZXJcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9ydWxlcy1vZi1ob29rc1xuICAgICAgUmVhY3RfX25hbWVzcGFjZS51c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICBsZXQgZ2V0S2V5V2l0aG91dEJhc2VuYW1lID0gZ2V0S2V5ICYmIGJhc2VuYW1lICE9PSBcIi9cIiA/IChsb2NhdGlvbiwgbWF0Y2hlcykgPT4gZ2V0S2V5KCAvLyBTdHJpcCB0aGUgYmFzZW5hbWUgdG8gbWF0Y2ggdXNlTG9jYXRpb24oKVxuICAgICAgICBfZXh0ZW5kcyh7fSwgbG9jYXRpb24sIHtcbiAgICAgICAgICBwYXRobmFtZTogcm91dGVyLnN0cmlwQmFzZW5hbWUobG9jYXRpb24ucGF0aG5hbWUsIGJhc2VuYW1lKSB8fCBsb2NhdGlvbi5wYXRobmFtZVxuICAgICAgICB9KSwgbWF0Y2hlcykgOiBnZXRLZXk7XG4gICAgICAgIGxldCBkaXNhYmxlU2Nyb2xsUmVzdG9yYXRpb24gPSByb3V0ZXIkMSA9PSBudWxsID8gdm9pZCAwIDogcm91dGVyJDEuZW5hYmxlU2Nyb2xsUmVzdG9yYXRpb24oc2F2ZWRTY3JvbGxQb3NpdGlvbnMsICgpID0+IHdpbmRvdy5zY3JvbGxZLCBnZXRLZXlXaXRob3V0QmFzZW5hbWUpO1xuICAgICAgICByZXR1cm4gKCkgPT4gZGlzYWJsZVNjcm9sbFJlc3RvcmF0aW9uICYmIGRpc2FibGVTY3JvbGxSZXN0b3JhdGlvbigpO1xuICAgICAgfSwgW3JvdXRlciQxLCBiYXNlbmFtZSwgZ2V0S2V5XSk7XG5cbiAgICAgIC8vIFJlc3RvcmUgc2Nyb2xsaW5nIHdoZW4gc3RhdGUucmVzdG9yZVNjcm9sbFBvc2l0aW9uIGNoYW5nZXNcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9ydWxlcy1vZi1ob29rc1xuICAgICAgUmVhY3RfX25hbWVzcGFjZS51c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICAvLyBFeHBsaWNpdCBmYWxzZSBtZWFucyBkb24ndCBkbyBhbnl0aGluZyAodXNlZCBmb3Igc3VibWlzc2lvbnMpXG4gICAgICAgIGlmIChyZXN0b3JlU2Nyb2xsUG9zaXRpb24gPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYmVlbiBoZXJlIGJlZm9yZSwgc2Nyb2xsIHRvIGl0XG4gICAgICAgIGlmICh0eXBlb2YgcmVzdG9yZVNjcm9sbFBvc2l0aW9uID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgd2luZG93LnNjcm9sbFRvKDAsIHJlc3RvcmVTY3JvbGxQb3NpdGlvbik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdHJ5IHRvIHNjcm9sbCB0byB0aGUgaGFzaFxuICAgICAgICBpZiAobG9jYXRpb24uaGFzaCkge1xuICAgICAgICAgIGxldCBlbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGRlY29kZVVSSUNvbXBvbmVudChsb2NhdGlvbi5oYXNoLnNsaWNlKDEpKSk7XG4gICAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgICBlbC5zY3JvbGxJbnRvVmlldygpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERvbid0IHJlc2V0IGlmIHRoaXMgbmF2aWdhdGlvbiBvcHRlZCBvdXRcbiAgICAgICAgaWYgKHByZXZlbnRTY3JvbGxSZXNldCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG90aGVyd2lzZSBnbyB0byB0aGUgdG9wIG9uIG5ldyBsb2NhdGlvbnNcbiAgICAgICAgd2luZG93LnNjcm9sbFRvKDAsIDApO1xuICAgICAgfSwgW2xvY2F0aW9uLCByZXN0b3JlU2Nyb2xsUG9zaXRpb24sIHByZXZlbnRTY3JvbGxSZXNldF0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXR1cCBhIGNhbGxiYWNrIHRvIGJlIGZpcmVkIG9uIHRoZSB3aW5kb3cncyBgYmVmb3JldW5sb2FkYCBldmVudC4gVGhpcyBpc1xuICAgKiB1c2VmdWwgZm9yIHNhdmluZyBzb21lIGRhdGEgdG8gYHdpbmRvdy5sb2NhbFN0b3JhZ2VgIGp1c3QgYmVmb3JlIHRoZSBwYWdlXG4gICAqIHJlZnJlc2hlcy5cbiAgICpcbiAgICogTm90ZTogVGhlIGBjYWxsYmFja2AgYXJndW1lbnQgc2hvdWxkIGJlIGEgZnVuY3Rpb24gY3JlYXRlZCB3aXRoXG4gICAqIGBSZWFjdC51c2VDYWxsYmFjaygpYC5cbiAgICovXG4gIGZ1bmN0aW9uIHVzZUJlZm9yZVVubG9hZChjYWxsYmFjaywgb3B0aW9ucykge1xuICAgIGxldCB7XG4gICAgICBjYXB0dXJlXG4gICAgfSA9IG9wdGlvbnMgfHwge307XG4gICAgUmVhY3RfX25hbWVzcGFjZS51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgbGV0IG9wdHMgPSBjYXB0dXJlICE9IG51bGwgPyB7XG4gICAgICAgIGNhcHR1cmVcbiAgICAgIH0gOiB1bmRlZmluZWQ7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImJlZm9yZXVubG9hZFwiLCBjYWxsYmFjaywgb3B0cyk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImJlZm9yZXVubG9hZFwiLCBjYWxsYmFjaywgb3B0cyk7XG4gICAgICB9O1xuICAgIH0sIFtjYWxsYmFjaywgY2FwdHVyZV0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHVwIGEgY2FsbGJhY2sgdG8gYmUgZmlyZWQgb24gdGhlIHdpbmRvdydzIGBwYWdlaGlkZWAgZXZlbnQuIFRoaXMgaXNcbiAgICogdXNlZnVsIGZvciBzYXZpbmcgc29tZSBkYXRhIHRvIGB3aW5kb3cubG9jYWxTdG9yYWdlYCBqdXN0IGJlZm9yZSB0aGUgcGFnZVxuICAgKiByZWZyZXNoZXMuICBUaGlzIGV2ZW50IGlzIGJldHRlciBzdXBwb3J0ZWQgdGhhbiBiZWZvcmV1bmxvYWQgYWNyb3NzIGJyb3dzZXJzLlxuICAgKlxuICAgKiBOb3RlOiBUaGUgYGNhbGxiYWNrYCBhcmd1bWVudCBzaG91bGQgYmUgYSBmdW5jdGlvbiBjcmVhdGVkIHdpdGhcbiAgICogYFJlYWN0LnVzZUNhbGxiYWNrKClgLlxuICAgKi9cbiAgZnVuY3Rpb24gdXNlUGFnZUhpZGUoY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICBsZXQge1xuICAgICAgY2FwdHVyZVxuICAgIH0gPSBvcHRpb25zIHx8IHt9O1xuICAgIFJlYWN0X19uYW1lc3BhY2UudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgIGxldCBvcHRzID0gY2FwdHVyZSAhPSBudWxsID8ge1xuICAgICAgICBjYXB0dXJlXG4gICAgICB9IDogdW5kZWZpbmVkO1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwYWdlaGlkZVwiLCBjYWxsYmFjaywgb3B0cyk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBhZ2VoaWRlXCIsIGNhbGxiYWNrLCBvcHRzKTtcbiAgICAgIH07XG4gICAgfSwgW2NhbGxiYWNrLCBjYXB0dXJlXSk7XG4gIH1cblxuICAvKipcbiAgICogV3JhcHBlciBhcm91bmQgdXNlQmxvY2tlciB0byBzaG93IGEgd2luZG93LmNvbmZpcm0gcHJvbXB0IHRvIHVzZXJzIGluc3RlYWRcbiAgICogb2YgYnVpbGRpbmcgYSBjdXN0b20gVUkgd2l0aCB1c2VCbG9ja2VyLlxuICAgKlxuICAgKiBXYXJuaW5nOiBUaGlzIGhhcyAqYSBsb3Qgb2Ygcm91Z2ggZWRnZXMqIGFuZCBiZWhhdmVzIHZlcnkgZGlmZmVyZW50bHkgKGFuZFxuICAgKiB2ZXJ5IGluY29ycmVjdGx5IGluIHNvbWUgY2FzZXMpIGFjcm9zcyBicm93c2VycyBpZiB1c2VyIGNsaWNrIGFkZGl0aW9uXG4gICAqIGJhY2svZm9yd2FyZCBuYXZpZ2F0aW9ucyB3aGlsZSB0aGUgY29uZmlybSBpcyBvcGVuLiAgVXNlIGF0IHlvdXIgb3duIHJpc2suXG4gICAqL1xuICBmdW5jdGlvbiB1c2VQcm9tcHQoX3JlZjEyKSB7XG4gICAgbGV0IHtcbiAgICAgIHdoZW4sXG4gICAgICBtZXNzYWdlXG4gICAgfSA9IF9yZWYxMjtcbiAgICBsZXQgYmxvY2tlciA9IHJlYWN0Um91dGVyLnVzZUJsb2NrZXIod2hlbik7XG4gICAgUmVhY3RfX25hbWVzcGFjZS51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgaWYgKGJsb2NrZXIuc3RhdGUgPT09IFwiYmxvY2tlZFwiKSB7XG4gICAgICAgIGxldCBwcm9jZWVkID0gd2luZG93LmNvbmZpcm0obWVzc2FnZSk7XG4gICAgICAgIGlmIChwcm9jZWVkKSB7XG4gICAgICAgICAgLy8gVGhpcyB0aW1lb3V0IGlzIG5lZWRlZCB0byBhdm9pZCBhIHdlaXJkIFwicmFjZVwiIG9uIFBPUCBuYXZpZ2F0aW9uc1xuICAgICAgICAgIC8vIGJldHdlZW4gdGhlIGB3aW5kb3cuaGlzdG9yeWAgcmV2ZXJ0IG5hdmlnYXRpb24gYW5kIHRoZSByZXN1bHQgb2ZcbiAgICAgICAgICAvLyBgd2luZG93LmNvbmZpcm1gXG4gICAgICAgICAgc2V0VGltZW91dChibG9ja2VyLnByb2NlZWQsIDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJsb2NrZXIucmVzZXQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIFtibG9ja2VyLCBtZXNzYWdlXSk7XG4gICAgUmVhY3RfX25hbWVzcGFjZS51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgaWYgKGJsb2NrZXIuc3RhdGUgPT09IFwiYmxvY2tlZFwiICYmICF3aGVuKSB7XG4gICAgICAgIGJsb2NrZXIucmVzZXQoKTtcbiAgICAgIH1cbiAgICB9LCBbYmxvY2tlciwgd2hlbl0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhIGJvb2xlYW4gaW5kaWNhdGluZyBpZiB0aGVyZSBpcyBhbiBhY3RpdmUgdmlldyB0cmFuc2l0aW9uIHRvIHRoZVxuICAgKiBnaXZlbiBocmVmLiAgWW91IGNhbiB1c2UgdGhpcyB2YWx1ZSB0byByZW5kZXIgQ1NTIGNsYXNzZXMgb3Igdmlld1RyYW5zaXRpb25OYW1lXG4gICAqIHN0eWxlcyBvbnRvIHlvdXIgZWxlbWVudHNcbiAgICpcbiAgICogQHBhcmFtIGhyZWYgVGhlIGRlc3RpbmF0aW9uIGhyZWZcbiAgICogQHBhcmFtIFtvcHRzLnJlbGF0aXZlXSBSZWxhdGl2ZSByb3V0aW5nIHR5cGUgKFwicm91dGVcIiB8IFwicGF0aFwiKVxuICAgKi9cbiAgZnVuY3Rpb24gdXNlVmlld1RyYW5zaXRpb25TdGF0ZSh0bywgb3B0cykge1xuICAgIGlmIChvcHRzID09PSB2b2lkIDApIHtcbiAgICAgIG9wdHMgPSB7fTtcbiAgICB9XG4gICAgbGV0IHZ0Q29udGV4dCA9IFJlYWN0X19uYW1lc3BhY2UudXNlQ29udGV4dChWaWV3VHJhbnNpdGlvbkNvbnRleHQpO1xuICAgICEodnRDb250ZXh0ICE9IG51bGwpID8gcm91dGVyLlVOU0FGRV9pbnZhcmlhbnQoZmFsc2UsIFwiYHVuc3RhYmxlX3VzZVZpZXdUcmFuc2l0aW9uU3RhdGVgIG11c3QgYmUgdXNlZCB3aXRoaW4gYHJlYWN0LXJvdXRlci1kb21gJ3MgYFJvdXRlclByb3ZpZGVyYC4gIFwiICsgXCJEaWQgeW91IGFjY2lkZW50YWxseSBpbXBvcnQgYFJvdXRlclByb3ZpZGVyYCBmcm9tIGByZWFjdC1yb3V0ZXJgP1wiKSAgOiB2b2lkIDA7XG4gICAgbGV0IHtcbiAgICAgIGJhc2VuYW1lXG4gICAgfSA9IHVzZURhdGFSb3V0ZXJDb250ZXh0KERhdGFSb3V0ZXJIb29rLnVzZVZpZXdUcmFuc2l0aW9uU3RhdGUpO1xuICAgIGxldCBwYXRoID0gcmVhY3RSb3V0ZXIudXNlUmVzb2x2ZWRQYXRoKHRvLCB7XG4gICAgICByZWxhdGl2ZTogb3B0cy5yZWxhdGl2ZVxuICAgIH0pO1xuICAgIGlmICghdnRDb250ZXh0LmlzVHJhbnNpdGlvbmluZykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBsZXQgY3VycmVudFBhdGggPSByb3V0ZXIuc3RyaXBCYXNlbmFtZSh2dENvbnRleHQuY3VycmVudExvY2F0aW9uLnBhdGhuYW1lLCBiYXNlbmFtZSkgfHwgdnRDb250ZXh0LmN1cnJlbnRMb2NhdGlvbi5wYXRobmFtZTtcbiAgICBsZXQgbmV4dFBhdGggPSByb3V0ZXIuc3RyaXBCYXNlbmFtZSh2dENvbnRleHQubmV4dExvY2F0aW9uLnBhdGhuYW1lLCBiYXNlbmFtZSkgfHwgdnRDb250ZXh0Lm5leHRMb2NhdGlvbi5wYXRobmFtZTtcblxuICAgIC8vIFRyYW5zaXRpb24gaXMgYWN0aXZlIGlmIHdlJ3JlIGdvaW5nIHRvIG9yIGNvbWluZyBmcm9tIHRoZSBpbmRpY2F0ZWRcbiAgICAvLyBkZXN0aW5hdGlvbi4gIFRoaXMgZW5zdXJlcyB0aGF0IG90aGVyIFBVU0ggbmF2aWdhdGlvbnMgdGhhdCByZXZlcnNlXG4gICAgLy8gYW4gaW5kaWNhdGVkIHRyYW5zaXRpb24gYXBwbHkuICBJLmUuLCBvbiB0aGUgbGlzdCB2aWV3IHlvdSBoYXZlOlxuICAgIC8vXG4gICAgLy8gICA8TmF2TGluayB0bz1cIi9kZXRhaWxzLzFcIiB1bnN0YWJsZV92aWV3VHJhbnNpdGlvbj5cbiAgICAvL1xuICAgIC8vIElmIHlvdSBjbGljayB0aGUgYnJlYWRjcnVtYiBiYWNrIHRvIHRoZSBsaXN0IHZpZXc6XG4gICAgLy9cbiAgICAvLyAgIDxOYXZMaW5rIHRvPVwiL2xpc3RcIiB1bnN0YWJsZV92aWV3VHJhbnNpdGlvbj5cbiAgICAvL1xuICAgIC8vIFdlIHNob3VsZCBhcHBseSB0aGUgdHJhbnNpdGlvbiBiZWNhdXNlIGl0J3MgaW5kaWNhdGVkIGFzIGFjdGl2ZSBnb2luZ1xuICAgIC8vIGZyb20gL2xpc3QgLT4gL2RldGFpbHMvMSBhbmQgdGhlcmVmb3JlIHNob3VsZCBiZSBhY3RpdmUgb24gdGhlIHJldmVyc2VcbiAgICAvLyAoZXZlbiB0aG91Z2ggdGhpcyBpc24ndCBzdHJpY3RseSBhIFBPUCByZXZlcnNlKVxuICAgIHJldHVybiByb3V0ZXIubWF0Y2hQYXRoKHBhdGgucGF0aG5hbWUsIG5leHRQYXRoKSAhPSBudWxsIHx8IHJvdXRlci5tYXRjaFBhdGgocGF0aC5wYXRobmFtZSwgY3VycmVudFBhdGgpICE9IG51bGw7XG4gIH1cblxuICAvLyNlbmRyZWdpb25cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ0Fib3J0ZWREZWZlcnJlZEVycm9yJywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByZWFjdFJvdXRlci5BYm9ydGVkRGVmZXJyZWRFcnJvcjsgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdBd2FpdCcsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVhY3RSb3V0ZXIuQXdhaXQ7IH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnTWVtb3J5Um91dGVyJywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByZWFjdFJvdXRlci5NZW1vcnlSb3V0ZXI7IH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnTmF2aWdhdGUnLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlYWN0Um91dGVyLk5hdmlnYXRlOyB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ05hdmlnYXRpb25UeXBlJywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByZWFjdFJvdXRlci5OYXZpZ2F0aW9uVHlwZTsgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdPdXRsZXQnLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlYWN0Um91dGVyLk91dGxldDsgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdSb3V0ZScsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVhY3RSb3V0ZXIuUm91dGU7IH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnUm91dGVyJywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByZWFjdFJvdXRlci5Sb3V0ZXI7IH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnUm91dGVzJywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByZWFjdFJvdXRlci5Sb3V0ZXM7IH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnVU5TQUZFX0RhdGFSb3V0ZXJDb250ZXh0Jywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByZWFjdFJvdXRlci5VTlNBRkVfRGF0YVJvdXRlckNvbnRleHQ7IH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnVU5TQUZFX0RhdGFSb3V0ZXJTdGF0ZUNvbnRleHQnLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlYWN0Um91dGVyLlVOU0FGRV9EYXRhUm91dGVyU3RhdGVDb250ZXh0OyB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ1VOU0FGRV9Mb2NhdGlvbkNvbnRleHQnLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlYWN0Um91dGVyLlVOU0FGRV9Mb2NhdGlvbkNvbnRleHQ7IH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnVU5TQUZFX05hdmlnYXRpb25Db250ZXh0Jywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByZWFjdFJvdXRlci5VTlNBRkVfTmF2aWdhdGlvbkNvbnRleHQ7IH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnVU5TQUZFX1JvdXRlQ29udGV4dCcsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVhY3RSb3V0ZXIuVU5TQUZFX1JvdXRlQ29udGV4dDsgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdVTlNBRkVfdXNlUm91dGVJZCcsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVhY3RSb3V0ZXIuVU5TQUZFX3VzZVJvdXRlSWQ7IH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnY3JlYXRlTWVtb3J5Um91dGVyJywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByZWFjdFJvdXRlci5jcmVhdGVNZW1vcnlSb3V0ZXI7IH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnY3JlYXRlUGF0aCcsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVhY3RSb3V0ZXIuY3JlYXRlUGF0aDsgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdjcmVhdGVSb3V0ZXNGcm9tQ2hpbGRyZW4nLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlYWN0Um91dGVyLmNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbjsgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdjcmVhdGVSb3V0ZXNGcm9tRWxlbWVudHMnLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlYWN0Um91dGVyLmNyZWF0ZVJvdXRlc0Zyb21FbGVtZW50czsgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdkZWZlcicsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVhY3RSb3V0ZXIuZGVmZXI7IH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnZ2VuZXJhdGVQYXRoJywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByZWFjdFJvdXRlci5nZW5lcmF0ZVBhdGg7IH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnaXNSb3V0ZUVycm9yUmVzcG9uc2UnLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlYWN0Um91dGVyLmlzUm91dGVFcnJvclJlc3BvbnNlOyB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ2pzb24nLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlYWN0Um91dGVyLmpzb247IH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnbWF0Y2hQYXRoJywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByZWFjdFJvdXRlci5tYXRjaFBhdGg7IH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnbWF0Y2hSb3V0ZXMnLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlYWN0Um91dGVyLm1hdGNoUm91dGVzOyB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ3BhcnNlUGF0aCcsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVhY3RSb3V0ZXIucGFyc2VQYXRoOyB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ3JlZGlyZWN0Jywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByZWFjdFJvdXRlci5yZWRpcmVjdDsgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdyZWRpcmVjdERvY3VtZW50Jywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByZWFjdFJvdXRlci5yZWRpcmVjdERvY3VtZW50OyB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ3JlbmRlck1hdGNoZXMnLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlYWN0Um91dGVyLnJlbmRlck1hdGNoZXM7IH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAncmVzb2x2ZVBhdGgnLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlYWN0Um91dGVyLnJlc29sdmVQYXRoOyB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ3VzZUFjdGlvbkRhdGEnLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlYWN0Um91dGVyLnVzZUFjdGlvbkRhdGE7IH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAndXNlQXN5bmNFcnJvcicsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVhY3RSb3V0ZXIudXNlQXN5bmNFcnJvcjsgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICd1c2VBc3luY1ZhbHVlJywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByZWFjdFJvdXRlci51c2VBc3luY1ZhbHVlOyB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ3VzZUJsb2NrZXInLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlYWN0Um91dGVyLnVzZUJsb2NrZXI7IH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAndXNlSHJlZicsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVhY3RSb3V0ZXIudXNlSHJlZjsgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICd1c2VJblJvdXRlckNvbnRleHQnLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlYWN0Um91dGVyLnVzZUluUm91dGVyQ29udGV4dDsgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICd1c2VMb2FkZXJEYXRhJywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByZWFjdFJvdXRlci51c2VMb2FkZXJEYXRhOyB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ3VzZUxvY2F0aW9uJywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByZWFjdFJvdXRlci51c2VMb2NhdGlvbjsgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICd1c2VNYXRjaCcsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVhY3RSb3V0ZXIudXNlTWF0Y2g7IH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAndXNlTWF0Y2hlcycsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVhY3RSb3V0ZXIudXNlTWF0Y2hlczsgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICd1c2VOYXZpZ2F0ZScsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVhY3RSb3V0ZXIudXNlTmF2aWdhdGU7IH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAndXNlTmF2aWdhdGlvbicsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVhY3RSb3V0ZXIudXNlTmF2aWdhdGlvbjsgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICd1c2VOYXZpZ2F0aW9uVHlwZScsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVhY3RSb3V0ZXIudXNlTmF2aWdhdGlvblR5cGU7IH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAndXNlT3V0bGV0Jywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByZWFjdFJvdXRlci51c2VPdXRsZXQ7IH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAndXNlT3V0bGV0Q29udGV4dCcsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVhY3RSb3V0ZXIudXNlT3V0bGV0Q29udGV4dDsgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICd1c2VQYXJhbXMnLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlYWN0Um91dGVyLnVzZVBhcmFtczsgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICd1c2VSZXNvbHZlZFBhdGgnLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlYWN0Um91dGVyLnVzZVJlc29sdmVkUGF0aDsgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICd1c2VSZXZhbGlkYXRvcicsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVhY3RSb3V0ZXIudXNlUmV2YWxpZGF0b3I7IH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAndXNlUm91dGVFcnJvcicsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVhY3RSb3V0ZXIudXNlUm91dGVFcnJvcjsgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICd1c2VSb3V0ZUxvYWRlckRhdGEnLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlYWN0Um91dGVyLnVzZVJvdXRlTG9hZGVyRGF0YTsgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICd1c2VSb3V0ZXMnLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlYWN0Um91dGVyLnVzZVJvdXRlczsgfVxuICB9KTtcbiAgZXhwb3J0cy5Ccm93c2VyUm91dGVyID0gQnJvd3NlclJvdXRlcjtcbiAgZXhwb3J0cy5Gb3JtID0gRm9ybTtcbiAgZXhwb3J0cy5IYXNoUm91dGVyID0gSGFzaFJvdXRlcjtcbiAgZXhwb3J0cy5MaW5rID0gTGluaztcbiAgZXhwb3J0cy5OYXZMaW5rID0gTmF2TGluaztcbiAgZXhwb3J0cy5Sb3V0ZXJQcm92aWRlciA9IFJvdXRlclByb3ZpZGVyO1xuICBleHBvcnRzLlNjcm9sbFJlc3RvcmF0aW9uID0gU2Nyb2xsUmVzdG9yYXRpb247XG4gIGV4cG9ydHMuVU5TQUZFX0ZldGNoZXJzQ29udGV4dCA9IEZldGNoZXJzQ29udGV4dDtcbiAgZXhwb3J0cy5VTlNBRkVfVmlld1RyYW5zaXRpb25Db250ZXh0ID0gVmlld1RyYW5zaXRpb25Db250ZXh0O1xuICBleHBvcnRzLlVOU0FGRV91c2VTY3JvbGxSZXN0b3JhdGlvbiA9IHVzZVNjcm9sbFJlc3RvcmF0aW9uO1xuICBleHBvcnRzLmNyZWF0ZUJyb3dzZXJSb3V0ZXIgPSBjcmVhdGVCcm93c2VyUm91dGVyO1xuICBleHBvcnRzLmNyZWF0ZUhhc2hSb3V0ZXIgPSBjcmVhdGVIYXNoUm91dGVyO1xuICBleHBvcnRzLmNyZWF0ZVNlYXJjaFBhcmFtcyA9IGNyZWF0ZVNlYXJjaFBhcmFtcztcbiAgZXhwb3J0cy51bnN0YWJsZV9IaXN0b3J5Um91dGVyID0gSGlzdG9yeVJvdXRlcjtcbiAgZXhwb3J0cy51bnN0YWJsZV91c2VQcm9tcHQgPSB1c2VQcm9tcHQ7XG4gIGV4cG9ydHMudW5zdGFibGVfdXNlVmlld1RyYW5zaXRpb25TdGF0ZSA9IHVzZVZpZXdUcmFuc2l0aW9uU3RhdGU7XG4gIGV4cG9ydHMudXNlQmVmb3JlVW5sb2FkID0gdXNlQmVmb3JlVW5sb2FkO1xuICBleHBvcnRzLnVzZUZldGNoZXIgPSB1c2VGZXRjaGVyO1xuICBleHBvcnRzLnVzZUZldGNoZXJzID0gdXNlRmV0Y2hlcnM7XG4gIGV4cG9ydHMudXNlRm9ybUFjdGlvbiA9IHVzZUZvcm1BY3Rpb247XG4gIGV4cG9ydHMudXNlTGlua0NsaWNrSGFuZGxlciA9IHVzZUxpbmtDbGlja0hhbmRsZXI7XG4gIGV4cG9ydHMudXNlU2VhcmNoUGFyYW1zID0gdXNlU2VhcmNoUGFyYW1zO1xuICBleHBvcnRzLnVzZVN1Ym1pdCA9IHVzZVN1Ym1pdDtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWFjdC1yb3V0ZXItZG9tLmRldmVsb3BtZW50LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-router-dom/dist/umd/react-router-dom.development.js\n");

/***/ })

};
;