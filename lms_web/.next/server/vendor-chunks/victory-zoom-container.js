"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/victory-zoom-container";
exports.ids = ["vendor-chunks/victory-zoom-container"];
exports.modules = {

/***/ "(ssr)/./node_modules/victory-zoom-container/lib/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/victory-zoom-container/lib/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nvar _victoryZoomContainer = __webpack_require__(/*! ./victory-zoom-container */ \"(ssr)/./node_modules/victory-zoom-container/lib/victory-zoom-container.js\");\nObject.keys(_victoryZoomContainer).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _victoryZoomContainer[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _victoryZoomContainer[key];\n    }\n  });\n});\nvar _zoomHelpers = __webpack_require__(/*! ./zoom-helpers */ \"(ssr)/./node_modules/victory-zoom-container/lib/zoom-helpers.js\");\nObject.keys(_zoomHelpers).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _zoomHelpers[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _zoomHelpers[key];\n    }\n  });\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdmljdG9yeS16b29tLWNvbnRhaW5lci9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsNEJBQTRCLG1CQUFPLENBQUMsMkdBQTBCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNELG1CQUFtQixtQkFBTyxDQUFDLHVGQUFnQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90ZW1wLy4vbm9kZV9tb2R1bGVzL3ZpY3Rvcnktem9vbS1jb250YWluZXIvbGliL2luZGV4LmpzPzE0MmEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG52YXIgX3ZpY3Rvcnlab29tQ29udGFpbmVyID0gcmVxdWlyZShcIi4vdmljdG9yeS16b29tLWNvbnRhaW5lclwiKTtcbk9iamVjdC5rZXlzKF92aWN0b3J5Wm9vbUNvbnRhaW5lcikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX3ZpY3Rvcnlab29tQ29udGFpbmVyW2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3ZpY3Rvcnlab29tQ29udGFpbmVyW2tleV07XG4gICAgfVxuICB9KTtcbn0pO1xudmFyIF96b29tSGVscGVycyA9IHJlcXVpcmUoXCIuL3pvb20taGVscGVyc1wiKTtcbk9iamVjdC5rZXlzKF96b29tSGVscGVycykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX3pvb21IZWxwZXJzW2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3pvb21IZWxwZXJzW2tleV07XG4gICAgfVxuICB9KTtcbn0pOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/victory-zoom-container/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/victory-zoom-container/lib/victory-zoom-container.js":
/*!***************************************************************************!*\
  !*** ./node_modules/victory-zoom-container/lib/victory-zoom-container.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.VictoryZoomContainer = void 0;\nexports.zoomContainerMixin = zoomContainerMixin;\nvar _defaults2 = _interopRequireDefault(__webpack_require__(/*! lodash/defaults */ \"(ssr)/./node_modules/lodash/defaults.js\"));\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\nvar _zoomHelpers = __webpack_require__(/*! ./zoom-helpers */ \"(ssr)/./node_modules/victory-zoom-container/lib/zoom-helpers.js\");\nvar _victoryCore = __webpack_require__(/*! victory-core */ \"(ssr)/./node_modules/victory-core/lib/index.js\");\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nconst DEFAULT_DOWNSAMPLE = 150;\nfunction zoomContainerMixin(Base) {\n  // @ts-expect-error \"TS2545: A mixin class must have a constructor with a single rest parameter of type 'any[]'.\"\n  return class VictoryZoomContainer extends Base {\n    static displayName = \"VictoryZoomContainer\";\n    static defaultProps = {\n      ..._victoryCore.VictoryContainer.defaultProps,\n      clipContainerComponent: /*#__PURE__*/_react.default.createElement(_victoryCore.VictoryClipContainer, null),\n      allowPan: true,\n      allowZoom: true,\n      zoomActive: false\n    };\n    static defaultEvents(props) {\n      return [{\n        target: \"parent\",\n        eventHandlers: {\n          onMouseDown: (evt, targetProps) => {\n            return props.disable ? {} : _zoomHelpers.ZoomHelpers.onMouseDown(evt, targetProps);\n          },\n          onTouchStart: (evt, targetProps) => {\n            return props.disable ? {} : _zoomHelpers.ZoomHelpers.onMouseDown(evt, targetProps);\n          },\n          onMouseUp: (evt, targetProps) => {\n            return props.disable ? {} : _zoomHelpers.ZoomHelpers.onMouseUp(evt, targetProps);\n          },\n          onTouchEnd: (evt, targetProps) => {\n            return props.disable ? {} : _zoomHelpers.ZoomHelpers.onMouseUp(evt, targetProps);\n          },\n          onMouseLeave: (evt, targetProps) => {\n            return props.disable ? {} : _zoomHelpers.ZoomHelpers.onMouseLeave(evt, targetProps);\n          },\n          onTouchCancel: (evt, targetProps) => {\n            return props.disable ? {} : _zoomHelpers.ZoomHelpers.onMouseLeave(evt, targetProps);\n          },\n          // eslint-disable-next-line max-params\n          onMouseMove: (evt, targetProps, eventKey, ctx) => {\n            if (props.disable) {\n              return {};\n            }\n            return _zoomHelpers.ZoomHelpers.onMouseMove(evt, targetProps, eventKey, ctx);\n          },\n          // eslint-disable-next-line max-params\n          onTouchMove: (evt, targetProps, eventKey, ctx) => {\n            if (props.disable) {\n              return {};\n            }\n            evt.preventDefault();\n            return _zoomHelpers.ZoomHelpers.onMouseMove(evt, targetProps, eventKey, ctx);\n          },\n          ...(props.disable || !props.allowZoom ? {} : {\n            onWheel: _zoomHelpers.ZoomHelpers.onWheel\n          })\n        }\n      }];\n    }\n    clipDataComponents(children, props) {\n      const {\n        scale,\n        clipContainerComponent,\n        polar,\n        origin,\n        horizontal\n      } = props;\n      const rangeX = horizontal ? scale.y.range() : scale.x.range();\n      const rangeY = horizontal ? scale.x.range() : scale.y.range();\n      const plottableWidth = Math.abs(rangeX[0] - rangeX[1]);\n      const plottableHeight = Math.abs(rangeY[0] - rangeY[1]);\n      const radius = Math.max(...rangeY);\n      const groupComponent = /*#__PURE__*/_react.default.cloneElement(clipContainerComponent, {\n        clipWidth: plottableWidth,\n        clipHeight: plottableHeight,\n        translateX: Math.min(...rangeX),\n        translateY: Math.min(...rangeY),\n        polar,\n        origin: polar ? origin : undefined,\n        radius: polar ? radius : undefined,\n        ...clipContainerComponent.props\n      });\n      return _react.default.Children.toArray(children).map(child => {\n        if (!_victoryCore.Data.isDataComponent(child)) {\n          return child;\n        }\n        return /*#__PURE__*/_react.default.cloneElement(child, {\n          groupComponent\n        });\n      });\n    }\n    modifyPolarDomain(domain, originalDomain) {\n      // Only zoom the radius of polar charts. Zooming angles is very confusing\n      return {\n        x: originalDomain.x,\n        y: [0, domain.y[1]]\n      };\n    }\n    downsampleZoomData(props, child, domain) {\n      const {\n        downsample\n      } = props;\n      const getData = childProps => {\n        const {\n          data,\n          x,\n          y\n        } = childProps;\n        const defaultGetData = child.type && _victoryCore.Helpers.isFunction(child.type.getData) ? child.type.getData : () => undefined;\n        // skip costly data formatting if x and y accessors are not present\n        return Array.isArray(data) && !x && !y ? data : defaultGetData(childProps);\n      };\n      const data = getData(child.props);\n\n      // return undefined if downsample is not run, then default() will replace with child.props.data\n      if (!downsample || !domain || !data) {\n        return undefined;\n      }\n      const maxPoints = downsample === true ? DEFAULT_DOWNSAMPLE : downsample;\n      const dimension = props.zoomDimension || \"x\";\n\n      // important: assumes data is ordered by dimension\n      // get the start and end of the data that is in the current visible domain\n      let startIndex = data.findIndex(d => d[dimension] >= domain[dimension][0]);\n      let endIndex = data.findIndex(d => d[dimension] > domain[dimension][1]);\n      // pick one more point (if available) at each end so that VictoryLine, VictoryArea connect\n      if (startIndex !== 0) {\n        startIndex -= 1;\n      }\n      if (endIndex !== -1) {\n        endIndex += 1;\n      }\n      const visibleData = data.slice(startIndex, endIndex);\n      return _victoryCore.Data.downsample(visibleData, maxPoints, startIndex);\n    }\n    modifyChildren(props) {\n      const childComponents = _react.default.Children.toArray(props.children);\n      return childComponents.map(child => {\n        const role = child.type && child.type.role;\n        const isDataComponent = _victoryCore.Data.isDataComponent(child);\n        const {\n          currentDomain,\n          zoomActive,\n          allowZoom\n        } = props;\n        const originalDomain = (0, _defaults2.default)({}, props.originalDomain, props.domain);\n        const zoomDomain = (0, _defaults2.default)({}, props.zoomDomain, props.domain);\n        const cachedZoomDomain = (0, _defaults2.default)({}, props.cachedZoomDomain, props.domain);\n        let domain;\n        if (!_zoomHelpers.ZoomHelpers.checkDomainEquality(zoomDomain, cachedZoomDomain)) {\n          // if zoomDomain has been changed, use it\n          domain = zoomDomain;\n        } else if (allowZoom && !zoomActive) {\n          // if user has zoomed all the way out, use the child domain\n          domain = child.props.domain;\n        } else {\n          // default: use currentDomain, set by the event handlers\n          domain = (0, _defaults2.default)({}, currentDomain, originalDomain);\n        }\n        let newDomain = props.polar ? this.modifyPolarDomain(domain, originalDomain) : domain;\n        if (newDomain && props.zoomDimension) {\n          // if zooming is restricted to a dimension, don't squash changes to zoomDomain in other dim\n          newDomain = {\n            ...zoomDomain,\n            [props.zoomDimension]: newDomain[props.zoomDimension]\n          };\n        }\n        // don't downsample stacked data\n        const newProps = isDataComponent && role !== \"stack\" ? {\n          domain: newDomain,\n          data: this.downsampleZoomData(props, child, newDomain)\n        } : {\n          domain: newDomain\n        };\n        return /*#__PURE__*/_react.default.cloneElement(child, (0, _defaults2.default)(newProps, child.props));\n      });\n    }\n\n    // Overrides method in VictoryContainer\n    getChildren(props) {\n      const children = this.modifyChildren(props);\n      return this.clipDataComponents(children, props);\n    }\n  };\n}\nconst VictoryZoomContainer = exports.VictoryZoomContainer = zoomContainerMixin(_victoryCore.VictoryContainer);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdmljdG9yeS16b29tLWNvbnRhaW5lci9saWIvdmljdG9yeS16b29tLWNvbnRhaW5lci5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRiw0QkFBNEI7QUFDNUIsMEJBQTBCO0FBQzFCLHdDQUF3QyxtQkFBTyxDQUFDLGdFQUFpQjtBQUNqRSxvQ0FBb0MsbUJBQU8sQ0FBQyx3R0FBTztBQUNuRCxtQkFBbUIsbUJBQU8sQ0FBQyx1RkFBZ0I7QUFDM0MsbUJBQW1CLG1CQUFPLENBQUMsb0VBQWM7QUFDekMsdUNBQXVDLHVDQUF1QztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDLFdBQVc7QUFDWDtBQUNBLHNDQUFzQztBQUN0QyxXQUFXO0FBQ1g7QUFDQSxzQ0FBc0M7QUFDdEMsV0FBVztBQUNYO0FBQ0Esc0NBQXNDO0FBQ3RDLFdBQVc7QUFDWDtBQUNBLHNDQUFzQztBQUN0QyxXQUFXO0FBQ1g7QUFDQSxzQ0FBc0M7QUFDdEMsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxxREFBcUQ7QUFDckQ7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YseURBQXlEO0FBQ3pELHFEQUFxRDtBQUNyRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNEJBQTRCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGVtcC8uL25vZGVfbW9kdWxlcy92aWN0b3J5LXpvb20tY29udGFpbmVyL2xpYi92aWN0b3J5LXpvb20tY29udGFpbmVyLmpzPzNhYTMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLlZpY3Rvcnlab29tQ29udGFpbmVyID0gdm9pZCAwO1xuZXhwb3J0cy56b29tQ29udGFpbmVyTWl4aW4gPSB6b29tQ29udGFpbmVyTWl4aW47XG52YXIgX2RlZmF1bHRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImxvZGFzaC9kZWZhdWx0c1wiKSk7XG52YXIgX3JlYWN0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIF96b29tSGVscGVycyA9IHJlcXVpcmUoXCIuL3pvb20taGVscGVyc1wiKTtcbnZhciBfdmljdG9yeUNvcmUgPSByZXF1aXJlKFwidmljdG9yeS1jb3JlXCIpO1xuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cbmNvbnN0IERFRkFVTFRfRE9XTlNBTVBMRSA9IDE1MDtcbmZ1bmN0aW9uIHpvb21Db250YWluZXJNaXhpbihCYXNlKSB7XG4gIC8vIEB0cy1leHBlY3QtZXJyb3IgXCJUUzI1NDU6IEEgbWl4aW4gY2xhc3MgbXVzdCBoYXZlIGEgY29uc3RydWN0b3Igd2l0aCBhIHNpbmdsZSByZXN0IHBhcmFtZXRlciBvZiB0eXBlICdhbnlbXScuXCJcbiAgcmV0dXJuIGNsYXNzIFZpY3Rvcnlab29tQ29udGFpbmVyIGV4dGVuZHMgQmFzZSB7XG4gICAgc3RhdGljIGRpc3BsYXlOYW1lID0gXCJWaWN0b3J5Wm9vbUNvbnRhaW5lclwiO1xuICAgIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgICAuLi5fdmljdG9yeUNvcmUuVmljdG9yeUNvbnRhaW5lci5kZWZhdWx0UHJvcHMsXG4gICAgICBjbGlwQ29udGFpbmVyQ29tcG9uZW50OiAvKiNfX1BVUkVfXyovX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfdmljdG9yeUNvcmUuVmljdG9yeUNsaXBDb250YWluZXIsIG51bGwpLFxuICAgICAgYWxsb3dQYW46IHRydWUsXG4gICAgICBhbGxvd1pvb206IHRydWUsXG4gICAgICB6b29tQWN0aXZlOiBmYWxzZVxuICAgIH07XG4gICAgc3RhdGljIGRlZmF1bHRFdmVudHMocHJvcHMpIHtcbiAgICAgIHJldHVybiBbe1xuICAgICAgICB0YXJnZXQ6IFwicGFyZW50XCIsXG4gICAgICAgIGV2ZW50SGFuZGxlcnM6IHtcbiAgICAgICAgICBvbk1vdXNlRG93bjogKGV2dCwgdGFyZ2V0UHJvcHMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBwcm9wcy5kaXNhYmxlID8ge30gOiBfem9vbUhlbHBlcnMuWm9vbUhlbHBlcnMub25Nb3VzZURvd24oZXZ0LCB0YXJnZXRQcm9wcyk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvblRvdWNoU3RhcnQ6IChldnQsIHRhcmdldFByb3BzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gcHJvcHMuZGlzYWJsZSA/IHt9IDogX3pvb21IZWxwZXJzLlpvb21IZWxwZXJzLm9uTW91c2VEb3duKGV2dCwgdGFyZ2V0UHJvcHMpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgb25Nb3VzZVVwOiAoZXZ0LCB0YXJnZXRQcm9wcykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHByb3BzLmRpc2FibGUgPyB7fSA6IF96b29tSGVscGVycy5ab29tSGVscGVycy5vbk1vdXNlVXAoZXZ0LCB0YXJnZXRQcm9wcyk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvblRvdWNoRW5kOiAoZXZ0LCB0YXJnZXRQcm9wcykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHByb3BzLmRpc2FibGUgPyB7fSA6IF96b29tSGVscGVycy5ab29tSGVscGVycy5vbk1vdXNlVXAoZXZ0LCB0YXJnZXRQcm9wcyk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvbk1vdXNlTGVhdmU6IChldnQsIHRhcmdldFByb3BzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gcHJvcHMuZGlzYWJsZSA/IHt9IDogX3pvb21IZWxwZXJzLlpvb21IZWxwZXJzLm9uTW91c2VMZWF2ZShldnQsIHRhcmdldFByb3BzKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9uVG91Y2hDYW5jZWw6IChldnQsIHRhcmdldFByb3BzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gcHJvcHMuZGlzYWJsZSA/IHt9IDogX3pvb21IZWxwZXJzLlpvb21IZWxwZXJzLm9uTW91c2VMZWF2ZShldnQsIHRhcmdldFByb3BzKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtcGFyYW1zXG4gICAgICAgICAgb25Nb3VzZU1vdmU6IChldnQsIHRhcmdldFByb3BzLCBldmVudEtleSwgY3R4KSA9PiB7XG4gICAgICAgICAgICBpZiAocHJvcHMuZGlzYWJsZSkge1xuICAgICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX3pvb21IZWxwZXJzLlpvb21IZWxwZXJzLm9uTW91c2VNb3ZlKGV2dCwgdGFyZ2V0UHJvcHMsIGV2ZW50S2V5LCBjdHgpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1wYXJhbXNcbiAgICAgICAgICBvblRvdWNoTW92ZTogKGV2dCwgdGFyZ2V0UHJvcHMsIGV2ZW50S2V5LCBjdHgpID0+IHtcbiAgICAgICAgICAgIGlmIChwcm9wcy5kaXNhYmxlKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgcmV0dXJuIF96b29tSGVscGVycy5ab29tSGVscGVycy5vbk1vdXNlTW92ZShldnQsIHRhcmdldFByb3BzLCBldmVudEtleSwgY3R4KTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIC4uLihwcm9wcy5kaXNhYmxlIHx8ICFwcm9wcy5hbGxvd1pvb20gPyB7fSA6IHtcbiAgICAgICAgICAgIG9uV2hlZWw6IF96b29tSGVscGVycy5ab29tSGVscGVycy5vbldoZWVsXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfV07XG4gICAgfVxuICAgIGNsaXBEYXRhQ29tcG9uZW50cyhjaGlsZHJlbiwgcHJvcHMpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc2NhbGUsXG4gICAgICAgIGNsaXBDb250YWluZXJDb21wb25lbnQsXG4gICAgICAgIHBvbGFyLFxuICAgICAgICBvcmlnaW4sXG4gICAgICAgIGhvcml6b250YWxcbiAgICAgIH0gPSBwcm9wcztcbiAgICAgIGNvbnN0IHJhbmdlWCA9IGhvcml6b250YWwgPyBzY2FsZS55LnJhbmdlKCkgOiBzY2FsZS54LnJhbmdlKCk7XG4gICAgICBjb25zdCByYW5nZVkgPSBob3Jpem9udGFsID8gc2NhbGUueC5yYW5nZSgpIDogc2NhbGUueS5yYW5nZSgpO1xuICAgICAgY29uc3QgcGxvdHRhYmxlV2lkdGggPSBNYXRoLmFicyhyYW5nZVhbMF0gLSByYW5nZVhbMV0pO1xuICAgICAgY29uc3QgcGxvdHRhYmxlSGVpZ2h0ID0gTWF0aC5hYnMocmFuZ2VZWzBdIC0gcmFuZ2VZWzFdKTtcbiAgICAgIGNvbnN0IHJhZGl1cyA9IE1hdGgubWF4KC4uLnJhbmdlWSk7XG4gICAgICBjb25zdCBncm91cENvbXBvbmVudCA9IC8qI19fUFVSRV9fKi9fcmVhY3QuZGVmYXVsdC5jbG9uZUVsZW1lbnQoY2xpcENvbnRhaW5lckNvbXBvbmVudCwge1xuICAgICAgICBjbGlwV2lkdGg6IHBsb3R0YWJsZVdpZHRoLFxuICAgICAgICBjbGlwSGVpZ2h0OiBwbG90dGFibGVIZWlnaHQsXG4gICAgICAgIHRyYW5zbGF0ZVg6IE1hdGgubWluKC4uLnJhbmdlWCksXG4gICAgICAgIHRyYW5zbGF0ZVk6IE1hdGgubWluKC4uLnJhbmdlWSksXG4gICAgICAgIHBvbGFyLFxuICAgICAgICBvcmlnaW46IHBvbGFyID8gb3JpZ2luIDogdW5kZWZpbmVkLFxuICAgICAgICByYWRpdXM6IHBvbGFyID8gcmFkaXVzIDogdW5kZWZpbmVkLFxuICAgICAgICAuLi5jbGlwQ29udGFpbmVyQ29tcG9uZW50LnByb3BzXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBfcmVhY3QuZGVmYXVsdC5DaGlsZHJlbi50b0FycmF5KGNoaWxkcmVuKS5tYXAoY2hpbGQgPT4ge1xuICAgICAgICBpZiAoIV92aWN0b3J5Q29yZS5EYXRhLmlzRGF0YUNvbXBvbmVudChjaGlsZCkpIHtcbiAgICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3QuZGVmYXVsdC5jbG9uZUVsZW1lbnQoY2hpbGQsIHtcbiAgICAgICAgICBncm91cENvbXBvbmVudFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBtb2RpZnlQb2xhckRvbWFpbihkb21haW4sIG9yaWdpbmFsRG9tYWluKSB7XG4gICAgICAvLyBPbmx5IHpvb20gdGhlIHJhZGl1cyBvZiBwb2xhciBjaGFydHMuIFpvb21pbmcgYW5nbGVzIGlzIHZlcnkgY29uZnVzaW5nXG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBvcmlnaW5hbERvbWFpbi54LFxuICAgICAgICB5OiBbMCwgZG9tYWluLnlbMV1dXG4gICAgICB9O1xuICAgIH1cbiAgICBkb3duc2FtcGxlWm9vbURhdGEocHJvcHMsIGNoaWxkLCBkb21haW4pIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZG93bnNhbXBsZVxuICAgICAgfSA9IHByb3BzO1xuICAgICAgY29uc3QgZ2V0RGF0YSA9IGNoaWxkUHJvcHMgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgZGF0YSxcbiAgICAgICAgICB4LFxuICAgICAgICAgIHlcbiAgICAgICAgfSA9IGNoaWxkUHJvcHM7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRHZXREYXRhID0gY2hpbGQudHlwZSAmJiBfdmljdG9yeUNvcmUuSGVscGVycy5pc0Z1bmN0aW9uKGNoaWxkLnR5cGUuZ2V0RGF0YSkgPyBjaGlsZC50eXBlLmdldERhdGEgOiAoKSA9PiB1bmRlZmluZWQ7XG4gICAgICAgIC8vIHNraXAgY29zdGx5IGRhdGEgZm9ybWF0dGluZyBpZiB4IGFuZCB5IGFjY2Vzc29ycyBhcmUgbm90IHByZXNlbnRcbiAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoZGF0YSkgJiYgIXggJiYgIXkgPyBkYXRhIDogZGVmYXVsdEdldERhdGEoY2hpbGRQcm9wcyk7XG4gICAgICB9O1xuICAgICAgY29uc3QgZGF0YSA9IGdldERhdGEoY2hpbGQucHJvcHMpO1xuXG4gICAgICAvLyByZXR1cm4gdW5kZWZpbmVkIGlmIGRvd25zYW1wbGUgaXMgbm90IHJ1biwgdGhlbiBkZWZhdWx0KCkgd2lsbCByZXBsYWNlIHdpdGggY2hpbGQucHJvcHMuZGF0YVxuICAgICAgaWYgKCFkb3duc2FtcGxlIHx8ICFkb21haW4gfHwgIWRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1heFBvaW50cyA9IGRvd25zYW1wbGUgPT09IHRydWUgPyBERUZBVUxUX0RPV05TQU1QTEUgOiBkb3duc2FtcGxlO1xuICAgICAgY29uc3QgZGltZW5zaW9uID0gcHJvcHMuem9vbURpbWVuc2lvbiB8fCBcInhcIjtcblxuICAgICAgLy8gaW1wb3J0YW50OiBhc3N1bWVzIGRhdGEgaXMgb3JkZXJlZCBieSBkaW1lbnNpb25cbiAgICAgIC8vIGdldCB0aGUgc3RhcnQgYW5kIGVuZCBvZiB0aGUgZGF0YSB0aGF0IGlzIGluIHRoZSBjdXJyZW50IHZpc2libGUgZG9tYWluXG4gICAgICBsZXQgc3RhcnRJbmRleCA9IGRhdGEuZmluZEluZGV4KGQgPT4gZFtkaW1lbnNpb25dID49IGRvbWFpbltkaW1lbnNpb25dWzBdKTtcbiAgICAgIGxldCBlbmRJbmRleCA9IGRhdGEuZmluZEluZGV4KGQgPT4gZFtkaW1lbnNpb25dID4gZG9tYWluW2RpbWVuc2lvbl1bMV0pO1xuICAgICAgLy8gcGljayBvbmUgbW9yZSBwb2ludCAoaWYgYXZhaWxhYmxlKSBhdCBlYWNoIGVuZCBzbyB0aGF0IFZpY3RvcnlMaW5lLCBWaWN0b3J5QXJlYSBjb25uZWN0XG4gICAgICBpZiAoc3RhcnRJbmRleCAhPT0gMCkge1xuICAgICAgICBzdGFydEluZGV4IC09IDE7XG4gICAgICB9XG4gICAgICBpZiAoZW5kSW5kZXggIT09IC0xKSB7XG4gICAgICAgIGVuZEluZGV4ICs9IDE7XG4gICAgICB9XG4gICAgICBjb25zdCB2aXNpYmxlRGF0YSA9IGRhdGEuc2xpY2Uoc3RhcnRJbmRleCwgZW5kSW5kZXgpO1xuICAgICAgcmV0dXJuIF92aWN0b3J5Q29yZS5EYXRhLmRvd25zYW1wbGUodmlzaWJsZURhdGEsIG1heFBvaW50cywgc3RhcnRJbmRleCk7XG4gICAgfVxuICAgIG1vZGlmeUNoaWxkcmVuKHByb3BzKSB7XG4gICAgICBjb25zdCBjaGlsZENvbXBvbmVudHMgPSBfcmVhY3QuZGVmYXVsdC5DaGlsZHJlbi50b0FycmF5KHByb3BzLmNoaWxkcmVuKTtcbiAgICAgIHJldHVybiBjaGlsZENvbXBvbmVudHMubWFwKGNoaWxkID0+IHtcbiAgICAgICAgY29uc3Qgcm9sZSA9IGNoaWxkLnR5cGUgJiYgY2hpbGQudHlwZS5yb2xlO1xuICAgICAgICBjb25zdCBpc0RhdGFDb21wb25lbnQgPSBfdmljdG9yeUNvcmUuRGF0YS5pc0RhdGFDb21wb25lbnQoY2hpbGQpO1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgY3VycmVudERvbWFpbixcbiAgICAgICAgICB6b29tQWN0aXZlLFxuICAgICAgICAgIGFsbG93Wm9vbVxuICAgICAgICB9ID0gcHJvcHM7XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsRG9tYWluID0gKDAsIF9kZWZhdWx0czIuZGVmYXVsdCkoe30sIHByb3BzLm9yaWdpbmFsRG9tYWluLCBwcm9wcy5kb21haW4pO1xuICAgICAgICBjb25zdCB6b29tRG9tYWluID0gKDAsIF9kZWZhdWx0czIuZGVmYXVsdCkoe30sIHByb3BzLnpvb21Eb21haW4sIHByb3BzLmRvbWFpbik7XG4gICAgICAgIGNvbnN0IGNhY2hlZFpvb21Eb21haW4gPSAoMCwgX2RlZmF1bHRzMi5kZWZhdWx0KSh7fSwgcHJvcHMuY2FjaGVkWm9vbURvbWFpbiwgcHJvcHMuZG9tYWluKTtcbiAgICAgICAgbGV0IGRvbWFpbjtcbiAgICAgICAgaWYgKCFfem9vbUhlbHBlcnMuWm9vbUhlbHBlcnMuY2hlY2tEb21haW5FcXVhbGl0eSh6b29tRG9tYWluLCBjYWNoZWRab29tRG9tYWluKSkge1xuICAgICAgICAgIC8vIGlmIHpvb21Eb21haW4gaGFzIGJlZW4gY2hhbmdlZCwgdXNlIGl0XG4gICAgICAgICAgZG9tYWluID0gem9vbURvbWFpbjtcbiAgICAgICAgfSBlbHNlIGlmIChhbGxvd1pvb20gJiYgIXpvb21BY3RpdmUpIHtcbiAgICAgICAgICAvLyBpZiB1c2VyIGhhcyB6b29tZWQgYWxsIHRoZSB3YXkgb3V0LCB1c2UgdGhlIGNoaWxkIGRvbWFpblxuICAgICAgICAgIGRvbWFpbiA9IGNoaWxkLnByb3BzLmRvbWFpbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBkZWZhdWx0OiB1c2UgY3VycmVudERvbWFpbiwgc2V0IGJ5IHRoZSBldmVudCBoYW5kbGVyc1xuICAgICAgICAgIGRvbWFpbiA9ICgwLCBfZGVmYXVsdHMyLmRlZmF1bHQpKHt9LCBjdXJyZW50RG9tYWluLCBvcmlnaW5hbERvbWFpbik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5ld0RvbWFpbiA9IHByb3BzLnBvbGFyID8gdGhpcy5tb2RpZnlQb2xhckRvbWFpbihkb21haW4sIG9yaWdpbmFsRG9tYWluKSA6IGRvbWFpbjtcbiAgICAgICAgaWYgKG5ld0RvbWFpbiAmJiBwcm9wcy56b29tRGltZW5zaW9uKSB7XG4gICAgICAgICAgLy8gaWYgem9vbWluZyBpcyByZXN0cmljdGVkIHRvIGEgZGltZW5zaW9uLCBkb24ndCBzcXVhc2ggY2hhbmdlcyB0byB6b29tRG9tYWluIGluIG90aGVyIGRpbVxuICAgICAgICAgIG5ld0RvbWFpbiA9IHtcbiAgICAgICAgICAgIC4uLnpvb21Eb21haW4sXG4gICAgICAgICAgICBbcHJvcHMuem9vbURpbWVuc2lvbl06IG5ld0RvbWFpbltwcm9wcy56b29tRGltZW5zaW9uXVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gZG9uJ3QgZG93bnNhbXBsZSBzdGFja2VkIGRhdGFcbiAgICAgICAgY29uc3QgbmV3UHJvcHMgPSBpc0RhdGFDb21wb25lbnQgJiYgcm9sZSAhPT0gXCJzdGFja1wiID8ge1xuICAgICAgICAgIGRvbWFpbjogbmV3RG9tYWluLFxuICAgICAgICAgIGRhdGE6IHRoaXMuZG93bnNhbXBsZVpvb21EYXRhKHByb3BzLCBjaGlsZCwgbmV3RG9tYWluKVxuICAgICAgICB9IDoge1xuICAgICAgICAgIGRvbWFpbjogbmV3RG9tYWluXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0LmRlZmF1bHQuY2xvbmVFbGVtZW50KGNoaWxkLCAoMCwgX2RlZmF1bHRzMi5kZWZhdWx0KShuZXdQcm9wcywgY2hpbGQucHJvcHMpKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIE92ZXJyaWRlcyBtZXRob2QgaW4gVmljdG9yeUNvbnRhaW5lclxuICAgIGdldENoaWxkcmVuKHByb3BzKSB7XG4gICAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMubW9kaWZ5Q2hpbGRyZW4ocHJvcHMpO1xuICAgICAgcmV0dXJuIHRoaXMuY2xpcERhdGFDb21wb25lbnRzKGNoaWxkcmVuLCBwcm9wcyk7XG4gICAgfVxuICB9O1xufVxuY29uc3QgVmljdG9yeVpvb21Db250YWluZXIgPSBleHBvcnRzLlZpY3Rvcnlab29tQ29udGFpbmVyID0gem9vbUNvbnRhaW5lck1peGluKF92aWN0b3J5Q29yZS5WaWN0b3J5Q29udGFpbmVyKTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/victory-zoom-container/lib/victory-zoom-container.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/victory-zoom-container/lib/zoom-helpers.js":
/*!*****************************************************************!*\
  !*** ./node_modules/victory-zoom-container/lib/zoom-helpers.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.ZoomHelpers = exports.RawZoomHelpers = void 0;\nvar _delay2 = _interopRequireDefault(__webpack_require__(/*! lodash/delay */ \"(ssr)/./node_modules/lodash/delay.js\"));\nvar _defaults2 = _interopRequireDefault(__webpack_require__(/*! lodash/defaults */ \"(ssr)/./node_modules/lodash/defaults.js\"));\nvar _throttle2 = _interopRequireDefault(__webpack_require__(/*! lodash/throttle */ \"(ssr)/./node_modules/lodash/throttle.js\"));\nvar _react = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nvar _victoryCore = __webpack_require__(/*! victory-core */ \"(ssr)/./node_modules/victory-core/lib/index.js\");\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n/* eslint no-magic-numbers: [\"error\", { \"ignore\": [-1, 0, 1, 2, 1000] }]*/\n\nconst RawZoomHelpers = exports.RawZoomHelpers = {\n  checkDomainEquality(a, b) {\n    const checkDimension = dim => {\n      const val1 = a && a[dim];\n      const val2 = b && b[dim];\n      if (!val1 && !val2) {\n        return true;\n      } else if (!val1 || !val2) {\n        return false;\n      }\n      return Number(val1[0]) === Number(val2[0]) && Number(val1[1]) === Number(val2[1]);\n    };\n    return checkDimension(\"x\") && checkDimension(\"y\");\n  },\n  /**\n   * Generates a new domain scaled by factor and constrained by the original domain.\n   * @param  {[Number, Number]} currentDomain  The domain to be scaled.\n   * @param  {Object} evt the event object\n   * @param  {Object} props the props of the targeted component\n   * @param  {String} axis the desired dimension (either x or y)\n   * @return {[Number, Number]}                The scale domain\n   */\n  // eslint-disable-next-line max-params\n  scale(currentDomain, evt, props, axis) {\n    const [from, to] = currentDomain;\n    const range = Math.abs(to - from);\n    const minimumZoom = props.minimumZoom && props.minimumZoom[axis];\n    const factor = this.getScaleFactor(evt);\n    if (minimumZoom && range <= minimumZoom && factor < 1) {\n      return currentDomain;\n    }\n    const [fromBound, toBound] = this.getDomain(props)[axis];\n    const percent = this.getScalePercent(evt, props, axis);\n    const point = factor * from + percent * (factor * range);\n    const minDomain = this.getMinimumDomain(point, props, axis);\n    const [newMin, newMax] = this.getScaledDomain(currentDomain, factor, percent);\n    const newDomain = [newMin > fromBound && newMin < toBound ? newMin : fromBound, newMax < toBound && newMax > fromBound ? newMax : toBound];\n    const domain = Math.abs(minDomain[1] - minDomain[0]) > Math.abs(newDomain[1] - newDomain[0]) ? minDomain : newDomain;\n    return _victoryCore.Collection.containsDates([fromBound, toBound]) ? [new Date(domain[0]), new Date(domain[1])] : domain;\n  },\n  getScaledDomain(currentDomain, factor, percent) {\n    const [from, to] = currentDomain;\n    const range = Math.abs(to - from);\n    const diff = range - range * factor;\n    const newMin = Number(from) + diff * percent;\n    const newMax = Number(to) - diff * (1 - percent);\n    return [Math.min(newMin, newMax), Math.max(newMin, newMax)];\n  },\n  getMinimumDomain(point, props, axis) {\n    const {\n      minimumZoom\n    } = props;\n    const originalDomain = this.getDomain(props)[axis];\n    const [from, to] = originalDomain;\n    const defaultMin = Math.abs(from - to) / 1000;\n    const extent = minimumZoom ? minimumZoom[axis] || defaultMin : defaultMin;\n    const minExtent = point - extent / 2;\n    const maxExtent = point + extent / 2;\n    return [minExtent > from && minExtent < to ? minExtent : from, maxExtent < to && maxExtent > from ? maxExtent : Number(from) + extent / 2];\n  },\n  zoommingOut(evt) {\n    return evt.deltaY > 0;\n  },\n  getScaleFactor(evt) {\n    const sign = this.zoommingOut(evt) ? 1 : -1;\n    // eslint-disable-next-line no-magic-numbers\n    const delta = Math.min(Math.abs(evt.deltaY / 300), 0.5); // TODO: Check scale factor\n    return Math.abs(1 + sign * delta);\n  },\n  getScalePercent(evt, props, axis) {\n    const originalDomain = this.getDomain(props);\n    const [from, to] = originalDomain[axis];\n    const position = this.getPosition(evt, props, originalDomain);\n    return (position[axis] - from) / Math.abs(to - from);\n  },\n  getPosition(evt, props, originalDomain) {\n    const {\n      x,\n      y\n    } = _victoryCore.Selection.getSVGEventCoordinates(evt);\n    const originalScale = {\n      x: props.scale.x.domain(originalDomain.x),\n      y: props.scale.y.domain(originalDomain.y)\n    };\n    return _victoryCore.Selection.getDataCoordinates(props, originalScale, x, y);\n  },\n  /**\n   * Generate a new domain translated by the delta and constrained by the original domain.\n   * @param  {[Number, Number]} currentDomain  The domain to be translated.\n   * @param  {[Number, Number]} originalDomain The original domain for the data set.\n   * @param  {Number}           delta          The delta to translate by\n   * @return {[Number, Number]}                The translated domain\n   */\n  pan(currentDomain, originalDomain, delta) {\n    const [fromCurrent, toCurrent] = currentDomain.map(val => Number(val));\n    const [fromOriginal, toOriginal] = originalDomain.map(val => Number(val));\n    const lowerBound = fromCurrent + delta;\n    const upperBound = toCurrent + delta;\n    let newDomain;\n    if (lowerBound > fromOriginal && upperBound < toOriginal) {\n      newDomain = [lowerBound, upperBound];\n    } else if (lowerBound < fromOriginal) {\n      // Clamp to lower limit\n      const dx = toCurrent - fromCurrent;\n      newDomain = [fromOriginal, fromOriginal + dx];\n    } else if (upperBound > toOriginal) {\n      // Clamp to upper limit\n      const dx = toCurrent - fromCurrent;\n      newDomain = [toOriginal - dx, toOriginal];\n    } else {\n      newDomain = currentDomain;\n    }\n    return _victoryCore.Collection.containsDates(currentDomain) || _victoryCore.Collection.containsDates(originalDomain) ? newDomain.map(val => new Date(val)) : newDomain;\n  },\n  getDomainScale(domain, scale, axis) {\n    const axisDomain = Array.isArray(domain) ? domain : domain[axis];\n    const [from, to] = axisDomain;\n    const range = scale[axis].range();\n    const plottableWidth = Math.abs(range[0] - range[1]);\n    return plottableWidth / (to - from);\n  },\n  handleAnimation(ctx) {\n    const animationTimer = ctx.context.animationTimer;\n    const transitionTimer = ctx.context.transitionTimer;\n    transitionTimer.bypassAnimation();\n    animationTimer.bypassAnimation();\n    const resumeAnimation = () => {\n      animationTimer.resumeAnimation();\n      transitionTimer.resumeAnimation();\n    };\n    // delay the callback that resumes animation by ~1 frame so that animation does not interfere with wheel events\n    return (0, _delay2.default)(resumeAnimation, 16); // eslint-disable-line no-magic-numbers\n  },\n  getLastDomain(targetProps, originalDomain) {\n    const {\n      zoomDomain,\n      cachedZoomDomain,\n      currentDomain,\n      domain\n    } = targetProps;\n    if (zoomDomain && !this.checkDomainEquality(zoomDomain, cachedZoomDomain)) {\n      return (0, _defaults2.default)({}, zoomDomain, domain);\n    }\n    return (0, _defaults2.default)({}, currentDomain || zoomDomain || originalDomain, domain);\n  },\n  getDomain(props) {\n    const {\n      originalDomain,\n      domain,\n      children,\n      zoomDimension\n    } = props;\n    const childComponents = _react.Children.toArray(children);\n    let childrenDomain = {};\n    if (childComponents.length) {\n      childrenDomain = zoomDimension ? {\n        [zoomDimension]: _victoryCore.Wrapper.getDomainFromChildren(props, zoomDimension, childComponents)\n      } : {\n        x: _victoryCore.Wrapper.getDomainFromChildren(props, \"x\", childComponents),\n        y: _victoryCore.Wrapper.getDomainFromChildren(props, \"y\", childComponents)\n      };\n    }\n    return (0, _defaults2.default)({}, childrenDomain, originalDomain, domain);\n  },\n  onMouseDown(evt, targetProps) {\n    evt.preventDefault();\n    if (!targetProps.allowPan) {\n      return undefined;\n    }\n    const parentSVG = targetProps.parentSVG || _victoryCore.Selection.getParentSVG(evt);\n    const {\n      x,\n      y\n    } = _victoryCore.Selection.getSVGEventCoordinates(evt, parentSVG);\n    return [{\n      target: \"parent\",\n      mutation: () => {\n        return {\n          startX: x,\n          startY: y,\n          panning: true,\n          parentSVG,\n          parentControlledProps: [\"domain\"]\n        };\n      }\n    }];\n  },\n  onMouseUp(evt, targetProps) {\n    if (!targetProps.allowPan) {\n      return undefined;\n    }\n    return [{\n      target: \"parent\",\n      mutation: () => {\n        return {\n          panning: false\n        };\n      }\n    }];\n  },\n  onMouseLeave(evt, targetProps) {\n    if (!targetProps.allowPan) {\n      return undefined;\n    }\n    return [{\n      target: \"parent\",\n      mutation: () => {\n        return {\n          panning: false\n        };\n      }\n    }];\n  },\n  // eslint-disable-next-line max-params, max-statements\n  onMouseMove(evt, targetProps, eventKey, ctx) {\n    if (targetProps.panning && targetProps.allowPan) {\n      const {\n        scale,\n        startX,\n        startY,\n        onZoomDomainChange,\n        zoomDomain,\n        zoomDimension,\n        horizontal\n      } = targetProps;\n      const parentSVG = targetProps.parentSVG || _victoryCore.Selection.getParentSVG(evt);\n      const {\n        x,\n        y\n      } = _victoryCore.Selection.getSVGEventCoordinates(evt, parentSVG);\n      const originalDomain = this.getDomain(targetProps);\n      const lastDomain = this.getLastDomain(targetProps, originalDomain);\n      const deltaX = horizontal ? y - startY : startX - x;\n      const deltaY = horizontal ? startX - x : y - startY;\n      const dx = deltaX / this.getDomainScale(lastDomain, scale, \"x\");\n      const dy = deltaY / this.getDomainScale(lastDomain, scale, \"y\");\n      const currentDomain = {\n        x: zoomDimension === \"y\" ? originalDomain.x : this.pan(lastDomain.x, originalDomain.x, dx),\n        y: zoomDimension === \"x\" ? originalDomain.y : this.pan(lastDomain.y, originalDomain.y, dy)\n      };\n      const resumeAnimation = this.handleAnimation(ctx);\n      const zoomActive = !this.checkDomainEquality(originalDomain, lastDomain);\n      const mutatedProps = {\n        parentControlledProps: [\"domain\"],\n        startX: x,\n        startY: y,\n        parentSVG,\n        currentDomain,\n        originalDomain,\n        cachedZoomDomain: zoomDomain,\n        zoomActive\n      };\n      if (_victoryCore.Helpers.isFunction(onZoomDomainChange)) {\n        onZoomDomainChange(currentDomain, (0, _defaults2.default)({}, mutatedProps, targetProps));\n      }\n      return [{\n        target: \"parent\",\n        callback: resumeAnimation,\n        mutation: () => mutatedProps\n      }];\n    }\n    return undefined;\n  },\n  // eslint-disable-next-line max-params\n  onWheel(evt, targetProps, eventKey, ctx) {\n    if (!targetProps.allowZoom) {\n      return undefined;\n    }\n    const {\n      onZoomDomainChange,\n      zoomDimension,\n      zoomDomain\n    } = targetProps;\n    const originalDomain = this.getDomain(targetProps);\n    const lastDomain = this.getLastDomain(targetProps, originalDomain);\n    const {\n      x,\n      y\n    } = lastDomain;\n    const currentDomain = {\n      x: zoomDimension === \"y\" ? lastDomain.x : this.scale(x, evt, targetProps, \"x\"),\n      y: zoomDimension === \"x\" ? lastDomain.y : this.scale(y, evt, targetProps, \"y\")\n    };\n    const resumeAnimation = this.handleAnimation(ctx);\n    const zoomActive = !this.zoommingOut(evt) ||\n    // if zoomming in or\n    //   if zoomActive is already set AND user hasn't zoommed out all the way\n    targetProps.zoomActive && !this.checkDomainEquality(originalDomain, lastDomain);\n    const mutatedProps = {\n      currentDomain,\n      originalDomain,\n      cachedZoomDomain: zoomDomain,\n      parentControlledProps: [\"domain\"],\n      panning: false,\n      zoomActive\n    };\n    if (_victoryCore.Helpers.isFunction(onZoomDomainChange)) {\n      onZoomDomainChange(currentDomain, (0, _defaults2.default)({}, mutatedProps, targetProps));\n    }\n    return [{\n      target: \"parent\",\n      callback: resumeAnimation,\n      mutation: () => mutatedProps\n    }];\n  }\n};\nconst ZoomHelpers = exports.ZoomHelpers = {\n  checkDomainEquality: RawZoomHelpers.checkDomainEquality.bind(RawZoomHelpers),\n  onMouseDown: RawZoomHelpers.onMouseDown.bind(RawZoomHelpers),\n  onMouseUp: RawZoomHelpers.onMouseUp.bind(RawZoomHelpers),\n  onMouseLeave: RawZoomHelpers.onMouseLeave.bind(RawZoomHelpers),\n  onMouseMove: (0, _throttle2.default)(RawZoomHelpers.onMouseMove.bind(RawZoomHelpers), 16,\n  // eslint-disable-line no-magic-numbers\n  {\n    leading: true,\n    trailing: false\n  }),\n  onWheel: (0, _throttle2.default)(RawZoomHelpers.onWheel.bind(RawZoomHelpers), 16,\n  // eslint-disable-line no-magic-numbers\n  {\n    leading: true,\n    trailing: false\n  })\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdmljdG9yeS16b29tLWNvbnRhaW5lci9saWIvem9vbS1oZWxwZXJzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLG1CQUFtQixHQUFHLHNCQUFzQjtBQUM1QyxxQ0FBcUMsbUJBQU8sQ0FBQywwREFBYztBQUMzRCx3Q0FBd0MsbUJBQU8sQ0FBQyxnRUFBaUI7QUFDakUsd0NBQXdDLG1CQUFPLENBQUMsZ0VBQWlCO0FBQ2pFLGFBQWEsbUJBQU8sQ0FBQyx3R0FBTztBQUM1QixtQkFBbUIsbUJBQU8sQ0FBQyxvRUFBYztBQUN6Qyx1Q0FBdUMsdUNBQXVDO0FBQzlFLHdDQUF3QywrQkFBK0I7O0FBRXZFLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGNBQWMsa0JBQWtCO0FBQ2hDLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsaUNBQWlDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxjQUFjLGtCQUFrQjtBQUNoQyxjQUFjLGtCQUFrQjtBQUNoQyxjQUFjLGtCQUFrQjtBQUNoQyxjQUFjLGlDQUFpQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3RELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQSxxQ0FBcUM7QUFDckMsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCIsInNvdXJjZXMiOlsid2VicGFjazovL3RlbXAvLi9ub2RlX21vZHVsZXMvdmljdG9yeS16b29tLWNvbnRhaW5lci9saWIvem9vbS1oZWxwZXJzLmpzPzYxODUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLlpvb21IZWxwZXJzID0gZXhwb3J0cy5SYXdab29tSGVscGVycyA9IHZvaWQgMDtcbnZhciBfZGVsYXkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2RlbGF5XCIpKTtcbnZhciBfZGVmYXVsdHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2RlZmF1bHRzXCIpKTtcbnZhciBfdGhyb3R0bGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL3Rocm90dGxlXCIpKTtcbnZhciBfcmVhY3QgPSByZXF1aXJlKFwicmVhY3RcIik7XG52YXIgX3ZpY3RvcnlDb3JlID0gcmVxdWlyZShcInZpY3RvcnktY29yZVwiKTtcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG4vKiBlc2xpbnQgbm8tbWFnaWMtbnVtYmVyczogW1wiZXJyb3JcIiwgeyBcImlnbm9yZVwiOiBbLTEsIDAsIDEsIDIsIDEwMDBdIH1dKi9cblxuY29uc3QgUmF3Wm9vbUhlbHBlcnMgPSBleHBvcnRzLlJhd1pvb21IZWxwZXJzID0ge1xuICBjaGVja0RvbWFpbkVxdWFsaXR5KGEsIGIpIHtcbiAgICBjb25zdCBjaGVja0RpbWVuc2lvbiA9IGRpbSA9PiB7XG4gICAgICBjb25zdCB2YWwxID0gYSAmJiBhW2RpbV07XG4gICAgICBjb25zdCB2YWwyID0gYiAmJiBiW2RpbV07XG4gICAgICBpZiAoIXZhbDEgJiYgIXZhbDIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2UgaWYgKCF2YWwxIHx8ICF2YWwyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBOdW1iZXIodmFsMVswXSkgPT09IE51bWJlcih2YWwyWzBdKSAmJiBOdW1iZXIodmFsMVsxXSkgPT09IE51bWJlcih2YWwyWzFdKTtcbiAgICB9O1xuICAgIHJldHVybiBjaGVja0RpbWVuc2lvbihcInhcIikgJiYgY2hlY2tEaW1lbnNpb24oXCJ5XCIpO1xuICB9LFxuICAvKipcbiAgICogR2VuZXJhdGVzIGEgbmV3IGRvbWFpbiBzY2FsZWQgYnkgZmFjdG9yIGFuZCBjb25zdHJhaW5lZCBieSB0aGUgb3JpZ2luYWwgZG9tYWluLlxuICAgKiBAcGFyYW0gIHtbTnVtYmVyLCBOdW1iZXJdfSBjdXJyZW50RG9tYWluICBUaGUgZG9tYWluIHRvIGJlIHNjYWxlZC5cbiAgICogQHBhcmFtICB7T2JqZWN0fSBldnQgdGhlIGV2ZW50IG9iamVjdFxuICAgKiBAcGFyYW0gIHtPYmplY3R9IHByb3BzIHRoZSBwcm9wcyBvZiB0aGUgdGFyZ2V0ZWQgY29tcG9uZW50XG4gICAqIEBwYXJhbSAge1N0cmluZ30gYXhpcyB0aGUgZGVzaXJlZCBkaW1lbnNpb24gKGVpdGhlciB4IG9yIHkpXG4gICAqIEByZXR1cm4ge1tOdW1iZXIsIE51bWJlcl19ICAgICAgICAgICAgICAgIFRoZSBzY2FsZSBkb21haW5cbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtcGFyYW1zXG4gIHNjYWxlKGN1cnJlbnREb21haW4sIGV2dCwgcHJvcHMsIGF4aXMpIHtcbiAgICBjb25zdCBbZnJvbSwgdG9dID0gY3VycmVudERvbWFpbjtcbiAgICBjb25zdCByYW5nZSA9IE1hdGguYWJzKHRvIC0gZnJvbSk7XG4gICAgY29uc3QgbWluaW11bVpvb20gPSBwcm9wcy5taW5pbXVtWm9vbSAmJiBwcm9wcy5taW5pbXVtWm9vbVtheGlzXTtcbiAgICBjb25zdCBmYWN0b3IgPSB0aGlzLmdldFNjYWxlRmFjdG9yKGV2dCk7XG4gICAgaWYgKG1pbmltdW1ab29tICYmIHJhbmdlIDw9IG1pbmltdW1ab29tICYmIGZhY3RvciA8IDEpIHtcbiAgICAgIHJldHVybiBjdXJyZW50RG9tYWluO1xuICAgIH1cbiAgICBjb25zdCBbZnJvbUJvdW5kLCB0b0JvdW5kXSA9IHRoaXMuZ2V0RG9tYWluKHByb3BzKVtheGlzXTtcbiAgICBjb25zdCBwZXJjZW50ID0gdGhpcy5nZXRTY2FsZVBlcmNlbnQoZXZ0LCBwcm9wcywgYXhpcyk7XG4gICAgY29uc3QgcG9pbnQgPSBmYWN0b3IgKiBmcm9tICsgcGVyY2VudCAqIChmYWN0b3IgKiByYW5nZSk7XG4gICAgY29uc3QgbWluRG9tYWluID0gdGhpcy5nZXRNaW5pbXVtRG9tYWluKHBvaW50LCBwcm9wcywgYXhpcyk7XG4gICAgY29uc3QgW25ld01pbiwgbmV3TWF4XSA9IHRoaXMuZ2V0U2NhbGVkRG9tYWluKGN1cnJlbnREb21haW4sIGZhY3RvciwgcGVyY2VudCk7XG4gICAgY29uc3QgbmV3RG9tYWluID0gW25ld01pbiA+IGZyb21Cb3VuZCAmJiBuZXdNaW4gPCB0b0JvdW5kID8gbmV3TWluIDogZnJvbUJvdW5kLCBuZXdNYXggPCB0b0JvdW5kICYmIG5ld01heCA+IGZyb21Cb3VuZCA/IG5ld01heCA6IHRvQm91bmRdO1xuICAgIGNvbnN0IGRvbWFpbiA9IE1hdGguYWJzKG1pbkRvbWFpblsxXSAtIG1pbkRvbWFpblswXSkgPiBNYXRoLmFicyhuZXdEb21haW5bMV0gLSBuZXdEb21haW5bMF0pID8gbWluRG9tYWluIDogbmV3RG9tYWluO1xuICAgIHJldHVybiBfdmljdG9yeUNvcmUuQ29sbGVjdGlvbi5jb250YWluc0RhdGVzKFtmcm9tQm91bmQsIHRvQm91bmRdKSA/IFtuZXcgRGF0ZShkb21haW5bMF0pLCBuZXcgRGF0ZShkb21haW5bMV0pXSA6IGRvbWFpbjtcbiAgfSxcbiAgZ2V0U2NhbGVkRG9tYWluKGN1cnJlbnREb21haW4sIGZhY3RvciwgcGVyY2VudCkge1xuICAgIGNvbnN0IFtmcm9tLCB0b10gPSBjdXJyZW50RG9tYWluO1xuICAgIGNvbnN0IHJhbmdlID0gTWF0aC5hYnModG8gLSBmcm9tKTtcbiAgICBjb25zdCBkaWZmID0gcmFuZ2UgLSByYW5nZSAqIGZhY3RvcjtcbiAgICBjb25zdCBuZXdNaW4gPSBOdW1iZXIoZnJvbSkgKyBkaWZmICogcGVyY2VudDtcbiAgICBjb25zdCBuZXdNYXggPSBOdW1iZXIodG8pIC0gZGlmZiAqICgxIC0gcGVyY2VudCk7XG4gICAgcmV0dXJuIFtNYXRoLm1pbihuZXdNaW4sIG5ld01heCksIE1hdGgubWF4KG5ld01pbiwgbmV3TWF4KV07XG4gIH0sXG4gIGdldE1pbmltdW1Eb21haW4ocG9pbnQsIHByb3BzLCBheGlzKSB7XG4gICAgY29uc3Qge1xuICAgICAgbWluaW11bVpvb21cbiAgICB9ID0gcHJvcHM7XG4gICAgY29uc3Qgb3JpZ2luYWxEb21haW4gPSB0aGlzLmdldERvbWFpbihwcm9wcylbYXhpc107XG4gICAgY29uc3QgW2Zyb20sIHRvXSA9IG9yaWdpbmFsRG9tYWluO1xuICAgIGNvbnN0IGRlZmF1bHRNaW4gPSBNYXRoLmFicyhmcm9tIC0gdG8pIC8gMTAwMDtcbiAgICBjb25zdCBleHRlbnQgPSBtaW5pbXVtWm9vbSA/IG1pbmltdW1ab29tW2F4aXNdIHx8IGRlZmF1bHRNaW4gOiBkZWZhdWx0TWluO1xuICAgIGNvbnN0IG1pbkV4dGVudCA9IHBvaW50IC0gZXh0ZW50IC8gMjtcbiAgICBjb25zdCBtYXhFeHRlbnQgPSBwb2ludCArIGV4dGVudCAvIDI7XG4gICAgcmV0dXJuIFttaW5FeHRlbnQgPiBmcm9tICYmIG1pbkV4dGVudCA8IHRvID8gbWluRXh0ZW50IDogZnJvbSwgbWF4RXh0ZW50IDwgdG8gJiYgbWF4RXh0ZW50ID4gZnJvbSA/IG1heEV4dGVudCA6IE51bWJlcihmcm9tKSArIGV4dGVudCAvIDJdO1xuICB9LFxuICB6b29tbWluZ091dChldnQpIHtcbiAgICByZXR1cm4gZXZ0LmRlbHRhWSA+IDA7XG4gIH0sXG4gIGdldFNjYWxlRmFjdG9yKGV2dCkge1xuICAgIGNvbnN0IHNpZ24gPSB0aGlzLnpvb21taW5nT3V0KGV2dCkgPyAxIDogLTE7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW1hZ2ljLW51bWJlcnNcbiAgICBjb25zdCBkZWx0YSA9IE1hdGgubWluKE1hdGguYWJzKGV2dC5kZWx0YVkgLyAzMDApLCAwLjUpOyAvLyBUT0RPOiBDaGVjayBzY2FsZSBmYWN0b3JcbiAgICByZXR1cm4gTWF0aC5hYnMoMSArIHNpZ24gKiBkZWx0YSk7XG4gIH0sXG4gIGdldFNjYWxlUGVyY2VudChldnQsIHByb3BzLCBheGlzKSB7XG4gICAgY29uc3Qgb3JpZ2luYWxEb21haW4gPSB0aGlzLmdldERvbWFpbihwcm9wcyk7XG4gICAgY29uc3QgW2Zyb20sIHRvXSA9IG9yaWdpbmFsRG9tYWluW2F4aXNdO1xuICAgIGNvbnN0IHBvc2l0aW9uID0gdGhpcy5nZXRQb3NpdGlvbihldnQsIHByb3BzLCBvcmlnaW5hbERvbWFpbik7XG4gICAgcmV0dXJuIChwb3NpdGlvbltheGlzXSAtIGZyb20pIC8gTWF0aC5hYnModG8gLSBmcm9tKTtcbiAgfSxcbiAgZ2V0UG9zaXRpb24oZXZ0LCBwcm9wcywgb3JpZ2luYWxEb21haW4pIHtcbiAgICBjb25zdCB7XG4gICAgICB4LFxuICAgICAgeVxuICAgIH0gPSBfdmljdG9yeUNvcmUuU2VsZWN0aW9uLmdldFNWR0V2ZW50Q29vcmRpbmF0ZXMoZXZ0KTtcbiAgICBjb25zdCBvcmlnaW5hbFNjYWxlID0ge1xuICAgICAgeDogcHJvcHMuc2NhbGUueC5kb21haW4ob3JpZ2luYWxEb21haW4ueCksXG4gICAgICB5OiBwcm9wcy5zY2FsZS55LmRvbWFpbihvcmlnaW5hbERvbWFpbi55KVxuICAgIH07XG4gICAgcmV0dXJuIF92aWN0b3J5Q29yZS5TZWxlY3Rpb24uZ2V0RGF0YUNvb3JkaW5hdGVzKHByb3BzLCBvcmlnaW5hbFNjYWxlLCB4LCB5KTtcbiAgfSxcbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgbmV3IGRvbWFpbiB0cmFuc2xhdGVkIGJ5IHRoZSBkZWx0YSBhbmQgY29uc3RyYWluZWQgYnkgdGhlIG9yaWdpbmFsIGRvbWFpbi5cbiAgICogQHBhcmFtICB7W051bWJlciwgTnVtYmVyXX0gY3VycmVudERvbWFpbiAgVGhlIGRvbWFpbiB0byBiZSB0cmFuc2xhdGVkLlxuICAgKiBAcGFyYW0gIHtbTnVtYmVyLCBOdW1iZXJdfSBvcmlnaW5hbERvbWFpbiBUaGUgb3JpZ2luYWwgZG9tYWluIGZvciB0aGUgZGF0YSBzZXQuXG4gICAqIEBwYXJhbSAge051bWJlcn0gICAgICAgICAgIGRlbHRhICAgICAgICAgIFRoZSBkZWx0YSB0byB0cmFuc2xhdGUgYnlcbiAgICogQHJldHVybiB7W051bWJlciwgTnVtYmVyXX0gICAgICAgICAgICAgICAgVGhlIHRyYW5zbGF0ZWQgZG9tYWluXG4gICAqL1xuICBwYW4oY3VycmVudERvbWFpbiwgb3JpZ2luYWxEb21haW4sIGRlbHRhKSB7XG4gICAgY29uc3QgW2Zyb21DdXJyZW50LCB0b0N1cnJlbnRdID0gY3VycmVudERvbWFpbi5tYXAodmFsID0+IE51bWJlcih2YWwpKTtcbiAgICBjb25zdCBbZnJvbU9yaWdpbmFsLCB0b09yaWdpbmFsXSA9IG9yaWdpbmFsRG9tYWluLm1hcCh2YWwgPT4gTnVtYmVyKHZhbCkpO1xuICAgIGNvbnN0IGxvd2VyQm91bmQgPSBmcm9tQ3VycmVudCArIGRlbHRhO1xuICAgIGNvbnN0IHVwcGVyQm91bmQgPSB0b0N1cnJlbnQgKyBkZWx0YTtcbiAgICBsZXQgbmV3RG9tYWluO1xuICAgIGlmIChsb3dlckJvdW5kID4gZnJvbU9yaWdpbmFsICYmIHVwcGVyQm91bmQgPCB0b09yaWdpbmFsKSB7XG4gICAgICBuZXdEb21haW4gPSBbbG93ZXJCb3VuZCwgdXBwZXJCb3VuZF07XG4gICAgfSBlbHNlIGlmIChsb3dlckJvdW5kIDwgZnJvbU9yaWdpbmFsKSB7XG4gICAgICAvLyBDbGFtcCB0byBsb3dlciBsaW1pdFxuICAgICAgY29uc3QgZHggPSB0b0N1cnJlbnQgLSBmcm9tQ3VycmVudDtcbiAgICAgIG5ld0RvbWFpbiA9IFtmcm9tT3JpZ2luYWwsIGZyb21PcmlnaW5hbCArIGR4XTtcbiAgICB9IGVsc2UgaWYgKHVwcGVyQm91bmQgPiB0b09yaWdpbmFsKSB7XG4gICAgICAvLyBDbGFtcCB0byB1cHBlciBsaW1pdFxuICAgICAgY29uc3QgZHggPSB0b0N1cnJlbnQgLSBmcm9tQ3VycmVudDtcbiAgICAgIG5ld0RvbWFpbiA9IFt0b09yaWdpbmFsIC0gZHgsIHRvT3JpZ2luYWxdO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdEb21haW4gPSBjdXJyZW50RG9tYWluO1xuICAgIH1cbiAgICByZXR1cm4gX3ZpY3RvcnlDb3JlLkNvbGxlY3Rpb24uY29udGFpbnNEYXRlcyhjdXJyZW50RG9tYWluKSB8fCBfdmljdG9yeUNvcmUuQ29sbGVjdGlvbi5jb250YWluc0RhdGVzKG9yaWdpbmFsRG9tYWluKSA/IG5ld0RvbWFpbi5tYXAodmFsID0+IG5ldyBEYXRlKHZhbCkpIDogbmV3RG9tYWluO1xuICB9LFxuICBnZXREb21haW5TY2FsZShkb21haW4sIHNjYWxlLCBheGlzKSB7XG4gICAgY29uc3QgYXhpc0RvbWFpbiA9IEFycmF5LmlzQXJyYXkoZG9tYWluKSA/IGRvbWFpbiA6IGRvbWFpbltheGlzXTtcbiAgICBjb25zdCBbZnJvbSwgdG9dID0gYXhpc0RvbWFpbjtcbiAgICBjb25zdCByYW5nZSA9IHNjYWxlW2F4aXNdLnJhbmdlKCk7XG4gICAgY29uc3QgcGxvdHRhYmxlV2lkdGggPSBNYXRoLmFicyhyYW5nZVswXSAtIHJhbmdlWzFdKTtcbiAgICByZXR1cm4gcGxvdHRhYmxlV2lkdGggLyAodG8gLSBmcm9tKTtcbiAgfSxcbiAgaGFuZGxlQW5pbWF0aW9uKGN0eCkge1xuICAgIGNvbnN0IGFuaW1hdGlvblRpbWVyID0gY3R4LmNvbnRleHQuYW5pbWF0aW9uVGltZXI7XG4gICAgY29uc3QgdHJhbnNpdGlvblRpbWVyID0gY3R4LmNvbnRleHQudHJhbnNpdGlvblRpbWVyO1xuICAgIHRyYW5zaXRpb25UaW1lci5ieXBhc3NBbmltYXRpb24oKTtcbiAgICBhbmltYXRpb25UaW1lci5ieXBhc3NBbmltYXRpb24oKTtcbiAgICBjb25zdCByZXN1bWVBbmltYXRpb24gPSAoKSA9PiB7XG4gICAgICBhbmltYXRpb25UaW1lci5yZXN1bWVBbmltYXRpb24oKTtcbiAgICAgIHRyYW5zaXRpb25UaW1lci5yZXN1bWVBbmltYXRpb24oKTtcbiAgICB9O1xuICAgIC8vIGRlbGF5IHRoZSBjYWxsYmFjayB0aGF0IHJlc3VtZXMgYW5pbWF0aW9uIGJ5IH4xIGZyYW1lIHNvIHRoYXQgYW5pbWF0aW9uIGRvZXMgbm90IGludGVyZmVyZSB3aXRoIHdoZWVsIGV2ZW50c1xuICAgIHJldHVybiAoMCwgX2RlbGF5Mi5kZWZhdWx0KShyZXN1bWVBbmltYXRpb24sIDE2KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1tYWdpYy1udW1iZXJzXG4gIH0sXG4gIGdldExhc3REb21haW4odGFyZ2V0UHJvcHMsIG9yaWdpbmFsRG9tYWluKSB7XG4gICAgY29uc3Qge1xuICAgICAgem9vbURvbWFpbixcbiAgICAgIGNhY2hlZFpvb21Eb21haW4sXG4gICAgICBjdXJyZW50RG9tYWluLFxuICAgICAgZG9tYWluXG4gICAgfSA9IHRhcmdldFByb3BzO1xuICAgIGlmICh6b29tRG9tYWluICYmICF0aGlzLmNoZWNrRG9tYWluRXF1YWxpdHkoem9vbURvbWFpbiwgY2FjaGVkWm9vbURvbWFpbikpIHtcbiAgICAgIHJldHVybiAoMCwgX2RlZmF1bHRzMi5kZWZhdWx0KSh7fSwgem9vbURvbWFpbiwgZG9tYWluKTtcbiAgICB9XG4gICAgcmV0dXJuICgwLCBfZGVmYXVsdHMyLmRlZmF1bHQpKHt9LCBjdXJyZW50RG9tYWluIHx8IHpvb21Eb21haW4gfHwgb3JpZ2luYWxEb21haW4sIGRvbWFpbik7XG4gIH0sXG4gIGdldERvbWFpbihwcm9wcykge1xuICAgIGNvbnN0IHtcbiAgICAgIG9yaWdpbmFsRG9tYWluLFxuICAgICAgZG9tYWluLFxuICAgICAgY2hpbGRyZW4sXG4gICAgICB6b29tRGltZW5zaW9uXG4gICAgfSA9IHByb3BzO1xuICAgIGNvbnN0IGNoaWxkQ29tcG9uZW50cyA9IF9yZWFjdC5DaGlsZHJlbi50b0FycmF5KGNoaWxkcmVuKTtcbiAgICBsZXQgY2hpbGRyZW5Eb21haW4gPSB7fTtcbiAgICBpZiAoY2hpbGRDb21wb25lbnRzLmxlbmd0aCkge1xuICAgICAgY2hpbGRyZW5Eb21haW4gPSB6b29tRGltZW5zaW9uID8ge1xuICAgICAgICBbem9vbURpbWVuc2lvbl06IF92aWN0b3J5Q29yZS5XcmFwcGVyLmdldERvbWFpbkZyb21DaGlsZHJlbihwcm9wcywgem9vbURpbWVuc2lvbiwgY2hpbGRDb21wb25lbnRzKVxuICAgICAgfSA6IHtcbiAgICAgICAgeDogX3ZpY3RvcnlDb3JlLldyYXBwZXIuZ2V0RG9tYWluRnJvbUNoaWxkcmVuKHByb3BzLCBcInhcIiwgY2hpbGRDb21wb25lbnRzKSxcbiAgICAgICAgeTogX3ZpY3RvcnlDb3JlLldyYXBwZXIuZ2V0RG9tYWluRnJvbUNoaWxkcmVuKHByb3BzLCBcInlcIiwgY2hpbGRDb21wb25lbnRzKVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuICgwLCBfZGVmYXVsdHMyLmRlZmF1bHQpKHt9LCBjaGlsZHJlbkRvbWFpbiwgb3JpZ2luYWxEb21haW4sIGRvbWFpbik7XG4gIH0sXG4gIG9uTW91c2VEb3duKGV2dCwgdGFyZ2V0UHJvcHMpIHtcbiAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICBpZiAoIXRhcmdldFByb3BzLmFsbG93UGFuKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCBwYXJlbnRTVkcgPSB0YXJnZXRQcm9wcy5wYXJlbnRTVkcgfHwgX3ZpY3RvcnlDb3JlLlNlbGVjdGlvbi5nZXRQYXJlbnRTVkcoZXZ0KTtcbiAgICBjb25zdCB7XG4gICAgICB4LFxuICAgICAgeVxuICAgIH0gPSBfdmljdG9yeUNvcmUuU2VsZWN0aW9uLmdldFNWR0V2ZW50Q29vcmRpbmF0ZXMoZXZ0LCBwYXJlbnRTVkcpO1xuICAgIHJldHVybiBbe1xuICAgICAgdGFyZ2V0OiBcInBhcmVudFwiLFxuICAgICAgbXV0YXRpb246ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdGFydFg6IHgsXG4gICAgICAgICAgc3RhcnRZOiB5LFxuICAgICAgICAgIHBhbm5pbmc6IHRydWUsXG4gICAgICAgICAgcGFyZW50U1ZHLFxuICAgICAgICAgIHBhcmVudENvbnRyb2xsZWRQcm9wczogW1wiZG9tYWluXCJdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfV07XG4gIH0sXG4gIG9uTW91c2VVcChldnQsIHRhcmdldFByb3BzKSB7XG4gICAgaWYgKCF0YXJnZXRQcm9wcy5hbGxvd1Bhbikge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIFt7XG4gICAgICB0YXJnZXQ6IFwicGFyZW50XCIsXG4gICAgICBtdXRhdGlvbjogKCkgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHBhbm5pbmc6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfV07XG4gIH0sXG4gIG9uTW91c2VMZWF2ZShldnQsIHRhcmdldFByb3BzKSB7XG4gICAgaWYgKCF0YXJnZXRQcm9wcy5hbGxvd1Bhbikge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIFt7XG4gICAgICB0YXJnZXQ6IFwicGFyZW50XCIsXG4gICAgICBtdXRhdGlvbjogKCkgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHBhbm5pbmc6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfV07XG4gIH0sXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtcGFyYW1zLCBtYXgtc3RhdGVtZW50c1xuICBvbk1vdXNlTW92ZShldnQsIHRhcmdldFByb3BzLCBldmVudEtleSwgY3R4KSB7XG4gICAgaWYgKHRhcmdldFByb3BzLnBhbm5pbmcgJiYgdGFyZ2V0UHJvcHMuYWxsb3dQYW4pIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc2NhbGUsXG4gICAgICAgIHN0YXJ0WCxcbiAgICAgICAgc3RhcnRZLFxuICAgICAgICBvblpvb21Eb21haW5DaGFuZ2UsXG4gICAgICAgIHpvb21Eb21haW4sXG4gICAgICAgIHpvb21EaW1lbnNpb24sXG4gICAgICAgIGhvcml6b250YWxcbiAgICAgIH0gPSB0YXJnZXRQcm9wcztcbiAgICAgIGNvbnN0IHBhcmVudFNWRyA9IHRhcmdldFByb3BzLnBhcmVudFNWRyB8fCBfdmljdG9yeUNvcmUuU2VsZWN0aW9uLmdldFBhcmVudFNWRyhldnQpO1xuICAgICAgY29uc3Qge1xuICAgICAgICB4LFxuICAgICAgICB5XG4gICAgICB9ID0gX3ZpY3RvcnlDb3JlLlNlbGVjdGlvbi5nZXRTVkdFdmVudENvb3JkaW5hdGVzKGV2dCwgcGFyZW50U1ZHKTtcbiAgICAgIGNvbnN0IG9yaWdpbmFsRG9tYWluID0gdGhpcy5nZXREb21haW4odGFyZ2V0UHJvcHMpO1xuICAgICAgY29uc3QgbGFzdERvbWFpbiA9IHRoaXMuZ2V0TGFzdERvbWFpbih0YXJnZXRQcm9wcywgb3JpZ2luYWxEb21haW4pO1xuICAgICAgY29uc3QgZGVsdGFYID0gaG9yaXpvbnRhbCA/IHkgLSBzdGFydFkgOiBzdGFydFggLSB4O1xuICAgICAgY29uc3QgZGVsdGFZID0gaG9yaXpvbnRhbCA/IHN0YXJ0WCAtIHggOiB5IC0gc3RhcnRZO1xuICAgICAgY29uc3QgZHggPSBkZWx0YVggLyB0aGlzLmdldERvbWFpblNjYWxlKGxhc3REb21haW4sIHNjYWxlLCBcInhcIik7XG4gICAgICBjb25zdCBkeSA9IGRlbHRhWSAvIHRoaXMuZ2V0RG9tYWluU2NhbGUobGFzdERvbWFpbiwgc2NhbGUsIFwieVwiKTtcbiAgICAgIGNvbnN0IGN1cnJlbnREb21haW4gPSB7XG4gICAgICAgIHg6IHpvb21EaW1lbnNpb24gPT09IFwieVwiID8gb3JpZ2luYWxEb21haW4ueCA6IHRoaXMucGFuKGxhc3REb21haW4ueCwgb3JpZ2luYWxEb21haW4ueCwgZHgpLFxuICAgICAgICB5OiB6b29tRGltZW5zaW9uID09PSBcInhcIiA/IG9yaWdpbmFsRG9tYWluLnkgOiB0aGlzLnBhbihsYXN0RG9tYWluLnksIG9yaWdpbmFsRG9tYWluLnksIGR5KVxuICAgICAgfTtcbiAgICAgIGNvbnN0IHJlc3VtZUFuaW1hdGlvbiA9IHRoaXMuaGFuZGxlQW5pbWF0aW9uKGN0eCk7XG4gICAgICBjb25zdCB6b29tQWN0aXZlID0gIXRoaXMuY2hlY2tEb21haW5FcXVhbGl0eShvcmlnaW5hbERvbWFpbiwgbGFzdERvbWFpbik7XG4gICAgICBjb25zdCBtdXRhdGVkUHJvcHMgPSB7XG4gICAgICAgIHBhcmVudENvbnRyb2xsZWRQcm9wczogW1wiZG9tYWluXCJdLFxuICAgICAgICBzdGFydFg6IHgsXG4gICAgICAgIHN0YXJ0WTogeSxcbiAgICAgICAgcGFyZW50U1ZHLFxuICAgICAgICBjdXJyZW50RG9tYWluLFxuICAgICAgICBvcmlnaW5hbERvbWFpbixcbiAgICAgICAgY2FjaGVkWm9vbURvbWFpbjogem9vbURvbWFpbixcbiAgICAgICAgem9vbUFjdGl2ZVxuICAgICAgfTtcbiAgICAgIGlmIChfdmljdG9yeUNvcmUuSGVscGVycy5pc0Z1bmN0aW9uKG9uWm9vbURvbWFpbkNoYW5nZSkpIHtcbiAgICAgICAgb25ab29tRG9tYWluQ2hhbmdlKGN1cnJlbnREb21haW4sICgwLCBfZGVmYXVsdHMyLmRlZmF1bHQpKHt9LCBtdXRhdGVkUHJvcHMsIHRhcmdldFByb3BzKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gW3tcbiAgICAgICAgdGFyZ2V0OiBcInBhcmVudFwiLFxuICAgICAgICBjYWxsYmFjazogcmVzdW1lQW5pbWF0aW9uLFxuICAgICAgICBtdXRhdGlvbjogKCkgPT4gbXV0YXRlZFByb3BzXG4gICAgICB9XTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfSxcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1wYXJhbXNcbiAgb25XaGVlbChldnQsIHRhcmdldFByb3BzLCBldmVudEtleSwgY3R4KSB7XG4gICAgaWYgKCF0YXJnZXRQcm9wcy5hbGxvd1pvb20pIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIG9uWm9vbURvbWFpbkNoYW5nZSxcbiAgICAgIHpvb21EaW1lbnNpb24sXG4gICAgICB6b29tRG9tYWluXG4gICAgfSA9IHRhcmdldFByb3BzO1xuICAgIGNvbnN0IG9yaWdpbmFsRG9tYWluID0gdGhpcy5nZXREb21haW4odGFyZ2V0UHJvcHMpO1xuICAgIGNvbnN0IGxhc3REb21haW4gPSB0aGlzLmdldExhc3REb21haW4odGFyZ2V0UHJvcHMsIG9yaWdpbmFsRG9tYWluKTtcbiAgICBjb25zdCB7XG4gICAgICB4LFxuICAgICAgeVxuICAgIH0gPSBsYXN0RG9tYWluO1xuICAgIGNvbnN0IGN1cnJlbnREb21haW4gPSB7XG4gICAgICB4OiB6b29tRGltZW5zaW9uID09PSBcInlcIiA/IGxhc3REb21haW4ueCA6IHRoaXMuc2NhbGUoeCwgZXZ0LCB0YXJnZXRQcm9wcywgXCJ4XCIpLFxuICAgICAgeTogem9vbURpbWVuc2lvbiA9PT0gXCJ4XCIgPyBsYXN0RG9tYWluLnkgOiB0aGlzLnNjYWxlKHksIGV2dCwgdGFyZ2V0UHJvcHMsIFwieVwiKVxuICAgIH07XG4gICAgY29uc3QgcmVzdW1lQW5pbWF0aW9uID0gdGhpcy5oYW5kbGVBbmltYXRpb24oY3R4KTtcbiAgICBjb25zdCB6b29tQWN0aXZlID0gIXRoaXMuem9vbW1pbmdPdXQoZXZ0KSB8fFxuICAgIC8vIGlmIHpvb21taW5nIGluIG9yXG4gICAgLy8gICBpZiB6b29tQWN0aXZlIGlzIGFscmVhZHkgc2V0IEFORCB1c2VyIGhhc24ndCB6b29tbWVkIG91dCBhbGwgdGhlIHdheVxuICAgIHRhcmdldFByb3BzLnpvb21BY3RpdmUgJiYgIXRoaXMuY2hlY2tEb21haW5FcXVhbGl0eShvcmlnaW5hbERvbWFpbiwgbGFzdERvbWFpbik7XG4gICAgY29uc3QgbXV0YXRlZFByb3BzID0ge1xuICAgICAgY3VycmVudERvbWFpbixcbiAgICAgIG9yaWdpbmFsRG9tYWluLFxuICAgICAgY2FjaGVkWm9vbURvbWFpbjogem9vbURvbWFpbixcbiAgICAgIHBhcmVudENvbnRyb2xsZWRQcm9wczogW1wiZG9tYWluXCJdLFxuICAgICAgcGFubmluZzogZmFsc2UsXG4gICAgICB6b29tQWN0aXZlXG4gICAgfTtcbiAgICBpZiAoX3ZpY3RvcnlDb3JlLkhlbHBlcnMuaXNGdW5jdGlvbihvblpvb21Eb21haW5DaGFuZ2UpKSB7XG4gICAgICBvblpvb21Eb21haW5DaGFuZ2UoY3VycmVudERvbWFpbiwgKDAsIF9kZWZhdWx0czIuZGVmYXVsdCkoe30sIG11dGF0ZWRQcm9wcywgdGFyZ2V0UHJvcHMpKTtcbiAgICB9XG4gICAgcmV0dXJuIFt7XG4gICAgICB0YXJnZXQ6IFwicGFyZW50XCIsXG4gICAgICBjYWxsYmFjazogcmVzdW1lQW5pbWF0aW9uLFxuICAgICAgbXV0YXRpb246ICgpID0+IG11dGF0ZWRQcm9wc1xuICAgIH1dO1xuICB9XG59O1xuY29uc3QgWm9vbUhlbHBlcnMgPSBleHBvcnRzLlpvb21IZWxwZXJzID0ge1xuICBjaGVja0RvbWFpbkVxdWFsaXR5OiBSYXdab29tSGVscGVycy5jaGVja0RvbWFpbkVxdWFsaXR5LmJpbmQoUmF3Wm9vbUhlbHBlcnMpLFxuICBvbk1vdXNlRG93bjogUmF3Wm9vbUhlbHBlcnMub25Nb3VzZURvd24uYmluZChSYXdab29tSGVscGVycyksXG4gIG9uTW91c2VVcDogUmF3Wm9vbUhlbHBlcnMub25Nb3VzZVVwLmJpbmQoUmF3Wm9vbUhlbHBlcnMpLFxuICBvbk1vdXNlTGVhdmU6IFJhd1pvb21IZWxwZXJzLm9uTW91c2VMZWF2ZS5iaW5kKFJhd1pvb21IZWxwZXJzKSxcbiAgb25Nb3VzZU1vdmU6ICgwLCBfdGhyb3R0bGUyLmRlZmF1bHQpKFJhd1pvb21IZWxwZXJzLm9uTW91c2VNb3ZlLmJpbmQoUmF3Wm9vbUhlbHBlcnMpLCAxNixcbiAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1tYWdpYy1udW1iZXJzXG4gIHtcbiAgICBsZWFkaW5nOiB0cnVlLFxuICAgIHRyYWlsaW5nOiBmYWxzZVxuICB9KSxcbiAgb25XaGVlbDogKDAsIF90aHJvdHRsZTIuZGVmYXVsdCkoUmF3Wm9vbUhlbHBlcnMub25XaGVlbC5iaW5kKFJhd1pvb21IZWxwZXJzKSwgMTYsXG4gIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbWFnaWMtbnVtYmVyc1xuICB7XG4gICAgbGVhZGluZzogdHJ1ZSxcbiAgICB0cmFpbGluZzogZmFsc2VcbiAgfSlcbn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/victory-zoom-container/lib/zoom-helpers.js\n");

/***/ })

};
;