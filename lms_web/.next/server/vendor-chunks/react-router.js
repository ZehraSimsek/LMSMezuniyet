/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-router";
exports.ids = ["vendor-chunks/react-router"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-router/dist/main.js":
/*!************************************************!*\
  !*** ./node_modules/react-router/dist/main.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * React Router v6.22.0\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\n\n\n/* eslint-env node */\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./umd/react-router.development.js */ \"(ssr)/./node_modules/react-router/dist/umd/react-router.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2Rpc3QvbWFpbi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUViOztBQUVBLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSx1SkFBNkQ7QUFDL0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90ZW1wLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9kaXN0L21haW4uanM/MDIyNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFJlYWN0IFJvdXRlciB2Ni4yMi4wXG4gKlxuICogQ29weXJpZ2h0IChjKSBSZW1peCBTb2Z0d2FyZSBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFLm1kIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuLyogZXNsaW50LWVudiBub2RlICovXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi91bWQvcmVhY3Qtcm91dGVyLnByb2R1Y3Rpb24ubWluLmpzXCIpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi91bWQvcmVhY3Qtcm91dGVyLmRldmVsb3BtZW50LmpzXCIpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-router/dist/main.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-router/dist/umd/react-router.development.js":
/*!************************************************************************!*\
  !*** ./node_modules/react-router/dist/umd/react-router.development.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("/**\n * React Router v6.22.0\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\n(function (global, factory) {\n   true ? factory(exports, __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"), __webpack_require__(/*! @remix-run/router */ \"(ssr)/./node_modules/@remix-run/router/dist/router.cjs.js\")) :\n  0;\n})(this, (function (exports, React, router) { 'use strict';\n\n  function _interopNamespace(e) {\n    if (e && e.__esModule) return e;\n    var n = Object.create(null);\n    if (e) {\n      Object.keys(e).forEach(function (k) {\n        if (k !== 'default') {\n          var d = Object.getOwnPropertyDescriptor(e, k);\n          Object.defineProperty(n, k, d.get ? d : {\n            enumerable: true,\n            get: function () { return e[k]; }\n          });\n        }\n      });\n    }\n    n[\"default\"] = e;\n    return Object.freeze(n);\n  }\n\n  var React__namespace = /*#__PURE__*/_interopNamespace(React);\n\n  function _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function (target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i];\n        for (var key in source) {\n          if (Object.prototype.hasOwnProperty.call(source, key)) {\n            target[key] = source[key];\n          }\n        }\n      }\n      return target;\n    };\n    return _extends.apply(this, arguments);\n  }\n\n  // Create react-specific types from the agnostic types in @remix-run/router to\n  // export from react-router\n  const DataRouterContext = /*#__PURE__*/React__namespace.createContext(null);\n  {\n    DataRouterContext.displayName = \"DataRouter\";\n  }\n  const DataRouterStateContext = /*#__PURE__*/React__namespace.createContext(null);\n  {\n    DataRouterStateContext.displayName = \"DataRouterState\";\n  }\n  const AwaitContext = /*#__PURE__*/React__namespace.createContext(null);\n  {\n    AwaitContext.displayName = \"Await\";\n  }\n\n  /**\n   * A Navigator is a \"location changer\"; it's how you get to different locations.\n   *\n   * Every history instance conforms to the Navigator interface, but the\n   * distinction is useful primarily when it comes to the low-level `<Router>` API\n   * where both the location and a navigator must be provided separately in order\n   * to avoid \"tearing\" that may occur in a suspense-enabled app if the action\n   * and/or location were to be read directly from the history instance.\n   */\n\n  const NavigationContext = /*#__PURE__*/React__namespace.createContext(null);\n  {\n    NavigationContext.displayName = \"Navigation\";\n  }\n  const LocationContext = /*#__PURE__*/React__namespace.createContext(null);\n  {\n    LocationContext.displayName = \"Location\";\n  }\n  const RouteContext = /*#__PURE__*/React__namespace.createContext({\n    outlet: null,\n    matches: [],\n    isDataRoute: false\n  });\n  {\n    RouteContext.displayName = \"Route\";\n  }\n  const RouteErrorContext = /*#__PURE__*/React__namespace.createContext(null);\n  {\n    RouteErrorContext.displayName = \"RouteError\";\n  }\n\n  /**\n   * Returns the full href for the given \"to\" value. This is useful for building\n   * custom links that are also accessible and preserve right-click behavior.\n   *\n   * @see https://reactrouter.com/hooks/use-href\n   */\n  function useHref(to, _temp) {\n    let {\n      relative\n    } = _temp === void 0 ? {} : _temp;\n    !useInRouterContext() ? router.UNSAFE_invariant(false, // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    \"useHref() may be used only in the context of a <Router> component.\")  : void 0;\n    let {\n      basename,\n      navigator\n    } = React__namespace.useContext(NavigationContext);\n    let {\n      hash,\n      pathname,\n      search\n    } = useResolvedPath(to, {\n      relative\n    });\n    let joinedPathname = pathname;\n\n    // If we're operating within a basename, prepend it to the pathname prior\n    // to creating the href.  If this is a root navigation, then just use the raw\n    // basename which allows the basename to have full control over the presence\n    // of a trailing slash on root links\n    if (basename !== \"/\") {\n      joinedPathname = pathname === \"/\" ? basename : router.joinPaths([basename, pathname]);\n    }\n    return navigator.createHref({\n      pathname: joinedPathname,\n      search,\n      hash\n    });\n  }\n\n  /**\n   * Returns true if this component is a descendant of a `<Router>`.\n   *\n   * @see https://reactrouter.com/hooks/use-in-router-context\n   */\n  function useInRouterContext() {\n    return React__namespace.useContext(LocationContext) != null;\n  }\n\n  /**\n   * Returns the current location object, which represents the current URL in web\n   * browsers.\n   *\n   * Note: If you're using this it may mean you're doing some of your own\n   * \"routing\" in your app, and we'd like to know what your use case is. We may\n   * be able to provide something higher-level to better suit your needs.\n   *\n   * @see https://reactrouter.com/hooks/use-location\n   */\n  function useLocation() {\n    !useInRouterContext() ? router.UNSAFE_invariant(false, // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    \"useLocation() may be used only in the context of a <Router> component.\")  : void 0;\n    return React__namespace.useContext(LocationContext).location;\n  }\n\n  /**\n   * Returns the current navigation action which describes how the router came to\n   * the current location, either by a pop, push, or replace on the history stack.\n   *\n   * @see https://reactrouter.com/hooks/use-navigation-type\n   */\n  function useNavigationType() {\n    return React__namespace.useContext(LocationContext).navigationType;\n  }\n\n  /**\n   * Returns a PathMatch object if the given pattern matches the current URL.\n   * This is useful for components that need to know \"active\" state, e.g.\n   * `<NavLink>`.\n   *\n   * @see https://reactrouter.com/hooks/use-match\n   */\n  function useMatch(pattern) {\n    !useInRouterContext() ? router.UNSAFE_invariant(false, // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    \"useMatch() may be used only in the context of a <Router> component.\")  : void 0;\n    let {\n      pathname\n    } = useLocation();\n    return React__namespace.useMemo(() => router.matchPath(pattern, pathname), [pathname, pattern]);\n  }\n\n  /**\n   * The interface for the navigate() function returned from useNavigate().\n   */\n\n  const navigateEffectWarning = \"You should call navigate() in a React.useEffect(), not when \" + \"your component is first rendered.\";\n\n  // Mute warnings for calls to useNavigate in SSR environments\n  function useIsomorphicLayoutEffect(cb) {\n    let isStatic = React__namespace.useContext(NavigationContext).static;\n    if (!isStatic) {\n      // We should be able to get rid of this once react 18.3 is released\n      // See: https://github.com/facebook/react/pull/26395\n      // eslint-disable-next-line react-hooks/rules-of-hooks\n      React__namespace.useLayoutEffect(cb);\n    }\n  }\n\n  /**\n   * Returns an imperative method for changing the location. Used by `<Link>`s, but\n   * may also be used by other elements to change the location.\n   *\n   * @see https://reactrouter.com/hooks/use-navigate\n   */\n  function useNavigate() {\n    let {\n      isDataRoute\n    } = React__namespace.useContext(RouteContext);\n    // Conditional usage is OK here because the usage of a data router is static\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    return isDataRoute ? useNavigateStable() : useNavigateUnstable();\n  }\n  function useNavigateUnstable() {\n    !useInRouterContext() ? router.UNSAFE_invariant(false, // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    \"useNavigate() may be used only in the context of a <Router> component.\")  : void 0;\n    let dataRouterContext = React__namespace.useContext(DataRouterContext);\n    let {\n      basename,\n      future,\n      navigator\n    } = React__namespace.useContext(NavigationContext);\n    let {\n      matches\n    } = React__namespace.useContext(RouteContext);\n    let {\n      pathname: locationPathname\n    } = useLocation();\n    let routePathnamesJson = JSON.stringify(router.UNSAFE_getResolveToMatches(matches, future.v7_relativeSplatPath));\n    let activeRef = React__namespace.useRef(false);\n    useIsomorphicLayoutEffect(() => {\n      activeRef.current = true;\n    });\n    let navigate = React__namespace.useCallback(function (to, options) {\n      if (options === void 0) {\n        options = {};\n      }\n      router.UNSAFE_warning(activeRef.current, navigateEffectWarning) ;\n\n      // Short circuit here since if this happens on first render the navigate\n      // is useless because we haven't wired up our history listener yet\n      if (!activeRef.current) return;\n      if (typeof to === \"number\") {\n        navigator.go(to);\n        return;\n      }\n      let path = router.resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, options.relative === \"path\");\n\n      // If we're operating within a basename, prepend it to the pathname prior\n      // to handing off to history (but only if we're not in a data router,\n      // otherwise it'll prepend the basename inside of the router).\n      // If this is a root navigation, then we navigate to the raw basename\n      // which allows the basename to have full control over the presence of a\n      // trailing slash on root links\n      if (dataRouterContext == null && basename !== \"/\") {\n        path.pathname = path.pathname === \"/\" ? basename : router.joinPaths([basename, path.pathname]);\n      }\n      (!!options.replace ? navigator.replace : navigator.push)(path, options.state, options);\n    }, [basename, navigator, routePathnamesJson, locationPathname, dataRouterContext]);\n    return navigate;\n  }\n  const OutletContext = /*#__PURE__*/React__namespace.createContext(null);\n\n  /**\n   * Returns the context (if provided) for the child route at this level of the route\n   * hierarchy.\n   * @see https://reactrouter.com/hooks/use-outlet-context\n   */\n  function useOutletContext() {\n    return React__namespace.useContext(OutletContext);\n  }\n\n  /**\n   * Returns the element for the child route at this level of the route\n   * hierarchy. Used internally by `<Outlet>` to render child routes.\n   *\n   * @see https://reactrouter.com/hooks/use-outlet\n   */\n  function useOutlet(context) {\n    let outlet = React__namespace.useContext(RouteContext).outlet;\n    if (outlet) {\n      return /*#__PURE__*/React__namespace.createElement(OutletContext.Provider, {\n        value: context\n      }, outlet);\n    }\n    return outlet;\n  }\n\n  /**\n   * Returns an object of key/value pairs of the dynamic params from the current\n   * URL that were matched by the route path.\n   *\n   * @see https://reactrouter.com/hooks/use-params\n   */\n  function useParams() {\n    let {\n      matches\n    } = React__namespace.useContext(RouteContext);\n    let routeMatch = matches[matches.length - 1];\n    return routeMatch ? routeMatch.params : {};\n  }\n\n  /**\n   * Resolves the pathname of the given `to` value against the current location.\n   *\n   * @see https://reactrouter.com/hooks/use-resolved-path\n   */\n  function useResolvedPath(to, _temp2) {\n    let {\n      relative\n    } = _temp2 === void 0 ? {} : _temp2;\n    let {\n      future\n    } = React__namespace.useContext(NavigationContext);\n    let {\n      matches\n    } = React__namespace.useContext(RouteContext);\n    let {\n      pathname: locationPathname\n    } = useLocation();\n    let routePathnamesJson = JSON.stringify(router.UNSAFE_getResolveToMatches(matches, future.v7_relativeSplatPath));\n    return React__namespace.useMemo(() => router.resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, relative === \"path\"), [to, routePathnamesJson, locationPathname, relative]);\n  }\n\n  /**\n   * Returns the element of the route that matched the current location, prepared\n   * with the correct context to render the remainder of the route tree. Route\n   * elements in the tree must render an `<Outlet>` to render their child route's\n   * element.\n   *\n   * @see https://reactrouter.com/hooks/use-routes\n   */\n  function useRoutes(routes, locationArg) {\n    return useRoutesImpl(routes, locationArg);\n  }\n\n  // Internal implementation with accept optional param for RouterProvider usage\n  function useRoutesImpl(routes, locationArg, dataRouterState, future) {\n    !useInRouterContext() ? router.UNSAFE_invariant(false, // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    \"useRoutes() may be used only in the context of a <Router> component.\")  : void 0;\n    let {\n      navigator\n    } = React__namespace.useContext(NavigationContext);\n    let {\n      matches: parentMatches\n    } = React__namespace.useContext(RouteContext);\n    let routeMatch = parentMatches[parentMatches.length - 1];\n    let parentParams = routeMatch ? routeMatch.params : {};\n    let parentPathname = routeMatch ? routeMatch.pathname : \"/\";\n    let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : \"/\";\n    let parentRoute = routeMatch && routeMatch.route;\n    {\n      // You won't get a warning about 2 different <Routes> under a <Route>\n      // without a trailing *, but this is a best-effort warning anyway since we\n      // cannot even give the warning unless they land at the parent route.\n      //\n      // Example:\n      //\n      // <Routes>\n      //   {/* This route path MUST end with /* because otherwise\n      //       it will never match /blog/post/123 */}\n      //   <Route path=\"blog\" element={<Blog />} />\n      //   <Route path=\"blog/feed\" element={<BlogFeed />} />\n      // </Routes>\n      //\n      // function Blog() {\n      //   return (\n      //     <Routes>\n      //       <Route path=\"post/:id\" element={<Post />} />\n      //     </Routes>\n      //   );\n      // }\n      let parentPath = parentRoute && parentRoute.path || \"\";\n      warningOnce(parentPathname, !parentRoute || parentPath.endsWith(\"*\"), \"You rendered descendant <Routes> (or called `useRoutes()`) at \" + (\"\\\"\" + parentPathname + \"\\\" (under <Route path=\\\"\" + parentPath + \"\\\">) but the \") + \"parent route path has no trailing \\\"*\\\". This means if you navigate \" + \"deeper, the parent won't match anymore and therefore the child \" + \"routes will never render.\\n\\n\" + (\"Please change the parent <Route path=\\\"\" + parentPath + \"\\\"> to <Route \") + (\"path=\\\"\" + (parentPath === \"/\" ? \"*\" : parentPath + \"/*\") + \"\\\">.\"));\n    }\n    let locationFromContext = useLocation();\n    let location;\n    if (locationArg) {\n      var _parsedLocationArg$pa;\n      let parsedLocationArg = typeof locationArg === \"string\" ? router.parsePath(locationArg) : locationArg;\n      !(parentPathnameBase === \"/\" || ((_parsedLocationArg$pa = parsedLocationArg.pathname) == null ? void 0 : _parsedLocationArg$pa.startsWith(parentPathnameBase))) ? router.UNSAFE_invariant(false, \"When overriding the location using `<Routes location>` or `useRoutes(routes, location)`, \" + \"the location pathname must begin with the portion of the URL pathname that was \" + (\"matched by all parent routes. The current pathname base is \\\"\" + parentPathnameBase + \"\\\" \") + (\"but pathname \\\"\" + parsedLocationArg.pathname + \"\\\" was given in the `location` prop.\"))  : void 0;\n      location = parsedLocationArg;\n    } else {\n      location = locationFromContext;\n    }\n    let pathname = location.pathname || \"/\";\n    let remainingPathname = parentPathnameBase === \"/\" ? pathname : pathname.slice(parentPathnameBase.length) || \"/\";\n    let matches = router.matchRoutes(routes, {\n      pathname: remainingPathname\n    });\n    {\n      router.UNSAFE_warning(parentRoute || matches != null, \"No routes matched location \\\"\" + location.pathname + location.search + location.hash + \"\\\" \") ;\n      router.UNSAFE_warning(matches == null || matches[matches.length - 1].route.element !== undefined || matches[matches.length - 1].route.Component !== undefined || matches[matches.length - 1].route.lazy !== undefined, \"Matched leaf route at location \\\"\" + location.pathname + location.search + location.hash + \"\\\" \" + \"does not have an element or Component. This means it will render an <Outlet /> with a \" + \"null value by default resulting in an \\\"empty\\\" page.\") ;\n    }\n    let renderedMatches = _renderMatches(matches && matches.map(match => Object.assign({}, match, {\n      params: Object.assign({}, parentParams, match.params),\n      pathname: router.joinPaths([parentPathnameBase,\n      // Re-encode pathnames that were decoded inside matchRoutes\n      navigator.encodeLocation ? navigator.encodeLocation(match.pathname).pathname : match.pathname]),\n      pathnameBase: match.pathnameBase === \"/\" ? parentPathnameBase : router.joinPaths([parentPathnameBase,\n      // Re-encode pathnames that were decoded inside matchRoutes\n      navigator.encodeLocation ? navigator.encodeLocation(match.pathnameBase).pathname : match.pathnameBase])\n    })), parentMatches, dataRouterState, future);\n\n    // When a user passes in a `locationArg`, the associated routes need to\n    // be wrapped in a new `LocationContext.Provider` in order for `useLocation`\n    // to use the scoped location instead of the global location.\n    if (locationArg && renderedMatches) {\n      return /*#__PURE__*/React__namespace.createElement(LocationContext.Provider, {\n        value: {\n          location: _extends({\n            pathname: \"/\",\n            search: \"\",\n            hash: \"\",\n            state: null,\n            key: \"default\"\n          }, location),\n          navigationType: router.Action.Pop\n        }\n      }, renderedMatches);\n    }\n    return renderedMatches;\n  }\n  function DefaultErrorComponent() {\n    let error = useRouteError();\n    let message = router.isRouteErrorResponse(error) ? error.status + \" \" + error.statusText : error instanceof Error ? error.message : JSON.stringify(error);\n    let stack = error instanceof Error ? error.stack : null;\n    let lightgrey = \"rgba(200,200,200, 0.5)\";\n    let preStyles = {\n      padding: \"0.5rem\",\n      backgroundColor: lightgrey\n    };\n    let codeStyles = {\n      padding: \"2px 4px\",\n      backgroundColor: lightgrey\n    };\n    let devInfo = null;\n    {\n      console.error(\"Error handled by React Router default ErrorBoundary:\", error);\n      devInfo = /*#__PURE__*/React__namespace.createElement(React__namespace.Fragment, null, /*#__PURE__*/React__namespace.createElement(\"p\", null, \"\\uD83D\\uDCBF Hey developer \\uD83D\\uDC4B\"), /*#__PURE__*/React__namespace.createElement(\"p\", null, \"You can provide a way better UX than this when your app throws errors by providing your own \", /*#__PURE__*/React__namespace.createElement(\"code\", {\n        style: codeStyles\n      }, \"ErrorBoundary\"), \" or\", \" \", /*#__PURE__*/React__namespace.createElement(\"code\", {\n        style: codeStyles\n      }, \"errorElement\"), \" prop on your route.\"));\n    }\n    return /*#__PURE__*/React__namespace.createElement(React__namespace.Fragment, null, /*#__PURE__*/React__namespace.createElement(\"h2\", null, \"Unexpected Application Error!\"), /*#__PURE__*/React__namespace.createElement(\"h3\", {\n      style: {\n        fontStyle: \"italic\"\n      }\n    }, message), stack ? /*#__PURE__*/React__namespace.createElement(\"pre\", {\n      style: preStyles\n    }, stack) : null, devInfo);\n  }\n  const defaultErrorElement = /*#__PURE__*/React__namespace.createElement(DefaultErrorComponent, null);\n  class RenderErrorBoundary extends React__namespace.Component {\n    constructor(props) {\n      super(props);\n      this.state = {\n        location: props.location,\n        revalidation: props.revalidation,\n        error: props.error\n      };\n    }\n    static getDerivedStateFromError(error) {\n      return {\n        error: error\n      };\n    }\n    static getDerivedStateFromProps(props, state) {\n      // When we get into an error state, the user will likely click \"back\" to the\n      // previous page that didn't have an error. Because this wraps the entire\n      // application, that will have no effect--the error page continues to display.\n      // This gives us a mechanism to recover from the error when the location changes.\n      //\n      // Whether we're in an error state or not, we update the location in state\n      // so that when we are in an error state, it gets reset when a new location\n      // comes in and the user recovers from the error.\n      if (state.location !== props.location || state.revalidation !== \"idle\" && props.revalidation === \"idle\") {\n        return {\n          error: props.error,\n          location: props.location,\n          revalidation: props.revalidation\n        };\n      }\n\n      // If we're not changing locations, preserve the location but still surface\n      // any new errors that may come through. We retain the existing error, we do\n      // this because the error provided from the app state may be cleared without\n      // the location changing.\n      return {\n        error: props.error !== undefined ? props.error : state.error,\n        location: state.location,\n        revalidation: props.revalidation || state.revalidation\n      };\n    }\n    componentDidCatch(error, errorInfo) {\n      console.error(\"React Router caught the following error during render\", error, errorInfo);\n    }\n    render() {\n      return this.state.error !== undefined ? /*#__PURE__*/React__namespace.createElement(RouteContext.Provider, {\n        value: this.props.routeContext\n      }, /*#__PURE__*/React__namespace.createElement(RouteErrorContext.Provider, {\n        value: this.state.error,\n        children: this.props.component\n      })) : this.props.children;\n    }\n  }\n  function RenderedRoute(_ref) {\n    let {\n      routeContext,\n      match,\n      children\n    } = _ref;\n    let dataRouterContext = React__namespace.useContext(DataRouterContext);\n\n    // Track how deep we got in our render pass to emulate SSR componentDidCatch\n    // in a DataStaticRouter\n    if (dataRouterContext && dataRouterContext.static && dataRouterContext.staticContext && (match.route.errorElement || match.route.ErrorBoundary)) {\n      dataRouterContext.staticContext._deepestRenderedBoundaryId = match.route.id;\n    }\n    return /*#__PURE__*/React__namespace.createElement(RouteContext.Provider, {\n      value: routeContext\n    }, children);\n  }\n  function _renderMatches(matches, parentMatches, dataRouterState, future) {\n    var _dataRouterState2;\n    if (parentMatches === void 0) {\n      parentMatches = [];\n    }\n    if (dataRouterState === void 0) {\n      dataRouterState = null;\n    }\n    if (future === void 0) {\n      future = null;\n    }\n    if (matches == null) {\n      var _dataRouterState;\n      if ((_dataRouterState = dataRouterState) != null && _dataRouterState.errors) {\n        // Don't bail if we have data router errors so we can render them in the\n        // boundary.  Use the pre-matched (or shimmed) matches\n        matches = dataRouterState.matches;\n      } else {\n        return null;\n      }\n    }\n    let renderedMatches = matches;\n\n    // If we have data errors, trim matches to the highest error boundary\n    let errors = (_dataRouterState2 = dataRouterState) == null ? void 0 : _dataRouterState2.errors;\n    if (errors != null) {\n      let errorIndex = renderedMatches.findIndex(m => m.route.id && (errors == null ? void 0 : errors[m.route.id]));\n      !(errorIndex >= 0) ? router.UNSAFE_invariant(false, \"Could not find a matching route for errors on route IDs: \" + Object.keys(errors).join(\",\"))  : void 0;\n      renderedMatches = renderedMatches.slice(0, Math.min(renderedMatches.length, errorIndex + 1));\n    }\n\n    // If we're in a partial hydration mode, detect if we need to render down to\n    // a given HydrateFallback while we load the rest of the hydration data\n    let renderFallback = false;\n    let fallbackIndex = -1;\n    if (dataRouterState && future && future.v7_partialHydration) {\n      for (let i = 0; i < renderedMatches.length; i++) {\n        let match = renderedMatches[i];\n        // Track the deepest fallback up until the first route without data\n        if (match.route.HydrateFallback || match.route.hydrateFallbackElement) {\n          fallbackIndex = i;\n        }\n        if (match.route.id) {\n          let {\n            loaderData,\n            errors\n          } = dataRouterState;\n          let needsToRunLoader = match.route.loader && loaderData[match.route.id] === undefined && (!errors || errors[match.route.id] === undefined);\n          if (match.route.lazy || needsToRunLoader) {\n            // We found the first route that's not ready to render (waiting on\n            // lazy, or has a loader that hasn't run yet).  Flag that we need to\n            // render a fallback and render up until the appropriate fallback\n            renderFallback = true;\n            if (fallbackIndex >= 0) {\n              renderedMatches = renderedMatches.slice(0, fallbackIndex + 1);\n            } else {\n              renderedMatches = [renderedMatches[0]];\n            }\n            break;\n          }\n        }\n      }\n    }\n    return renderedMatches.reduceRight((outlet, match, index) => {\n      // Only data routers handle errors/fallbacks\n      let error;\n      let shouldRenderHydrateFallback = false;\n      let errorElement = null;\n      let hydrateFallbackElement = null;\n      if (dataRouterState) {\n        error = errors && match.route.id ? errors[match.route.id] : undefined;\n        errorElement = match.route.errorElement || defaultErrorElement;\n        if (renderFallback) {\n          if (fallbackIndex < 0 && index === 0) {\n            warningOnce(\"route-fallback\", false, \"No `HydrateFallback` element provided to render during initial hydration\");\n            shouldRenderHydrateFallback = true;\n            hydrateFallbackElement = null;\n          } else if (fallbackIndex === index) {\n            shouldRenderHydrateFallback = true;\n            hydrateFallbackElement = match.route.hydrateFallbackElement || null;\n          }\n        }\n      }\n      let matches = parentMatches.concat(renderedMatches.slice(0, index + 1));\n      let getChildren = () => {\n        let children;\n        if (error) {\n          children = errorElement;\n        } else if (shouldRenderHydrateFallback) {\n          children = hydrateFallbackElement;\n        } else if (match.route.Component) {\n          // Note: This is a de-optimized path since React won't re-use the\n          // ReactElement since it's identity changes with each new\n          // React.createElement call.  We keep this so folks can use\n          // `<Route Component={...}>` in `<Routes>` but generally `Component`\n          // usage is only advised in `RouterProvider` when we can convert it to\n          // `element` ahead of time.\n          children = /*#__PURE__*/React__namespace.createElement(match.route.Component, null);\n        } else if (match.route.element) {\n          children = match.route.element;\n        } else {\n          children = outlet;\n        }\n        return /*#__PURE__*/React__namespace.createElement(RenderedRoute, {\n          match: match,\n          routeContext: {\n            outlet,\n            matches,\n            isDataRoute: dataRouterState != null\n          },\n          children: children\n        });\n      };\n      // Only wrap in an error boundary within data router usages when we have an\n      // ErrorBoundary/errorElement on this route.  Otherwise let it bubble up to\n      // an ancestor ErrorBoundary/errorElement\n      return dataRouterState && (match.route.ErrorBoundary || match.route.errorElement || index === 0) ? /*#__PURE__*/React__namespace.createElement(RenderErrorBoundary, {\n        location: dataRouterState.location,\n        revalidation: dataRouterState.revalidation,\n        component: errorElement,\n        error: error,\n        children: getChildren(),\n        routeContext: {\n          outlet: null,\n          matches,\n          isDataRoute: true\n        }\n      }) : getChildren();\n    }, null);\n  }\n  var DataRouterHook = /*#__PURE__*/function (DataRouterHook) {\n    DataRouterHook[\"UseBlocker\"] = \"useBlocker\";\n    DataRouterHook[\"UseRevalidator\"] = \"useRevalidator\";\n    DataRouterHook[\"UseNavigateStable\"] = \"useNavigate\";\n    return DataRouterHook;\n  }(DataRouterHook || {});\n  var DataRouterStateHook = /*#__PURE__*/function (DataRouterStateHook) {\n    DataRouterStateHook[\"UseBlocker\"] = \"useBlocker\";\n    DataRouterStateHook[\"UseLoaderData\"] = \"useLoaderData\";\n    DataRouterStateHook[\"UseActionData\"] = \"useActionData\";\n    DataRouterStateHook[\"UseRouteError\"] = \"useRouteError\";\n    DataRouterStateHook[\"UseNavigation\"] = \"useNavigation\";\n    DataRouterStateHook[\"UseRouteLoaderData\"] = \"useRouteLoaderData\";\n    DataRouterStateHook[\"UseMatches\"] = \"useMatches\";\n    DataRouterStateHook[\"UseRevalidator\"] = \"useRevalidator\";\n    DataRouterStateHook[\"UseNavigateStable\"] = \"useNavigate\";\n    DataRouterStateHook[\"UseRouteId\"] = \"useRouteId\";\n    return DataRouterStateHook;\n  }(DataRouterStateHook || {});\n  function getDataRouterConsoleError(hookName) {\n    return hookName + \" must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.\";\n  }\n  function useDataRouterContext(hookName) {\n    let ctx = React__namespace.useContext(DataRouterContext);\n    !ctx ? router.UNSAFE_invariant(false, getDataRouterConsoleError(hookName))  : void 0;\n    return ctx;\n  }\n  function useDataRouterState(hookName) {\n    let state = React__namespace.useContext(DataRouterStateContext);\n    !state ? router.UNSAFE_invariant(false, getDataRouterConsoleError(hookName))  : void 0;\n    return state;\n  }\n  function useRouteContext(hookName) {\n    let route = React__namespace.useContext(RouteContext);\n    !route ? router.UNSAFE_invariant(false, getDataRouterConsoleError(hookName))  : void 0;\n    return route;\n  }\n\n  // Internal version with hookName-aware debugging\n  function useCurrentRouteId(hookName) {\n    let route = useRouteContext(hookName);\n    let thisRoute = route.matches[route.matches.length - 1];\n    !thisRoute.route.id ? router.UNSAFE_invariant(false, hookName + \" can only be used on routes that contain a unique \\\"id\\\"\")  : void 0;\n    return thisRoute.route.id;\n  }\n\n  /**\n   * Returns the ID for the nearest contextual route\n   */\n  function useRouteId() {\n    return useCurrentRouteId(DataRouterStateHook.UseRouteId);\n  }\n\n  /**\n   * Returns the current navigation, defaulting to an \"idle\" navigation when\n   * no navigation is in progress\n   */\n  function useNavigation() {\n    let state = useDataRouterState(DataRouterStateHook.UseNavigation);\n    return state.navigation;\n  }\n\n  /**\n   * Returns a revalidate function for manually triggering revalidation, as well\n   * as the current state of any manual revalidations\n   */\n  function useRevalidator() {\n    let dataRouterContext = useDataRouterContext(DataRouterHook.UseRevalidator);\n    let state = useDataRouterState(DataRouterStateHook.UseRevalidator);\n    return React__namespace.useMemo(() => ({\n      revalidate: dataRouterContext.router.revalidate,\n      state: state.revalidation\n    }), [dataRouterContext.router.revalidate, state.revalidation]);\n  }\n\n  /**\n   * Returns the active route matches, useful for accessing loaderData for\n   * parent/child routes or the route \"handle\" property\n   */\n  function useMatches() {\n    let {\n      matches,\n      loaderData\n    } = useDataRouterState(DataRouterStateHook.UseMatches);\n    return React__namespace.useMemo(() => matches.map(m => router.UNSAFE_convertRouteMatchToUiMatch(m, loaderData)), [matches, loaderData]);\n  }\n\n  /**\n   * Returns the loader data for the nearest ancestor Route loader\n   */\n  function useLoaderData() {\n    let state = useDataRouterState(DataRouterStateHook.UseLoaderData);\n    let routeId = useCurrentRouteId(DataRouterStateHook.UseLoaderData);\n    if (state.errors && state.errors[routeId] != null) {\n      console.error(\"You cannot `useLoaderData` in an errorElement (routeId: \" + routeId + \")\");\n      return undefined;\n    }\n    return state.loaderData[routeId];\n  }\n\n  /**\n   * Returns the loaderData for the given routeId\n   */\n  function useRouteLoaderData(routeId) {\n    let state = useDataRouterState(DataRouterStateHook.UseRouteLoaderData);\n    return state.loaderData[routeId];\n  }\n\n  /**\n   * Returns the action data for the nearest ancestor Route action\n   */\n  function useActionData() {\n    let state = useDataRouterState(DataRouterStateHook.UseActionData);\n    let routeId = useCurrentRouteId(DataRouterStateHook.UseLoaderData);\n    return state.actionData ? state.actionData[routeId] : undefined;\n  }\n\n  /**\n   * Returns the nearest ancestor Route error, which could be a loader/action\n   * error or a render error.  This is intended to be called from your\n   * ErrorBoundary/errorElement to display a proper error message.\n   */\n  function useRouteError() {\n    var _state$errors;\n    let error = React__namespace.useContext(RouteErrorContext);\n    let state = useDataRouterState(DataRouterStateHook.UseRouteError);\n    let routeId = useCurrentRouteId(DataRouterStateHook.UseRouteError);\n\n    // If this was a render error, we put it in a RouteError context inside\n    // of RenderErrorBoundary\n    if (error !== undefined) {\n      return error;\n    }\n\n    // Otherwise look for errors from our data router state\n    return (_state$errors = state.errors) == null ? void 0 : _state$errors[routeId];\n  }\n\n  /**\n   * Returns the happy-path data from the nearest ancestor `<Await />` value\n   */\n  function useAsyncValue() {\n    let value = React__namespace.useContext(AwaitContext);\n    return value == null ? void 0 : value._data;\n  }\n\n  /**\n   * Returns the error from the nearest ancestor `<Await />` value\n   */\n  function useAsyncError() {\n    let value = React__namespace.useContext(AwaitContext);\n    return value == null ? void 0 : value._error;\n  }\n  let blockerId = 0;\n\n  /**\n   * Allow the application to block navigations within the SPA and present the\n   * user a confirmation dialog to confirm the navigation.  Mostly used to avoid\n   * using half-filled form data.  This does not handle hard-reloads or\n   * cross-origin navigations.\n   */\n  function useBlocker(shouldBlock) {\n    let {\n      router: router$1,\n      basename\n    } = useDataRouterContext(DataRouterHook.UseBlocker);\n    let state = useDataRouterState(DataRouterStateHook.UseBlocker);\n    let [blockerKey, setBlockerKey] = React__namespace.useState(\"\");\n    let blockerFunction = React__namespace.useCallback(arg => {\n      if (typeof shouldBlock !== \"function\") {\n        return !!shouldBlock;\n      }\n      if (basename === \"/\") {\n        return shouldBlock(arg);\n      }\n\n      // If they provided us a function and we've got an active basename, strip\n      // it from the locations we expose to the user to match the behavior of\n      // useLocation\n      let {\n        currentLocation,\n        nextLocation,\n        historyAction\n      } = arg;\n      return shouldBlock({\n        currentLocation: _extends({}, currentLocation, {\n          pathname: router.stripBasename(currentLocation.pathname, basename) || currentLocation.pathname\n        }),\n        nextLocation: _extends({}, nextLocation, {\n          pathname: router.stripBasename(nextLocation.pathname, basename) || nextLocation.pathname\n        }),\n        historyAction\n      });\n    }, [basename, shouldBlock]);\n\n    // This effect is in charge of blocker key assignment and deletion (which is\n    // tightly coupled to the key)\n    React__namespace.useEffect(() => {\n      let key = String(++blockerId);\n      setBlockerKey(key);\n      return () => router$1.deleteBlocker(key);\n    }, [router$1]);\n\n    // This effect handles assigning the blockerFunction.  This is to handle\n    // unstable blocker function identities, and happens only after the prior\n    // effect so we don't get an orphaned blockerFunction in the router with a\n    // key of \"\".  Until then we just have the IDLE_BLOCKER.\n    React__namespace.useEffect(() => {\n      if (blockerKey !== \"\") {\n        router$1.getBlocker(blockerKey, blockerFunction);\n      }\n    }, [router$1, blockerKey, blockerFunction]);\n\n    // Prefer the blocker from `state` not `router.state` since DataRouterContext\n    // is memoized so this ensures we update on blocker state updates\n    return blockerKey && state.blockers.has(blockerKey) ? state.blockers.get(blockerKey) : router.IDLE_BLOCKER;\n  }\n\n  /**\n   * Stable version of useNavigate that is used when we are in the context of\n   * a RouterProvider.\n   */\n  function useNavigateStable() {\n    let {\n      router: router$1\n    } = useDataRouterContext(DataRouterHook.UseNavigateStable);\n    let id = useCurrentRouteId(DataRouterStateHook.UseNavigateStable);\n    let activeRef = React__namespace.useRef(false);\n    useIsomorphicLayoutEffect(() => {\n      activeRef.current = true;\n    });\n    let navigate = React__namespace.useCallback(function (to, options) {\n      if (options === void 0) {\n        options = {};\n      }\n      router.UNSAFE_warning(activeRef.current, navigateEffectWarning) ;\n\n      // Short circuit here since if this happens on first render the navigate\n      // is useless because we haven't wired up our router subscriber yet\n      if (!activeRef.current) return;\n      if (typeof to === \"number\") {\n        router$1.navigate(to);\n      } else {\n        router$1.navigate(to, _extends({\n          fromRouteId: id\n        }, options));\n      }\n    }, [router$1, id]);\n    return navigate;\n  }\n  const alreadyWarned = {};\n  function warningOnce(key, cond, message) {\n    if (!cond && !alreadyWarned[key]) {\n      alreadyWarned[key] = true;\n      router.UNSAFE_warning(false, message) ;\n    }\n  }\n\n  /**\n    Webpack + React 17 fails to compile on any of the following because webpack\n    complains that `startTransition` doesn't exist in `React`:\n    * import { startTransition } from \"react\"\n    * import * as React from from \"react\";\n      \"startTransition\" in React ? React.startTransition(() => setState()) : setState()\n    * import * as React from from \"react\";\n      \"startTransition\" in React ? React[\"startTransition\"](() => setState()) : setState()\n\n    Moving it to a constant such as the following solves the Webpack/React 17 issue:\n    * import * as React from from \"react\";\n      const START_TRANSITION = \"startTransition\";\n      START_TRANSITION in React ? React[START_TRANSITION](() => setState()) : setState()\n\n    However, that introduces webpack/terser minification issues in production builds\n    in React 18 where minification/obfuscation ends up removing the call of\n    React.startTransition entirely from the first half of the ternary.  Grabbing\n    this exported reference once up front resolves that issue.\n\n    See https://github.com/remix-run/react-router/issues/10579\n  */\n  const START_TRANSITION = \"startTransition\";\n  const startTransitionImpl = React__namespace[START_TRANSITION];\n\n  /**\n   * Given a Remix Router instance, render the appropriate UI\n   */\n  function RouterProvider(_ref) {\n    let {\n      fallbackElement,\n      router: router$1,\n      future\n    } = _ref;\n    let [state, setStateImpl] = React__namespace.useState(router$1.state);\n    let {\n      v7_startTransition\n    } = future || {};\n    let setState = React__namespace.useCallback(newState => {\n      if (v7_startTransition && startTransitionImpl) {\n        startTransitionImpl(() => setStateImpl(newState));\n      } else {\n        setStateImpl(newState);\n      }\n    }, [setStateImpl, v7_startTransition]);\n\n    // Need to use a layout effect here so we are subscribed early enough to\n    // pick up on any render-driven redirects/navigations (useEffect/<Navigate>)\n    React__namespace.useLayoutEffect(() => router$1.subscribe(setState), [router$1, setState]);\n    React__namespace.useEffect(() => {\n      router.UNSAFE_warning(fallbackElement == null || !router$1.future.v7_partialHydration, \"`<RouterProvider fallbackElement>` is deprecated when using \" + \"`v7_partialHydration`, use a `HydrateFallback` component instead\") ;\n      // Only log this once on initial mount\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, []);\n    let navigator = React__namespace.useMemo(() => {\n      return {\n        createHref: router$1.createHref,\n        encodeLocation: router$1.encodeLocation,\n        go: n => router$1.navigate(n),\n        push: (to, state, opts) => router$1.navigate(to, {\n          state,\n          preventScrollReset: opts == null ? void 0 : opts.preventScrollReset\n        }),\n        replace: (to, state, opts) => router$1.navigate(to, {\n          replace: true,\n          state,\n          preventScrollReset: opts == null ? void 0 : opts.preventScrollReset\n        })\n      };\n    }, [router$1]);\n    let basename = router$1.basename || \"/\";\n    let dataRouterContext = React__namespace.useMemo(() => ({\n      router: router$1,\n      navigator,\n      static: false,\n      basename\n    }), [router$1, navigator, basename]);\n\n    // The fragment and {null} here are important!  We need them to keep React 18's\n    // useId happy when we are server-rendering since we may have a <script> here\n    // containing the hydrated server-side staticContext (from StaticRouterProvider).\n    // useId relies on the component tree structure to generate deterministic id's\n    // so we need to ensure it remains the same on the client even though\n    // we don't need the <script> tag\n    return /*#__PURE__*/React__namespace.createElement(React__namespace.Fragment, null, /*#__PURE__*/React__namespace.createElement(DataRouterContext.Provider, {\n      value: dataRouterContext\n    }, /*#__PURE__*/React__namespace.createElement(DataRouterStateContext.Provider, {\n      value: state\n    }, /*#__PURE__*/React__namespace.createElement(Router, {\n      basename: basename,\n      location: state.location,\n      navigationType: state.historyAction,\n      navigator: navigator,\n      future: {\n        v7_relativeSplatPath: router$1.future.v7_relativeSplatPath\n      }\n    }, state.initialized || router$1.future.v7_partialHydration ? /*#__PURE__*/React__namespace.createElement(DataRoutes, {\n      routes: router$1.routes,\n      future: router$1.future,\n      state: state\n    }) : fallbackElement))), null);\n  }\n  function DataRoutes(_ref2) {\n    let {\n      routes,\n      future,\n      state\n    } = _ref2;\n    return useRoutesImpl(routes, undefined, state, future);\n  }\n  /**\n   * A `<Router>` that stores all entries in memory.\n   *\n   * @see https://reactrouter.com/router-components/memory-router\n   */\n  function MemoryRouter(_ref3) {\n    let {\n      basename,\n      children,\n      initialEntries,\n      initialIndex,\n      future\n    } = _ref3;\n    let historyRef = React__namespace.useRef();\n    if (historyRef.current == null) {\n      historyRef.current = router.createMemoryHistory({\n        initialEntries,\n        initialIndex,\n        v5Compat: true\n      });\n    }\n    let history = historyRef.current;\n    let [state, setStateImpl] = React__namespace.useState({\n      action: history.action,\n      location: history.location\n    });\n    let {\n      v7_startTransition\n    } = future || {};\n    let setState = React__namespace.useCallback(newState => {\n      v7_startTransition && startTransitionImpl ? startTransitionImpl(() => setStateImpl(newState)) : setStateImpl(newState);\n    }, [setStateImpl, v7_startTransition]);\n    React__namespace.useLayoutEffect(() => history.listen(setState), [history, setState]);\n    return /*#__PURE__*/React__namespace.createElement(Router, {\n      basename: basename,\n      children: children,\n      location: state.location,\n      navigationType: state.action,\n      navigator: history,\n      future: future\n    });\n  }\n  /**\n   * Changes the current location.\n   *\n   * Note: This API is mostly useful in React.Component subclasses that are not\n   * able to use hooks. In functional components, we recommend you use the\n   * `useNavigate` hook instead.\n   *\n   * @see https://reactrouter.com/components/navigate\n   */\n  function Navigate(_ref4) {\n    let {\n      to,\n      replace,\n      state,\n      relative\n    } = _ref4;\n    !useInRouterContext() ? router.UNSAFE_invariant(false, // TODO: This error is probably because they somehow have 2 versions of\n    // the router loaded. We can help them understand how to avoid that.\n    \"<Navigate> may be used only in the context of a <Router> component.\")  : void 0;\n    let {\n      future,\n      static: isStatic\n    } = React__namespace.useContext(NavigationContext);\n    router.UNSAFE_warning(!isStatic, \"<Navigate> must not be used on the initial render in a <StaticRouter>. \" + \"This is a no-op, but you should modify your code so the <Navigate> is \" + \"only ever rendered in response to some user interaction or state change.\") ;\n    let {\n      matches\n    } = React__namespace.useContext(RouteContext);\n    let {\n      pathname: locationPathname\n    } = useLocation();\n    let navigate = useNavigate();\n\n    // Resolve the path outside of the effect so that when effects run twice in\n    // StrictMode they navigate to the same place\n    let path = router.resolveTo(to, router.UNSAFE_getResolveToMatches(matches, future.v7_relativeSplatPath), locationPathname, relative === \"path\");\n    let jsonPath = JSON.stringify(path);\n    React__namespace.useEffect(() => navigate(JSON.parse(jsonPath), {\n      replace,\n      state,\n      relative\n    }), [navigate, jsonPath, relative, replace, state]);\n    return null;\n  }\n  /**\n   * Renders the child route's element, if there is one.\n   *\n   * @see https://reactrouter.com/components/outlet\n   */\n  function Outlet(props) {\n    return useOutlet(props.context);\n  }\n  /**\n   * Declares an element that should be rendered at a certain URL path.\n   *\n   * @see https://reactrouter.com/components/route\n   */\n  function Route(_props) {\n    router.UNSAFE_invariant(false, \"A <Route> is only ever to be used as the child of <Routes> element, \" + \"never rendered directly. Please wrap your <Route> in a <Routes>.\")  ;\n  }\n  /**\n   * Provides location context for the rest of the app.\n   *\n   * Note: You usually won't render a `<Router>` directly. Instead, you'll render a\n   * router that is more specific to your environment such as a `<BrowserRouter>`\n   * in web browsers or a `<StaticRouter>` for server rendering.\n   *\n   * @see https://reactrouter.com/router-components/router\n   */\n  function Router(_ref5) {\n    let {\n      basename: basenameProp = \"/\",\n      children = null,\n      location: locationProp,\n      navigationType = router.Action.Pop,\n      navigator,\n      static: staticProp = false,\n      future\n    } = _ref5;\n    !!useInRouterContext() ? router.UNSAFE_invariant(false, \"You cannot render a <Router> inside another <Router>.\" + \" You should never have more than one in your app.\")  : void 0;\n\n    // Preserve trailing slashes on basename, so we can let the user control\n    // the enforcement of trailing slashes throughout the app\n    let basename = basenameProp.replace(/^\\/*/, \"/\");\n    let navigationContext = React__namespace.useMemo(() => ({\n      basename,\n      navigator,\n      static: staticProp,\n      future: _extends({\n        v7_relativeSplatPath: false\n      }, future)\n    }), [basename, future, navigator, staticProp]);\n    if (typeof locationProp === \"string\") {\n      locationProp = router.parsePath(locationProp);\n    }\n    let {\n      pathname = \"/\",\n      search = \"\",\n      hash = \"\",\n      state = null,\n      key = \"default\"\n    } = locationProp;\n    let locationContext = React__namespace.useMemo(() => {\n      let trailingPathname = router.stripBasename(pathname, basename);\n      if (trailingPathname == null) {\n        return null;\n      }\n      return {\n        location: {\n          pathname: trailingPathname,\n          search,\n          hash,\n          state,\n          key\n        },\n        navigationType\n      };\n    }, [basename, pathname, search, hash, state, key, navigationType]);\n    router.UNSAFE_warning(locationContext != null, \"<Router basename=\\\"\" + basename + \"\\\"> is not able to match the URL \" + (\"\\\"\" + pathname + search + hash + \"\\\" because it does not start with the \") + \"basename, so the <Router> won't render anything.\") ;\n    if (locationContext == null) {\n      return null;\n    }\n    return /*#__PURE__*/React__namespace.createElement(NavigationContext.Provider, {\n      value: navigationContext\n    }, /*#__PURE__*/React__namespace.createElement(LocationContext.Provider, {\n      children: children,\n      value: locationContext\n    }));\n  }\n  /**\n   * A container for a nested tree of `<Route>` elements that renders the branch\n   * that best matches the current location.\n   *\n   * @see https://reactrouter.com/components/routes\n   */\n  function Routes(_ref6) {\n    let {\n      children,\n      location\n    } = _ref6;\n    return useRoutes(createRoutesFromChildren(children), location);\n  }\n  /**\n   * Component to use for rendering lazily loaded data from returning defer()\n   * in a loader function\n   */\n  function Await(_ref7) {\n    let {\n      children,\n      errorElement,\n      resolve\n    } = _ref7;\n    return /*#__PURE__*/React__namespace.createElement(AwaitErrorBoundary, {\n      resolve: resolve,\n      errorElement: errorElement\n    }, /*#__PURE__*/React__namespace.createElement(ResolveAwait, null, children));\n  }\n  var AwaitRenderStatus = /*#__PURE__*/function (AwaitRenderStatus) {\n    AwaitRenderStatus[AwaitRenderStatus[\"pending\"] = 0] = \"pending\";\n    AwaitRenderStatus[AwaitRenderStatus[\"success\"] = 1] = \"success\";\n    AwaitRenderStatus[AwaitRenderStatus[\"error\"] = 2] = \"error\";\n    return AwaitRenderStatus;\n  }(AwaitRenderStatus || {});\n  const neverSettledPromise = new Promise(() => {});\n  class AwaitErrorBoundary extends React__namespace.Component {\n    constructor(props) {\n      super(props);\n      this.state = {\n        error: null\n      };\n    }\n    static getDerivedStateFromError(error) {\n      return {\n        error\n      };\n    }\n    componentDidCatch(error, errorInfo) {\n      console.error(\"<Await> caught the following error during render\", error, errorInfo);\n    }\n    render() {\n      let {\n        children,\n        errorElement,\n        resolve\n      } = this.props;\n      let promise = null;\n      let status = AwaitRenderStatus.pending;\n      if (!(resolve instanceof Promise)) {\n        // Didn't get a promise - provide as a resolved promise\n        status = AwaitRenderStatus.success;\n        promise = Promise.resolve();\n        Object.defineProperty(promise, \"_tracked\", {\n          get: () => true\n        });\n        Object.defineProperty(promise, \"_data\", {\n          get: () => resolve\n        });\n      } else if (this.state.error) {\n        // Caught a render error, provide it as a rejected promise\n        status = AwaitRenderStatus.error;\n        let renderError = this.state.error;\n        promise = Promise.reject().catch(() => {}); // Avoid unhandled rejection warnings\n        Object.defineProperty(promise, \"_tracked\", {\n          get: () => true\n        });\n        Object.defineProperty(promise, \"_error\", {\n          get: () => renderError\n        });\n      } else if (resolve._tracked) {\n        // Already tracked promise - check contents\n        promise = resolve;\n        status = promise._error !== undefined ? AwaitRenderStatus.error : promise._data !== undefined ? AwaitRenderStatus.success : AwaitRenderStatus.pending;\n      } else {\n        // Raw (untracked) promise - track it\n        status = AwaitRenderStatus.pending;\n        Object.defineProperty(resolve, \"_tracked\", {\n          get: () => true\n        });\n        promise = resolve.then(data => Object.defineProperty(resolve, \"_data\", {\n          get: () => data\n        }), error => Object.defineProperty(resolve, \"_error\", {\n          get: () => error\n        }));\n      }\n      if (status === AwaitRenderStatus.error && promise._error instanceof router.AbortedDeferredError) {\n        // Freeze the UI by throwing a never resolved promise\n        throw neverSettledPromise;\n      }\n      if (status === AwaitRenderStatus.error && !errorElement) {\n        // No errorElement, throw to the nearest route-level error boundary\n        throw promise._error;\n      }\n      if (status === AwaitRenderStatus.error) {\n        // Render via our errorElement\n        return /*#__PURE__*/React__namespace.createElement(AwaitContext.Provider, {\n          value: promise,\n          children: errorElement\n        });\n      }\n      if (status === AwaitRenderStatus.success) {\n        // Render children with resolved value\n        return /*#__PURE__*/React__namespace.createElement(AwaitContext.Provider, {\n          value: promise,\n          children: children\n        });\n      }\n\n      // Throw to the suspense boundary\n      throw promise;\n    }\n  }\n\n  /**\n   * @private\n   * Indirection to leverage useAsyncValue for a render-prop API on `<Await>`\n   */\n  function ResolveAwait(_ref8) {\n    let {\n      children\n    } = _ref8;\n    let data = useAsyncValue();\n    let toRender = typeof children === \"function\" ? children(data) : children;\n    return /*#__PURE__*/React__namespace.createElement(React__namespace.Fragment, null, toRender);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////////\n  // UTILS\n  ///////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * Creates a route config from a React \"children\" object, which is usually\n   * either a `<Route>` element or an array of them. Used internally by\n   * `<Routes>` to create a route config from its children.\n   *\n   * @see https://reactrouter.com/utils/create-routes-from-children\n   */\n  function createRoutesFromChildren(children, parentPath) {\n    if (parentPath === void 0) {\n      parentPath = [];\n    }\n    let routes = [];\n    React__namespace.Children.forEach(children, (element, index) => {\n      if (! /*#__PURE__*/React__namespace.isValidElement(element)) {\n        // Ignore non-elements. This allows people to more easily inline\n        // conditionals in their route config.\n        return;\n      }\n      let treePath = [...parentPath, index];\n      if (element.type === React__namespace.Fragment) {\n        // Transparently support React.Fragment and its children.\n        routes.push.apply(routes, createRoutesFromChildren(element.props.children, treePath));\n        return;\n      }\n      !(element.type === Route) ? router.UNSAFE_invariant(false, \"[\" + (typeof element.type === \"string\" ? element.type : element.type.name) + \"] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>\")  : void 0;\n      !(!element.props.index || !element.props.children) ? router.UNSAFE_invariant(false, \"An index route cannot have child routes.\")  : void 0;\n      let route = {\n        id: element.props.id || treePath.join(\"-\"),\n        caseSensitive: element.props.caseSensitive,\n        element: element.props.element,\n        Component: element.props.Component,\n        index: element.props.index,\n        path: element.props.path,\n        loader: element.props.loader,\n        action: element.props.action,\n        errorElement: element.props.errorElement,\n        ErrorBoundary: element.props.ErrorBoundary,\n        hasErrorBoundary: element.props.ErrorBoundary != null || element.props.errorElement != null,\n        shouldRevalidate: element.props.shouldRevalidate,\n        handle: element.props.handle,\n        lazy: element.props.lazy\n      };\n      if (element.props.children) {\n        route.children = createRoutesFromChildren(element.props.children, treePath);\n      }\n      routes.push(route);\n    });\n    return routes;\n  }\n\n  /**\n   * Renders the result of `matchRoutes()` into a React element.\n   */\n  function renderMatches(matches) {\n    return _renderMatches(matches);\n  }\n\n  function mapRouteProperties(route) {\n    let updates = {\n      // Note: this check also occurs in createRoutesFromChildren so update\n      // there if you change this -- please and thank you!\n      hasErrorBoundary: route.ErrorBoundary != null || route.errorElement != null\n    };\n    if (route.Component) {\n      {\n        if (route.element) {\n          router.UNSAFE_warning(false, \"You should not include both `Component` and `element` on your route - \" + \"`Component` will be used.\") ;\n        }\n      }\n      Object.assign(updates, {\n        element: /*#__PURE__*/React__namespace.createElement(route.Component),\n        Component: undefined\n      });\n    }\n    if (route.HydrateFallback) {\n      {\n        if (route.hydrateFallbackElement) {\n          router.UNSAFE_warning(false, \"You should not include both `HydrateFallback` and `hydrateFallbackElement` on your route - \" + \"`HydrateFallback` will be used.\") ;\n        }\n      }\n      Object.assign(updates, {\n        hydrateFallbackElement: /*#__PURE__*/React__namespace.createElement(route.HydrateFallback),\n        HydrateFallback: undefined\n      });\n    }\n    if (route.ErrorBoundary) {\n      {\n        if (route.errorElement) {\n          router.UNSAFE_warning(false, \"You should not include both `ErrorBoundary` and `errorElement` on your route - \" + \"`ErrorBoundary` will be used.\") ;\n        }\n      }\n      Object.assign(updates, {\n        errorElement: /*#__PURE__*/React__namespace.createElement(route.ErrorBoundary),\n        ErrorBoundary: undefined\n      });\n    }\n    return updates;\n  }\n  function createMemoryRouter(routes, opts) {\n    return router.createRouter({\n      basename: opts == null ? void 0 : opts.basename,\n      future: _extends({}, opts == null ? void 0 : opts.future, {\n        v7_prependBasename: true\n      }),\n      history: router.createMemoryHistory({\n        initialEntries: opts == null ? void 0 : opts.initialEntries,\n        initialIndex: opts == null ? void 0 : opts.initialIndex\n      }),\n      hydrationData: opts == null ? void 0 : opts.hydrationData,\n      routes,\n      mapRouteProperties\n    }).initialize();\n  }\n\n  Object.defineProperty(exports, 'AbortedDeferredError', {\n    enumerable: true,\n    get: function () { return router.AbortedDeferredError; }\n  });\n  Object.defineProperty(exports, 'NavigationType', {\n    enumerable: true,\n    get: function () { return router.Action; }\n  });\n  Object.defineProperty(exports, 'createPath', {\n    enumerable: true,\n    get: function () { return router.createPath; }\n  });\n  Object.defineProperty(exports, 'defer', {\n    enumerable: true,\n    get: function () { return router.defer; }\n  });\n  Object.defineProperty(exports, 'generatePath', {\n    enumerable: true,\n    get: function () { return router.generatePath; }\n  });\n  Object.defineProperty(exports, 'isRouteErrorResponse', {\n    enumerable: true,\n    get: function () { return router.isRouteErrorResponse; }\n  });\n  Object.defineProperty(exports, 'json', {\n    enumerable: true,\n    get: function () { return router.json; }\n  });\n  Object.defineProperty(exports, 'matchPath', {\n    enumerable: true,\n    get: function () { return router.matchPath; }\n  });\n  Object.defineProperty(exports, 'matchRoutes', {\n    enumerable: true,\n    get: function () { return router.matchRoutes; }\n  });\n  Object.defineProperty(exports, 'parsePath', {\n    enumerable: true,\n    get: function () { return router.parsePath; }\n  });\n  Object.defineProperty(exports, 'redirect', {\n    enumerable: true,\n    get: function () { return router.redirect; }\n  });\n  Object.defineProperty(exports, 'redirectDocument', {\n    enumerable: true,\n    get: function () { return router.redirectDocument; }\n  });\n  Object.defineProperty(exports, 'resolvePath', {\n    enumerable: true,\n    get: function () { return router.resolvePath; }\n  });\n  exports.Await = Await;\n  exports.MemoryRouter = MemoryRouter;\n  exports.Navigate = Navigate;\n  exports.Outlet = Outlet;\n  exports.Route = Route;\n  exports.Router = Router;\n  exports.RouterProvider = RouterProvider;\n  exports.Routes = Routes;\n  exports.UNSAFE_DataRouterContext = DataRouterContext;\n  exports.UNSAFE_DataRouterStateContext = DataRouterStateContext;\n  exports.UNSAFE_LocationContext = LocationContext;\n  exports.UNSAFE_NavigationContext = NavigationContext;\n  exports.UNSAFE_RouteContext = RouteContext;\n  exports.UNSAFE_mapRouteProperties = mapRouteProperties;\n  exports.UNSAFE_useRouteId = useRouteId;\n  exports.UNSAFE_useRoutesImpl = useRoutesImpl;\n  exports.createMemoryRouter = createMemoryRouter;\n  exports.createRoutesFromChildren = createRoutesFromChildren;\n  exports.createRoutesFromElements = createRoutesFromChildren;\n  exports.renderMatches = renderMatches;\n  exports.useActionData = useActionData;\n  exports.useAsyncError = useAsyncError;\n  exports.useAsyncValue = useAsyncValue;\n  exports.useBlocker = useBlocker;\n  exports.useHref = useHref;\n  exports.useInRouterContext = useInRouterContext;\n  exports.useLoaderData = useLoaderData;\n  exports.useLocation = useLocation;\n  exports.useMatch = useMatch;\n  exports.useMatches = useMatches;\n  exports.useNavigate = useNavigate;\n  exports.useNavigation = useNavigation;\n  exports.useNavigationType = useNavigationType;\n  exports.useOutlet = useOutlet;\n  exports.useOutletContext = useOutletContext;\n  exports.useParams = useParams;\n  exports.useResolvedPath = useResolvedPath;\n  exports.useRevalidator = useRevalidator;\n  exports.useRouteError = useRouteError;\n  exports.useRouteLoaderData = useRouteLoaderData;\n  exports.useRoutes = useRoutes;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n//# sourceMappingURL=react-router.development.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2Rpc3QvdW1kL3JlYWN0LXJvdXRlci5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxLQUE0RCxvQkFBb0IsbUJBQU8sQ0FBQyx3R0FBTyxHQUFHLG1CQUFPLENBQUMsb0ZBQW1CO0FBQy9ILEVBQUUsQ0FDOEk7QUFDaEosQ0FBQyw2Q0FBNkM7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQixXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQixzQkFBc0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHdCQUF3QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHlCQUF5QjtBQUMvQjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsdUNBQXVDLFVBQVU7QUFDakQsNENBQTRDLGNBQWM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxVQUFVO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlGQUF5RjtBQUN6Riw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsNEJBQTRCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsSUFBSTtBQUNwQztBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcscUJBQXFCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsMEJBQTBCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQSxTQUFTO0FBQ1QsaUNBQWlDO0FBQ2pDO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxrQkFBa0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTCx5QkFBeUIsTUFBTTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyx3QkFBd0I7QUFDM0Isa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsR0FBRztBQUNwRDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixHQUFHO0FBQ0g7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixHQUFHO0FBQ0g7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixHQUFHO0FBQ0g7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixHQUFHO0FBQ0g7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixHQUFHO0FBQ0g7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixHQUFHO0FBQ0g7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixHQUFHO0FBQ0g7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixHQUFHO0FBQ0g7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixHQUFHO0FBQ0g7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixHQUFHO0FBQ0g7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixHQUFHO0FBQ0g7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixHQUFHO0FBQ0g7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpREFBaUQsYUFBYTs7QUFFOUQsQ0FBQztBQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGVtcC8uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvZGlzdC91bWQvcmVhY3Qtcm91dGVyLmRldmVsb3BtZW50LmpzPzdiZTQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBSZWFjdCBSb3V0ZXIgdjYuMjIuMFxuICpcbiAqIENvcHlyaWdodCAoYykgUmVtaXggU29mdHdhcmUgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBsaWNlbnNlIE1JVFxuICovXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMsIHJlcXVpcmUoJ3JlYWN0JyksIHJlcXVpcmUoJ0ByZW1peC1ydW4vcm91dGVyJykpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cycsICdyZWFjdCcsICdAcmVtaXgtcnVuL3JvdXRlciddLCBmYWN0b3J5KSA6XG4gIChnbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogZ2xvYmFsIHx8IHNlbGYsIGZhY3RvcnkoZ2xvYmFsLlJlYWN0Um91dGVyID0ge30sIGdsb2JhbC5SZWFjdCwgZ2xvYmFsLlJlbWl4Um91dGVyKSk7XG59KSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMsIFJlYWN0LCByb3V0ZXIpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIGZ1bmN0aW9uIF9pbnRlcm9wTmFtZXNwYWNlKGUpIHtcbiAgICBpZiAoZSAmJiBlLl9fZXNNb2R1bGUpIHJldHVybiBlO1xuICAgIHZhciBuID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBpZiAoZSkge1xuICAgICAgT2JqZWN0LmtleXMoZSkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgICBpZiAoayAhPT0gJ2RlZmF1bHQnKSB7XG4gICAgICAgICAgdmFyIGQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIGspO1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBrLCBkLmdldCA/IGQgOiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlW2tdOyB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBuW1wiZGVmYXVsdFwiXSA9IGU7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUobik7XG4gIH1cblxuICB2YXIgUmVhY3RfX25hbWVzcGFjZSA9IC8qI19fUFVSRV9fKi9faW50ZXJvcE5hbWVzcGFjZShSZWFjdCk7XG5cbiAgZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gICAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbi5iaW5kKCkgOiBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH07XG4gICAgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICAvLyBDcmVhdGUgcmVhY3Qtc3BlY2lmaWMgdHlwZXMgZnJvbSB0aGUgYWdub3N0aWMgdHlwZXMgaW4gQHJlbWl4LXJ1bi9yb3V0ZXIgdG9cbiAgLy8gZXhwb3J0IGZyb20gcmVhY3Qtcm91dGVyXG4gIGNvbnN0IERhdGFSb3V0ZXJDb250ZXh0ID0gLyojX19QVVJFX18qL1JlYWN0X19uYW1lc3BhY2UuY3JlYXRlQ29udGV4dChudWxsKTtcbiAge1xuICAgIERhdGFSb3V0ZXJDb250ZXh0LmRpc3BsYXlOYW1lID0gXCJEYXRhUm91dGVyXCI7XG4gIH1cbiAgY29uc3QgRGF0YVJvdXRlclN0YXRlQ29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUNvbnRleHQobnVsbCk7XG4gIHtcbiAgICBEYXRhUm91dGVyU3RhdGVDb250ZXh0LmRpc3BsYXlOYW1lID0gXCJEYXRhUm91dGVyU3RhdGVcIjtcbiAgfVxuICBjb25zdCBBd2FpdENvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVDb250ZXh0KG51bGwpO1xuICB7XG4gICAgQXdhaXRDb250ZXh0LmRpc3BsYXlOYW1lID0gXCJBd2FpdFwiO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgTmF2aWdhdG9yIGlzIGEgXCJsb2NhdGlvbiBjaGFuZ2VyXCI7IGl0J3MgaG93IHlvdSBnZXQgdG8gZGlmZmVyZW50IGxvY2F0aW9ucy5cbiAgICpcbiAgICogRXZlcnkgaGlzdG9yeSBpbnN0YW5jZSBjb25mb3JtcyB0byB0aGUgTmF2aWdhdG9yIGludGVyZmFjZSwgYnV0IHRoZVxuICAgKiBkaXN0aW5jdGlvbiBpcyB1c2VmdWwgcHJpbWFyaWx5IHdoZW4gaXQgY29tZXMgdG8gdGhlIGxvdy1sZXZlbCBgPFJvdXRlcj5gIEFQSVxuICAgKiB3aGVyZSBib3RoIHRoZSBsb2NhdGlvbiBhbmQgYSBuYXZpZ2F0b3IgbXVzdCBiZSBwcm92aWRlZCBzZXBhcmF0ZWx5IGluIG9yZGVyXG4gICAqIHRvIGF2b2lkIFwidGVhcmluZ1wiIHRoYXQgbWF5IG9jY3VyIGluIGEgc3VzcGVuc2UtZW5hYmxlZCBhcHAgaWYgdGhlIGFjdGlvblxuICAgKiBhbmQvb3IgbG9jYXRpb24gd2VyZSB0byBiZSByZWFkIGRpcmVjdGx5IGZyb20gdGhlIGhpc3RvcnkgaW5zdGFuY2UuXG4gICAqL1xuXG4gIGNvbnN0IE5hdmlnYXRpb25Db250ZXh0ID0gLyojX19QVVJFX18qL1JlYWN0X19uYW1lc3BhY2UuY3JlYXRlQ29udGV4dChudWxsKTtcbiAge1xuICAgIE5hdmlnYXRpb25Db250ZXh0LmRpc3BsYXlOYW1lID0gXCJOYXZpZ2F0aW9uXCI7XG4gIH1cbiAgY29uc3QgTG9jYXRpb25Db250ZXh0ID0gLyojX19QVVJFX18qL1JlYWN0X19uYW1lc3BhY2UuY3JlYXRlQ29udGV4dChudWxsKTtcbiAge1xuICAgIExvY2F0aW9uQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiTG9jYXRpb25cIjtcbiAgfVxuICBjb25zdCBSb3V0ZUNvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVDb250ZXh0KHtcbiAgICBvdXRsZXQ6IG51bGwsXG4gICAgbWF0Y2hlczogW10sXG4gICAgaXNEYXRhUm91dGU6IGZhbHNlXG4gIH0pO1xuICB7XG4gICAgUm91dGVDb250ZXh0LmRpc3BsYXlOYW1lID0gXCJSb3V0ZVwiO1xuICB9XG4gIGNvbnN0IFJvdXRlRXJyb3JDb250ZXh0ID0gLyojX19QVVJFX18qL1JlYWN0X19uYW1lc3BhY2UuY3JlYXRlQ29udGV4dChudWxsKTtcbiAge1xuICAgIFJvdXRlRXJyb3JDb250ZXh0LmRpc3BsYXlOYW1lID0gXCJSb3V0ZUVycm9yXCI7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZnVsbCBocmVmIGZvciB0aGUgZ2l2ZW4gXCJ0b1wiIHZhbHVlLiBUaGlzIGlzIHVzZWZ1bCBmb3IgYnVpbGRpbmdcbiAgICogY3VzdG9tIGxpbmtzIHRoYXQgYXJlIGFsc28gYWNjZXNzaWJsZSBhbmQgcHJlc2VydmUgcmlnaHQtY2xpY2sgYmVoYXZpb3IuXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vaG9va3MvdXNlLWhyZWZcbiAgICovXG4gIGZ1bmN0aW9uIHVzZUhyZWYodG8sIF90ZW1wKSB7XG4gICAgbGV0IHtcbiAgICAgIHJlbGF0aXZlXG4gICAgfSA9IF90ZW1wID09PSB2b2lkIDAgPyB7fSA6IF90ZW1wO1xuICAgICF1c2VJblJvdXRlckNvbnRleHQoKSA/IHJvdXRlci5VTlNBRkVfaW52YXJpYW50KGZhbHNlLCAvLyBUT0RPOiBUaGlzIGVycm9yIGlzIHByb2JhYmx5IGJlY2F1c2UgdGhleSBzb21laG93IGhhdmUgMiB2ZXJzaW9ucyBvZiB0aGVcbiAgICAvLyByb3V0ZXIgbG9hZGVkLiBXZSBjYW4gaGVscCB0aGVtIHVuZGVyc3RhbmQgaG93IHRvIGF2b2lkIHRoYXQuXG4gICAgXCJ1c2VIcmVmKCkgbWF5IGJlIHVzZWQgb25seSBpbiB0aGUgY29udGV4dCBvZiBhIDxSb3V0ZXI+IGNvbXBvbmVudC5cIikgIDogdm9pZCAwO1xuICAgIGxldCB7XG4gICAgICBiYXNlbmFtZSxcbiAgICAgIG5hdmlnYXRvclxuICAgIH0gPSBSZWFjdF9fbmFtZXNwYWNlLnVzZUNvbnRleHQoTmF2aWdhdGlvbkNvbnRleHQpO1xuICAgIGxldCB7XG4gICAgICBoYXNoLFxuICAgICAgcGF0aG5hbWUsXG4gICAgICBzZWFyY2hcbiAgICB9ID0gdXNlUmVzb2x2ZWRQYXRoKHRvLCB7XG4gICAgICByZWxhdGl2ZVxuICAgIH0pO1xuICAgIGxldCBqb2luZWRQYXRobmFtZSA9IHBhdGhuYW1lO1xuXG4gICAgLy8gSWYgd2UncmUgb3BlcmF0aW5nIHdpdGhpbiBhIGJhc2VuYW1lLCBwcmVwZW5kIGl0IHRvIHRoZSBwYXRobmFtZSBwcmlvclxuICAgIC8vIHRvIGNyZWF0aW5nIHRoZSBocmVmLiAgSWYgdGhpcyBpcyBhIHJvb3QgbmF2aWdhdGlvbiwgdGhlbiBqdXN0IHVzZSB0aGUgcmF3XG4gICAgLy8gYmFzZW5hbWUgd2hpY2ggYWxsb3dzIHRoZSBiYXNlbmFtZSB0byBoYXZlIGZ1bGwgY29udHJvbCBvdmVyIHRoZSBwcmVzZW5jZVxuICAgIC8vIG9mIGEgdHJhaWxpbmcgc2xhc2ggb24gcm9vdCBsaW5rc1xuICAgIGlmIChiYXNlbmFtZSAhPT0gXCIvXCIpIHtcbiAgICAgIGpvaW5lZFBhdGhuYW1lID0gcGF0aG5hbWUgPT09IFwiL1wiID8gYmFzZW5hbWUgOiByb3V0ZXIuam9pblBhdGhzKFtiYXNlbmFtZSwgcGF0aG5hbWVdKTtcbiAgICB9XG4gICAgcmV0dXJuIG5hdmlnYXRvci5jcmVhdGVIcmVmKHtcbiAgICAgIHBhdGhuYW1lOiBqb2luZWRQYXRobmFtZSxcbiAgICAgIHNlYXJjaCxcbiAgICAgIGhhc2hcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBjb21wb25lbnQgaXMgYSBkZXNjZW5kYW50IG9mIGEgYDxSb3V0ZXI+YC5cbiAgICpcbiAgICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9ob29rcy91c2UtaW4tcm91dGVyLWNvbnRleHRcbiAgICovXG4gIGZ1bmN0aW9uIHVzZUluUm91dGVyQ29udGV4dCgpIHtcbiAgICByZXR1cm4gUmVhY3RfX25hbWVzcGFjZS51c2VDb250ZXh0KExvY2F0aW9uQ29udGV4dCkgIT0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGxvY2F0aW9uIG9iamVjdCwgd2hpY2ggcmVwcmVzZW50cyB0aGUgY3VycmVudCBVUkwgaW4gd2ViXG4gICAqIGJyb3dzZXJzLlxuICAgKlxuICAgKiBOb3RlOiBJZiB5b3UncmUgdXNpbmcgdGhpcyBpdCBtYXkgbWVhbiB5b3UncmUgZG9pbmcgc29tZSBvZiB5b3VyIG93blxuICAgKiBcInJvdXRpbmdcIiBpbiB5b3VyIGFwcCwgYW5kIHdlJ2QgbGlrZSB0byBrbm93IHdoYXQgeW91ciB1c2UgY2FzZSBpcy4gV2UgbWF5XG4gICAqIGJlIGFibGUgdG8gcHJvdmlkZSBzb21ldGhpbmcgaGlnaGVyLWxldmVsIHRvIGJldHRlciBzdWl0IHlvdXIgbmVlZHMuXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vaG9va3MvdXNlLWxvY2F0aW9uXG4gICAqL1xuICBmdW5jdGlvbiB1c2VMb2NhdGlvbigpIHtcbiAgICAhdXNlSW5Sb3V0ZXJDb250ZXh0KCkgPyByb3V0ZXIuVU5TQUZFX2ludmFyaWFudChmYWxzZSwgLy8gVE9ETzogVGhpcyBlcnJvciBpcyBwcm9iYWJseSBiZWNhdXNlIHRoZXkgc29tZWhvdyBoYXZlIDIgdmVyc2lvbnMgb2YgdGhlXG4gICAgLy8gcm91dGVyIGxvYWRlZC4gV2UgY2FuIGhlbHAgdGhlbSB1bmRlcnN0YW5kIGhvdyB0byBhdm9pZCB0aGF0LlxuICAgIFwidXNlTG9jYXRpb24oKSBtYXkgYmUgdXNlZCBvbmx5IGluIHRoZSBjb250ZXh0IG9mIGEgPFJvdXRlcj4gY29tcG9uZW50LlwiKSAgOiB2b2lkIDA7XG4gICAgcmV0dXJuIFJlYWN0X19uYW1lc3BhY2UudXNlQ29udGV4dChMb2NhdGlvbkNvbnRleHQpLmxvY2F0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgbmF2aWdhdGlvbiBhY3Rpb24gd2hpY2ggZGVzY3JpYmVzIGhvdyB0aGUgcm91dGVyIGNhbWUgdG9cbiAgICogdGhlIGN1cnJlbnQgbG9jYXRpb24sIGVpdGhlciBieSBhIHBvcCwgcHVzaCwgb3IgcmVwbGFjZSBvbiB0aGUgaGlzdG9yeSBzdGFjay5cbiAgICpcbiAgICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9ob29rcy91c2UtbmF2aWdhdGlvbi10eXBlXG4gICAqL1xuICBmdW5jdGlvbiB1c2VOYXZpZ2F0aW9uVHlwZSgpIHtcbiAgICByZXR1cm4gUmVhY3RfX25hbWVzcGFjZS51c2VDb250ZXh0KExvY2F0aW9uQ29udGV4dCkubmF2aWdhdGlvblR5cGU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIFBhdGhNYXRjaCBvYmplY3QgaWYgdGhlIGdpdmVuIHBhdHRlcm4gbWF0Y2hlcyB0aGUgY3VycmVudCBVUkwuXG4gICAqIFRoaXMgaXMgdXNlZnVsIGZvciBjb21wb25lbnRzIHRoYXQgbmVlZCB0byBrbm93IFwiYWN0aXZlXCIgc3RhdGUsIGUuZy5cbiAgICogYDxOYXZMaW5rPmAuXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vaG9va3MvdXNlLW1hdGNoXG4gICAqL1xuICBmdW5jdGlvbiB1c2VNYXRjaChwYXR0ZXJuKSB7XG4gICAgIXVzZUluUm91dGVyQ29udGV4dCgpID8gcm91dGVyLlVOU0FGRV9pbnZhcmlhbnQoZmFsc2UsIC8vIFRPRE86IFRoaXMgZXJyb3IgaXMgcHJvYmFibHkgYmVjYXVzZSB0aGV5IHNvbWVob3cgaGF2ZSAyIHZlcnNpb25zIG9mIHRoZVxuICAgIC8vIHJvdXRlciBsb2FkZWQuIFdlIGNhbiBoZWxwIHRoZW0gdW5kZXJzdGFuZCBob3cgdG8gYXZvaWQgdGhhdC5cbiAgICBcInVzZU1hdGNoKCkgbWF5IGJlIHVzZWQgb25seSBpbiB0aGUgY29udGV4dCBvZiBhIDxSb3V0ZXI+IGNvbXBvbmVudC5cIikgIDogdm9pZCAwO1xuICAgIGxldCB7XG4gICAgICBwYXRobmFtZVxuICAgIH0gPSB1c2VMb2NhdGlvbigpO1xuICAgIHJldHVybiBSZWFjdF9fbmFtZXNwYWNlLnVzZU1lbW8oKCkgPT4gcm91dGVyLm1hdGNoUGF0aChwYXR0ZXJuLCBwYXRobmFtZSksIFtwYXRobmFtZSwgcGF0dGVybl0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBpbnRlcmZhY2UgZm9yIHRoZSBuYXZpZ2F0ZSgpIGZ1bmN0aW9uIHJldHVybmVkIGZyb20gdXNlTmF2aWdhdGUoKS5cbiAgICovXG5cbiAgY29uc3QgbmF2aWdhdGVFZmZlY3RXYXJuaW5nID0gXCJZb3Ugc2hvdWxkIGNhbGwgbmF2aWdhdGUoKSBpbiBhIFJlYWN0LnVzZUVmZmVjdCgpLCBub3Qgd2hlbiBcIiArIFwieW91ciBjb21wb25lbnQgaXMgZmlyc3QgcmVuZGVyZWQuXCI7XG5cbiAgLy8gTXV0ZSB3YXJuaW5ncyBmb3IgY2FsbHMgdG8gdXNlTmF2aWdhdGUgaW4gU1NSIGVudmlyb25tZW50c1xuICBmdW5jdGlvbiB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGNiKSB7XG4gICAgbGV0IGlzU3RhdGljID0gUmVhY3RfX25hbWVzcGFjZS51c2VDb250ZXh0KE5hdmlnYXRpb25Db250ZXh0KS5zdGF0aWM7XG4gICAgaWYgKCFpc1N0YXRpYykge1xuICAgICAgLy8gV2Ugc2hvdWxkIGJlIGFibGUgdG8gZ2V0IHJpZCBvZiB0aGlzIG9uY2UgcmVhY3QgMTguMyBpcyByZWxlYXNlZFxuICAgICAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8yNjM5NVxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gICAgICBSZWFjdF9fbmFtZXNwYWNlLnVzZUxheW91dEVmZmVjdChjYik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gaW1wZXJhdGl2ZSBtZXRob2QgZm9yIGNoYW5naW5nIHRoZSBsb2NhdGlvbi4gVXNlZCBieSBgPExpbms+YHMsIGJ1dFxuICAgKiBtYXkgYWxzbyBiZSB1c2VkIGJ5IG90aGVyIGVsZW1lbnRzIHRvIGNoYW5nZSB0aGUgbG9jYXRpb24uXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vaG9va3MvdXNlLW5hdmlnYXRlXG4gICAqL1xuICBmdW5jdGlvbiB1c2VOYXZpZ2F0ZSgpIHtcbiAgICBsZXQge1xuICAgICAgaXNEYXRhUm91dGVcbiAgICB9ID0gUmVhY3RfX25hbWVzcGFjZS51c2VDb250ZXh0KFJvdXRlQ29udGV4dCk7XG4gICAgLy8gQ29uZGl0aW9uYWwgdXNhZ2UgaXMgT0sgaGVyZSBiZWNhdXNlIHRoZSB1c2FnZSBvZiBhIGRhdGEgcm91dGVyIGlzIHN0YXRpY1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9ydWxlcy1vZi1ob29rc1xuICAgIHJldHVybiBpc0RhdGFSb3V0ZSA/IHVzZU5hdmlnYXRlU3RhYmxlKCkgOiB1c2VOYXZpZ2F0ZVVuc3RhYmxlKCk7XG4gIH1cbiAgZnVuY3Rpb24gdXNlTmF2aWdhdGVVbnN0YWJsZSgpIHtcbiAgICAhdXNlSW5Sb3V0ZXJDb250ZXh0KCkgPyByb3V0ZXIuVU5TQUZFX2ludmFyaWFudChmYWxzZSwgLy8gVE9ETzogVGhpcyBlcnJvciBpcyBwcm9iYWJseSBiZWNhdXNlIHRoZXkgc29tZWhvdyBoYXZlIDIgdmVyc2lvbnMgb2YgdGhlXG4gICAgLy8gcm91dGVyIGxvYWRlZC4gV2UgY2FuIGhlbHAgdGhlbSB1bmRlcnN0YW5kIGhvdyB0byBhdm9pZCB0aGF0LlxuICAgIFwidXNlTmF2aWdhdGUoKSBtYXkgYmUgdXNlZCBvbmx5IGluIHRoZSBjb250ZXh0IG9mIGEgPFJvdXRlcj4gY29tcG9uZW50LlwiKSAgOiB2b2lkIDA7XG4gICAgbGV0IGRhdGFSb3V0ZXJDb250ZXh0ID0gUmVhY3RfX25hbWVzcGFjZS51c2VDb250ZXh0KERhdGFSb3V0ZXJDb250ZXh0KTtcbiAgICBsZXQge1xuICAgICAgYmFzZW5hbWUsXG4gICAgICBmdXR1cmUsXG4gICAgICBuYXZpZ2F0b3JcbiAgICB9ID0gUmVhY3RfX25hbWVzcGFjZS51c2VDb250ZXh0KE5hdmlnYXRpb25Db250ZXh0KTtcbiAgICBsZXQge1xuICAgICAgbWF0Y2hlc1xuICAgIH0gPSBSZWFjdF9fbmFtZXNwYWNlLnVzZUNvbnRleHQoUm91dGVDb250ZXh0KTtcbiAgICBsZXQge1xuICAgICAgcGF0aG5hbWU6IGxvY2F0aW9uUGF0aG5hbWVcbiAgICB9ID0gdXNlTG9jYXRpb24oKTtcbiAgICBsZXQgcm91dGVQYXRobmFtZXNKc29uID0gSlNPTi5zdHJpbmdpZnkocm91dGVyLlVOU0FGRV9nZXRSZXNvbHZlVG9NYXRjaGVzKG1hdGNoZXMsIGZ1dHVyZS52N19yZWxhdGl2ZVNwbGF0UGF0aCkpO1xuICAgIGxldCBhY3RpdmVSZWYgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVJlZihmYWxzZSk7XG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICBhY3RpdmVSZWYuY3VycmVudCA9IHRydWU7XG4gICAgfSk7XG4gICAgbGV0IG5hdmlnYXRlID0gUmVhY3RfX25hbWVzcGFjZS51c2VDYWxsYmFjayhmdW5jdGlvbiAodG8sIG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgfVxuICAgICAgcm91dGVyLlVOU0FGRV93YXJuaW5nKGFjdGl2ZVJlZi5jdXJyZW50LCBuYXZpZ2F0ZUVmZmVjdFdhcm5pbmcpIDtcblxuICAgICAgLy8gU2hvcnQgY2lyY3VpdCBoZXJlIHNpbmNlIGlmIHRoaXMgaGFwcGVucyBvbiBmaXJzdCByZW5kZXIgdGhlIG5hdmlnYXRlXG4gICAgICAvLyBpcyB1c2VsZXNzIGJlY2F1c2Ugd2UgaGF2ZW4ndCB3aXJlZCB1cCBvdXIgaGlzdG9yeSBsaXN0ZW5lciB5ZXRcbiAgICAgIGlmICghYWN0aXZlUmVmLmN1cnJlbnQpIHJldHVybjtcbiAgICAgIGlmICh0eXBlb2YgdG8gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgbmF2aWdhdG9yLmdvKHRvKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IHBhdGggPSByb3V0ZXIucmVzb2x2ZVRvKHRvLCBKU09OLnBhcnNlKHJvdXRlUGF0aG5hbWVzSnNvbiksIGxvY2F0aW9uUGF0aG5hbWUsIG9wdGlvbnMucmVsYXRpdmUgPT09IFwicGF0aFwiKTtcblxuICAgICAgLy8gSWYgd2UncmUgb3BlcmF0aW5nIHdpdGhpbiBhIGJhc2VuYW1lLCBwcmVwZW5kIGl0IHRvIHRoZSBwYXRobmFtZSBwcmlvclxuICAgICAgLy8gdG8gaGFuZGluZyBvZmYgdG8gaGlzdG9yeSAoYnV0IG9ubHkgaWYgd2UncmUgbm90IGluIGEgZGF0YSByb3V0ZXIsXG4gICAgICAvLyBvdGhlcndpc2UgaXQnbGwgcHJlcGVuZCB0aGUgYmFzZW5hbWUgaW5zaWRlIG9mIHRoZSByb3V0ZXIpLlxuICAgICAgLy8gSWYgdGhpcyBpcyBhIHJvb3QgbmF2aWdhdGlvbiwgdGhlbiB3ZSBuYXZpZ2F0ZSB0byB0aGUgcmF3IGJhc2VuYW1lXG4gICAgICAvLyB3aGljaCBhbGxvd3MgdGhlIGJhc2VuYW1lIHRvIGhhdmUgZnVsbCBjb250cm9sIG92ZXIgdGhlIHByZXNlbmNlIG9mIGFcbiAgICAgIC8vIHRyYWlsaW5nIHNsYXNoIG9uIHJvb3QgbGlua3NcbiAgICAgIGlmIChkYXRhUm91dGVyQ29udGV4dCA9PSBudWxsICYmIGJhc2VuYW1lICE9PSBcIi9cIikge1xuICAgICAgICBwYXRoLnBhdGhuYW1lID0gcGF0aC5wYXRobmFtZSA9PT0gXCIvXCIgPyBiYXNlbmFtZSA6IHJvdXRlci5qb2luUGF0aHMoW2Jhc2VuYW1lLCBwYXRoLnBhdGhuYW1lXSk7XG4gICAgICB9XG4gICAgICAoISFvcHRpb25zLnJlcGxhY2UgPyBuYXZpZ2F0b3IucmVwbGFjZSA6IG5hdmlnYXRvci5wdXNoKShwYXRoLCBvcHRpb25zLnN0YXRlLCBvcHRpb25zKTtcbiAgICB9LCBbYmFzZW5hbWUsIG5hdmlnYXRvciwgcm91dGVQYXRobmFtZXNKc29uLCBsb2NhdGlvblBhdGhuYW1lLCBkYXRhUm91dGVyQ29udGV4dF0pO1xuICAgIHJldHVybiBuYXZpZ2F0ZTtcbiAgfVxuICBjb25zdCBPdXRsZXRDb250ZXh0ID0gLyojX19QVVJFX18qL1JlYWN0X19uYW1lc3BhY2UuY3JlYXRlQ29udGV4dChudWxsKTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY29udGV4dCAoaWYgcHJvdmlkZWQpIGZvciB0aGUgY2hpbGQgcm91dGUgYXQgdGhpcyBsZXZlbCBvZiB0aGUgcm91dGVcbiAgICogaGllcmFyY2h5LlxuICAgKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2hvb2tzL3VzZS1vdXRsZXQtY29udGV4dFxuICAgKi9cbiAgZnVuY3Rpb24gdXNlT3V0bGV0Q29udGV4dCgpIHtcbiAgICByZXR1cm4gUmVhY3RfX25hbWVzcGFjZS51c2VDb250ZXh0KE91dGxldENvbnRleHQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGVsZW1lbnQgZm9yIHRoZSBjaGlsZCByb3V0ZSBhdCB0aGlzIGxldmVsIG9mIHRoZSByb3V0ZVxuICAgKiBoaWVyYXJjaHkuIFVzZWQgaW50ZXJuYWxseSBieSBgPE91dGxldD5gIHRvIHJlbmRlciBjaGlsZCByb3V0ZXMuXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vaG9va3MvdXNlLW91dGxldFxuICAgKi9cbiAgZnVuY3Rpb24gdXNlT3V0bGV0KGNvbnRleHQpIHtcbiAgICBsZXQgb3V0bGV0ID0gUmVhY3RfX25hbWVzcGFjZS51c2VDb250ZXh0KFJvdXRlQ29udGV4dCkub3V0bGV0O1xuICAgIGlmIChvdXRsZXQpIHtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KE91dGxldENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgdmFsdWU6IGNvbnRleHRcbiAgICAgIH0sIG91dGxldCk7XG4gICAgfVxuICAgIHJldHVybiBvdXRsZXQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBvYmplY3Qgb2Yga2V5L3ZhbHVlIHBhaXJzIG9mIHRoZSBkeW5hbWljIHBhcmFtcyBmcm9tIHRoZSBjdXJyZW50XG4gICAqIFVSTCB0aGF0IHdlcmUgbWF0Y2hlZCBieSB0aGUgcm91dGUgcGF0aC5cbiAgICpcbiAgICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9ob29rcy91c2UtcGFyYW1zXG4gICAqL1xuICBmdW5jdGlvbiB1c2VQYXJhbXMoKSB7XG4gICAgbGV0IHtcbiAgICAgIG1hdGNoZXNcbiAgICB9ID0gUmVhY3RfX25hbWVzcGFjZS51c2VDb250ZXh0KFJvdXRlQ29udGV4dCk7XG4gICAgbGV0IHJvdXRlTWF0Y2ggPSBtYXRjaGVzW21hdGNoZXMubGVuZ3RoIC0gMV07XG4gICAgcmV0dXJuIHJvdXRlTWF0Y2ggPyByb3V0ZU1hdGNoLnBhcmFtcyA6IHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc29sdmVzIHRoZSBwYXRobmFtZSBvZiB0aGUgZ2l2ZW4gYHRvYCB2YWx1ZSBhZ2FpbnN0IHRoZSBjdXJyZW50IGxvY2F0aW9uLlxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2hvb2tzL3VzZS1yZXNvbHZlZC1wYXRoXG4gICAqL1xuICBmdW5jdGlvbiB1c2VSZXNvbHZlZFBhdGgodG8sIF90ZW1wMikge1xuICAgIGxldCB7XG4gICAgICByZWxhdGl2ZVxuICAgIH0gPSBfdGVtcDIgPT09IHZvaWQgMCA/IHt9IDogX3RlbXAyO1xuICAgIGxldCB7XG4gICAgICBmdXR1cmVcbiAgICB9ID0gUmVhY3RfX25hbWVzcGFjZS51c2VDb250ZXh0KE5hdmlnYXRpb25Db250ZXh0KTtcbiAgICBsZXQge1xuICAgICAgbWF0Y2hlc1xuICAgIH0gPSBSZWFjdF9fbmFtZXNwYWNlLnVzZUNvbnRleHQoUm91dGVDb250ZXh0KTtcbiAgICBsZXQge1xuICAgICAgcGF0aG5hbWU6IGxvY2F0aW9uUGF0aG5hbWVcbiAgICB9ID0gdXNlTG9jYXRpb24oKTtcbiAgICBsZXQgcm91dGVQYXRobmFtZXNKc29uID0gSlNPTi5zdHJpbmdpZnkocm91dGVyLlVOU0FGRV9nZXRSZXNvbHZlVG9NYXRjaGVzKG1hdGNoZXMsIGZ1dHVyZS52N19yZWxhdGl2ZVNwbGF0UGF0aCkpO1xuICAgIHJldHVybiBSZWFjdF9fbmFtZXNwYWNlLnVzZU1lbW8oKCkgPT4gcm91dGVyLnJlc29sdmVUbyh0bywgSlNPTi5wYXJzZShyb3V0ZVBhdGhuYW1lc0pzb24pLCBsb2NhdGlvblBhdGhuYW1lLCByZWxhdGl2ZSA9PT0gXCJwYXRoXCIpLCBbdG8sIHJvdXRlUGF0aG5hbWVzSnNvbiwgbG9jYXRpb25QYXRobmFtZSwgcmVsYXRpdmVdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBlbGVtZW50IG9mIHRoZSByb3V0ZSB0aGF0IG1hdGNoZWQgdGhlIGN1cnJlbnQgbG9jYXRpb24sIHByZXBhcmVkXG4gICAqIHdpdGggdGhlIGNvcnJlY3QgY29udGV4dCB0byByZW5kZXIgdGhlIHJlbWFpbmRlciBvZiB0aGUgcm91dGUgdHJlZS4gUm91dGVcbiAgICogZWxlbWVudHMgaW4gdGhlIHRyZWUgbXVzdCByZW5kZXIgYW4gYDxPdXRsZXQ+YCB0byByZW5kZXIgdGhlaXIgY2hpbGQgcm91dGUnc1xuICAgKiBlbGVtZW50LlxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2hvb2tzL3VzZS1yb3V0ZXNcbiAgICovXG4gIGZ1bmN0aW9uIHVzZVJvdXRlcyhyb3V0ZXMsIGxvY2F0aW9uQXJnKSB7XG4gICAgcmV0dXJuIHVzZVJvdXRlc0ltcGwocm91dGVzLCBsb2NhdGlvbkFyZyk7XG4gIH1cblxuICAvLyBJbnRlcm5hbCBpbXBsZW1lbnRhdGlvbiB3aXRoIGFjY2VwdCBvcHRpb25hbCBwYXJhbSBmb3IgUm91dGVyUHJvdmlkZXIgdXNhZ2VcbiAgZnVuY3Rpb24gdXNlUm91dGVzSW1wbChyb3V0ZXMsIGxvY2F0aW9uQXJnLCBkYXRhUm91dGVyU3RhdGUsIGZ1dHVyZSkge1xuICAgICF1c2VJblJvdXRlckNvbnRleHQoKSA/IHJvdXRlci5VTlNBRkVfaW52YXJpYW50KGZhbHNlLCAvLyBUT0RPOiBUaGlzIGVycm9yIGlzIHByb2JhYmx5IGJlY2F1c2UgdGhleSBzb21laG93IGhhdmUgMiB2ZXJzaW9ucyBvZiB0aGVcbiAgICAvLyByb3V0ZXIgbG9hZGVkLiBXZSBjYW4gaGVscCB0aGVtIHVuZGVyc3RhbmQgaG93IHRvIGF2b2lkIHRoYXQuXG4gICAgXCJ1c2VSb3V0ZXMoKSBtYXkgYmUgdXNlZCBvbmx5IGluIHRoZSBjb250ZXh0IG9mIGEgPFJvdXRlcj4gY29tcG9uZW50LlwiKSAgOiB2b2lkIDA7XG4gICAgbGV0IHtcbiAgICAgIG5hdmlnYXRvclxuICAgIH0gPSBSZWFjdF9fbmFtZXNwYWNlLnVzZUNvbnRleHQoTmF2aWdhdGlvbkNvbnRleHQpO1xuICAgIGxldCB7XG4gICAgICBtYXRjaGVzOiBwYXJlbnRNYXRjaGVzXG4gICAgfSA9IFJlYWN0X19uYW1lc3BhY2UudXNlQ29udGV4dChSb3V0ZUNvbnRleHQpO1xuICAgIGxldCByb3V0ZU1hdGNoID0gcGFyZW50TWF0Y2hlc1twYXJlbnRNYXRjaGVzLmxlbmd0aCAtIDFdO1xuICAgIGxldCBwYXJlbnRQYXJhbXMgPSByb3V0ZU1hdGNoID8gcm91dGVNYXRjaC5wYXJhbXMgOiB7fTtcbiAgICBsZXQgcGFyZW50UGF0aG5hbWUgPSByb3V0ZU1hdGNoID8gcm91dGVNYXRjaC5wYXRobmFtZSA6IFwiL1wiO1xuICAgIGxldCBwYXJlbnRQYXRobmFtZUJhc2UgPSByb3V0ZU1hdGNoID8gcm91dGVNYXRjaC5wYXRobmFtZUJhc2UgOiBcIi9cIjtcbiAgICBsZXQgcGFyZW50Um91dGUgPSByb3V0ZU1hdGNoICYmIHJvdXRlTWF0Y2gucm91dGU7XG4gICAge1xuICAgICAgLy8gWW91IHdvbid0IGdldCBhIHdhcm5pbmcgYWJvdXQgMiBkaWZmZXJlbnQgPFJvdXRlcz4gdW5kZXIgYSA8Um91dGU+XG4gICAgICAvLyB3aXRob3V0IGEgdHJhaWxpbmcgKiwgYnV0IHRoaXMgaXMgYSBiZXN0LWVmZm9ydCB3YXJuaW5nIGFueXdheSBzaW5jZSB3ZVxuICAgICAgLy8gY2Fubm90IGV2ZW4gZ2l2ZSB0aGUgd2FybmluZyB1bmxlc3MgdGhleSBsYW5kIGF0IHRoZSBwYXJlbnQgcm91dGUuXG4gICAgICAvL1xuICAgICAgLy8gRXhhbXBsZTpcbiAgICAgIC8vXG4gICAgICAvLyA8Um91dGVzPlxuICAgICAgLy8gICB7LyogVGhpcyByb3V0ZSBwYXRoIE1VU1QgZW5kIHdpdGggLyogYmVjYXVzZSBvdGhlcndpc2VcbiAgICAgIC8vICAgICAgIGl0IHdpbGwgbmV2ZXIgbWF0Y2ggL2Jsb2cvcG9zdC8xMjMgKi99XG4gICAgICAvLyAgIDxSb3V0ZSBwYXRoPVwiYmxvZ1wiIGVsZW1lbnQ9ezxCbG9nIC8+fSAvPlxuICAgICAgLy8gICA8Um91dGUgcGF0aD1cImJsb2cvZmVlZFwiIGVsZW1lbnQ9ezxCbG9nRmVlZCAvPn0gLz5cbiAgICAgIC8vIDwvUm91dGVzPlxuICAgICAgLy9cbiAgICAgIC8vIGZ1bmN0aW9uIEJsb2coKSB7XG4gICAgICAvLyAgIHJldHVybiAoXG4gICAgICAvLyAgICAgPFJvdXRlcz5cbiAgICAgIC8vICAgICAgIDxSb3V0ZSBwYXRoPVwicG9zdC86aWRcIiBlbGVtZW50PXs8UG9zdCAvPn0gLz5cbiAgICAgIC8vICAgICA8L1JvdXRlcz5cbiAgICAgIC8vICAgKTtcbiAgICAgIC8vIH1cbiAgICAgIGxldCBwYXJlbnRQYXRoID0gcGFyZW50Um91dGUgJiYgcGFyZW50Um91dGUucGF0aCB8fCBcIlwiO1xuICAgICAgd2FybmluZ09uY2UocGFyZW50UGF0aG5hbWUsICFwYXJlbnRSb3V0ZSB8fCBwYXJlbnRQYXRoLmVuZHNXaXRoKFwiKlwiKSwgXCJZb3UgcmVuZGVyZWQgZGVzY2VuZGFudCA8Um91dGVzPiAob3IgY2FsbGVkIGB1c2VSb3V0ZXMoKWApIGF0IFwiICsgKFwiXFxcIlwiICsgcGFyZW50UGF0aG5hbWUgKyBcIlxcXCIgKHVuZGVyIDxSb3V0ZSBwYXRoPVxcXCJcIiArIHBhcmVudFBhdGggKyBcIlxcXCI+KSBidXQgdGhlIFwiKSArIFwicGFyZW50IHJvdXRlIHBhdGggaGFzIG5vIHRyYWlsaW5nIFxcXCIqXFxcIi4gVGhpcyBtZWFucyBpZiB5b3UgbmF2aWdhdGUgXCIgKyBcImRlZXBlciwgdGhlIHBhcmVudCB3b24ndCBtYXRjaCBhbnltb3JlIGFuZCB0aGVyZWZvcmUgdGhlIGNoaWxkIFwiICsgXCJyb3V0ZXMgd2lsbCBuZXZlciByZW5kZXIuXFxuXFxuXCIgKyAoXCJQbGVhc2UgY2hhbmdlIHRoZSBwYXJlbnQgPFJvdXRlIHBhdGg9XFxcIlwiICsgcGFyZW50UGF0aCArIFwiXFxcIj4gdG8gPFJvdXRlIFwiKSArIChcInBhdGg9XFxcIlwiICsgKHBhcmVudFBhdGggPT09IFwiL1wiID8gXCIqXCIgOiBwYXJlbnRQYXRoICsgXCIvKlwiKSArIFwiXFxcIj4uXCIpKTtcbiAgICB9XG4gICAgbGV0IGxvY2F0aW9uRnJvbUNvbnRleHQgPSB1c2VMb2NhdGlvbigpO1xuICAgIGxldCBsb2NhdGlvbjtcbiAgICBpZiAobG9jYXRpb25BcmcpIHtcbiAgICAgIHZhciBfcGFyc2VkTG9jYXRpb25BcmckcGE7XG4gICAgICBsZXQgcGFyc2VkTG9jYXRpb25BcmcgPSB0eXBlb2YgbG9jYXRpb25BcmcgPT09IFwic3RyaW5nXCIgPyByb3V0ZXIucGFyc2VQYXRoKGxvY2F0aW9uQXJnKSA6IGxvY2F0aW9uQXJnO1xuICAgICAgIShwYXJlbnRQYXRobmFtZUJhc2UgPT09IFwiL1wiIHx8ICgoX3BhcnNlZExvY2F0aW9uQXJnJHBhID0gcGFyc2VkTG9jYXRpb25BcmcucGF0aG5hbWUpID09IG51bGwgPyB2b2lkIDAgOiBfcGFyc2VkTG9jYXRpb25BcmckcGEuc3RhcnRzV2l0aChwYXJlbnRQYXRobmFtZUJhc2UpKSkgPyByb3V0ZXIuVU5TQUZFX2ludmFyaWFudChmYWxzZSwgXCJXaGVuIG92ZXJyaWRpbmcgdGhlIGxvY2F0aW9uIHVzaW5nIGA8Um91dGVzIGxvY2F0aW9uPmAgb3IgYHVzZVJvdXRlcyhyb3V0ZXMsIGxvY2F0aW9uKWAsIFwiICsgXCJ0aGUgbG9jYXRpb24gcGF0aG5hbWUgbXVzdCBiZWdpbiB3aXRoIHRoZSBwb3J0aW9uIG9mIHRoZSBVUkwgcGF0aG5hbWUgdGhhdCB3YXMgXCIgKyAoXCJtYXRjaGVkIGJ5IGFsbCBwYXJlbnQgcm91dGVzLiBUaGUgY3VycmVudCBwYXRobmFtZSBiYXNlIGlzIFxcXCJcIiArIHBhcmVudFBhdGhuYW1lQmFzZSArIFwiXFxcIiBcIikgKyAoXCJidXQgcGF0aG5hbWUgXFxcIlwiICsgcGFyc2VkTG9jYXRpb25BcmcucGF0aG5hbWUgKyBcIlxcXCIgd2FzIGdpdmVuIGluIHRoZSBgbG9jYXRpb25gIHByb3AuXCIpKSAgOiB2b2lkIDA7XG4gICAgICBsb2NhdGlvbiA9IHBhcnNlZExvY2F0aW9uQXJnO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2NhdGlvbiA9IGxvY2F0aW9uRnJvbUNvbnRleHQ7XG4gICAgfVxuICAgIGxldCBwYXRobmFtZSA9IGxvY2F0aW9uLnBhdGhuYW1lIHx8IFwiL1wiO1xuICAgIGxldCByZW1haW5pbmdQYXRobmFtZSA9IHBhcmVudFBhdGhuYW1lQmFzZSA9PT0gXCIvXCIgPyBwYXRobmFtZSA6IHBhdGhuYW1lLnNsaWNlKHBhcmVudFBhdGhuYW1lQmFzZS5sZW5ndGgpIHx8IFwiL1wiO1xuICAgIGxldCBtYXRjaGVzID0gcm91dGVyLm1hdGNoUm91dGVzKHJvdXRlcywge1xuICAgICAgcGF0aG5hbWU6IHJlbWFpbmluZ1BhdGhuYW1lXG4gICAgfSk7XG4gICAge1xuICAgICAgcm91dGVyLlVOU0FGRV93YXJuaW5nKHBhcmVudFJvdXRlIHx8IG1hdGNoZXMgIT0gbnVsbCwgXCJObyByb3V0ZXMgbWF0Y2hlZCBsb2NhdGlvbiBcXFwiXCIgKyBsb2NhdGlvbi5wYXRobmFtZSArIGxvY2F0aW9uLnNlYXJjaCArIGxvY2F0aW9uLmhhc2ggKyBcIlxcXCIgXCIpIDtcbiAgICAgIHJvdXRlci5VTlNBRkVfd2FybmluZyhtYXRjaGVzID09IG51bGwgfHwgbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdLnJvdXRlLmVsZW1lbnQgIT09IHVuZGVmaW5lZCB8fCBtYXRjaGVzW21hdGNoZXMubGVuZ3RoIC0gMV0ucm91dGUuQ29tcG9uZW50ICE9PSB1bmRlZmluZWQgfHwgbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdLnJvdXRlLmxhenkgIT09IHVuZGVmaW5lZCwgXCJNYXRjaGVkIGxlYWYgcm91dGUgYXQgbG9jYXRpb24gXFxcIlwiICsgbG9jYXRpb24ucGF0aG5hbWUgKyBsb2NhdGlvbi5zZWFyY2ggKyBsb2NhdGlvbi5oYXNoICsgXCJcXFwiIFwiICsgXCJkb2VzIG5vdCBoYXZlIGFuIGVsZW1lbnQgb3IgQ29tcG9uZW50LiBUaGlzIG1lYW5zIGl0IHdpbGwgcmVuZGVyIGFuIDxPdXRsZXQgLz4gd2l0aCBhIFwiICsgXCJudWxsIHZhbHVlIGJ5IGRlZmF1bHQgcmVzdWx0aW5nIGluIGFuIFxcXCJlbXB0eVxcXCIgcGFnZS5cIikgO1xuICAgIH1cbiAgICBsZXQgcmVuZGVyZWRNYXRjaGVzID0gX3JlbmRlck1hdGNoZXMobWF0Y2hlcyAmJiBtYXRjaGVzLm1hcChtYXRjaCA9PiBPYmplY3QuYXNzaWduKHt9LCBtYXRjaCwge1xuICAgICAgcGFyYW1zOiBPYmplY3QuYXNzaWduKHt9LCBwYXJlbnRQYXJhbXMsIG1hdGNoLnBhcmFtcyksXG4gICAgICBwYXRobmFtZTogcm91dGVyLmpvaW5QYXRocyhbcGFyZW50UGF0aG5hbWVCYXNlLFxuICAgICAgLy8gUmUtZW5jb2RlIHBhdGhuYW1lcyB0aGF0IHdlcmUgZGVjb2RlZCBpbnNpZGUgbWF0Y2hSb3V0ZXNcbiAgICAgIG5hdmlnYXRvci5lbmNvZGVMb2NhdGlvbiA/IG5hdmlnYXRvci5lbmNvZGVMb2NhdGlvbihtYXRjaC5wYXRobmFtZSkucGF0aG5hbWUgOiBtYXRjaC5wYXRobmFtZV0pLFxuICAgICAgcGF0aG5hbWVCYXNlOiBtYXRjaC5wYXRobmFtZUJhc2UgPT09IFwiL1wiID8gcGFyZW50UGF0aG5hbWVCYXNlIDogcm91dGVyLmpvaW5QYXRocyhbcGFyZW50UGF0aG5hbWVCYXNlLFxuICAgICAgLy8gUmUtZW5jb2RlIHBhdGhuYW1lcyB0aGF0IHdlcmUgZGVjb2RlZCBpbnNpZGUgbWF0Y2hSb3V0ZXNcbiAgICAgIG5hdmlnYXRvci5lbmNvZGVMb2NhdGlvbiA/IG5hdmlnYXRvci5lbmNvZGVMb2NhdGlvbihtYXRjaC5wYXRobmFtZUJhc2UpLnBhdGhuYW1lIDogbWF0Y2gucGF0aG5hbWVCYXNlXSlcbiAgICB9KSksIHBhcmVudE1hdGNoZXMsIGRhdGFSb3V0ZXJTdGF0ZSwgZnV0dXJlKTtcblxuICAgIC8vIFdoZW4gYSB1c2VyIHBhc3NlcyBpbiBhIGBsb2NhdGlvbkFyZ2AsIHRoZSBhc3NvY2lhdGVkIHJvdXRlcyBuZWVkIHRvXG4gICAgLy8gYmUgd3JhcHBlZCBpbiBhIG5ldyBgTG9jYXRpb25Db250ZXh0LlByb3ZpZGVyYCBpbiBvcmRlciBmb3IgYHVzZUxvY2F0aW9uYFxuICAgIC8vIHRvIHVzZSB0aGUgc2NvcGVkIGxvY2F0aW9uIGluc3RlYWQgb2YgdGhlIGdsb2JhbCBsb2NhdGlvbi5cbiAgICBpZiAobG9jYXRpb25BcmcgJiYgcmVuZGVyZWRNYXRjaGVzKSB7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChMb2NhdGlvbkNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICBsb2NhdGlvbjogX2V4dGVuZHMoe1xuICAgICAgICAgICAgcGF0aG5hbWU6IFwiL1wiLFxuICAgICAgICAgICAgc2VhcmNoOiBcIlwiLFxuICAgICAgICAgICAgaGFzaDogXCJcIixcbiAgICAgICAgICAgIHN0YXRlOiBudWxsLFxuICAgICAgICAgICAga2V5OiBcImRlZmF1bHRcIlxuICAgICAgICAgIH0sIGxvY2F0aW9uKSxcbiAgICAgICAgICBuYXZpZ2F0aW9uVHlwZTogcm91dGVyLkFjdGlvbi5Qb3BcbiAgICAgICAgfVxuICAgICAgfSwgcmVuZGVyZWRNYXRjaGVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlbmRlcmVkTWF0Y2hlcztcbiAgfVxuICBmdW5jdGlvbiBEZWZhdWx0RXJyb3JDb21wb25lbnQoKSB7XG4gICAgbGV0IGVycm9yID0gdXNlUm91dGVFcnJvcigpO1xuICAgIGxldCBtZXNzYWdlID0gcm91dGVyLmlzUm91dGVFcnJvclJlc3BvbnNlKGVycm9yKSA/IGVycm9yLnN0YXR1cyArIFwiIFwiICsgZXJyb3Iuc3RhdHVzVGV4dCA6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogSlNPTi5zdHJpbmdpZnkoZXJyb3IpO1xuICAgIGxldCBzdGFjayA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5zdGFjayA6IG51bGw7XG4gICAgbGV0IGxpZ2h0Z3JleSA9IFwicmdiYSgyMDAsMjAwLDIwMCwgMC41KVwiO1xuICAgIGxldCBwcmVTdHlsZXMgPSB7XG4gICAgICBwYWRkaW5nOiBcIjAuNXJlbVwiLFxuICAgICAgYmFja2dyb3VuZENvbG9yOiBsaWdodGdyZXlcbiAgICB9O1xuICAgIGxldCBjb2RlU3R5bGVzID0ge1xuICAgICAgcGFkZGluZzogXCIycHggNHB4XCIsXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6IGxpZ2h0Z3JleVxuICAgIH07XG4gICAgbGV0IGRldkluZm8gPSBudWxsO1xuICAgIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBoYW5kbGVkIGJ5IFJlYWN0IFJvdXRlciBkZWZhdWx0IEVycm9yQm91bmRhcnk6XCIsIGVycm9yKTtcbiAgICAgIGRldkluZm8gPSAvKiNfX1BVUkVfXyovUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFJlYWN0X19uYW1lc3BhY2UuRnJhZ21lbnQsIG51bGwsIC8qI19fUFVSRV9fKi9SZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJwXCIsIG51bGwsIFwiXFx1RDgzRFxcdURDQkYgSGV5IGRldmVsb3BlciBcXHVEODNEXFx1REM0QlwiKSwgLyojX19QVVJFX18qL1JlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcInBcIiwgbnVsbCwgXCJZb3UgY2FuIHByb3ZpZGUgYSB3YXkgYmV0dGVyIFVYIHRoYW4gdGhpcyB3aGVuIHlvdXIgYXBwIHRocm93cyBlcnJvcnMgYnkgcHJvdmlkaW5nIHlvdXIgb3duIFwiLCAvKiNfX1BVUkVfXyovUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwiY29kZVwiLCB7XG4gICAgICAgIHN0eWxlOiBjb2RlU3R5bGVzXG4gICAgICB9LCBcIkVycm9yQm91bmRhcnlcIiksIFwiIG9yXCIsIFwiIFwiLCAvKiNfX1BVUkVfXyovUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwiY29kZVwiLCB7XG4gICAgICAgIHN0eWxlOiBjb2RlU3R5bGVzXG4gICAgICB9LCBcImVycm9yRWxlbWVudFwiKSwgXCIgcHJvcCBvbiB5b3VyIHJvdXRlLlwiKSk7XG4gICAgfVxuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFJlYWN0X19uYW1lc3BhY2UuRnJhZ21lbnQsIG51bGwsIC8qI19fUFVSRV9fKi9SZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJoMlwiLCBudWxsLCBcIlVuZXhwZWN0ZWQgQXBwbGljYXRpb24gRXJyb3IhXCIpLCAvKiNfX1BVUkVfXyovUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwiaDNcIiwge1xuICAgICAgc3R5bGU6IHtcbiAgICAgICAgZm9udFN0eWxlOiBcIml0YWxpY1wiXG4gICAgICB9XG4gICAgfSwgbWVzc2FnZSksIHN0YWNrID8gLyojX19QVVJFX18qL1JlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcInByZVwiLCB7XG4gICAgICBzdHlsZTogcHJlU3R5bGVzXG4gICAgfSwgc3RhY2spIDogbnVsbCwgZGV2SW5mbyk7XG4gIH1cbiAgY29uc3QgZGVmYXVsdEVycm9yRWxlbWVudCA9IC8qI19fUFVSRV9fKi9SZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoRGVmYXVsdEVycm9yQ29tcG9uZW50LCBudWxsKTtcbiAgY2xhc3MgUmVuZGVyRXJyb3JCb3VuZGFyeSBleHRlbmRzIFJlYWN0X19uYW1lc3BhY2UuQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgc3VwZXIocHJvcHMpO1xuICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgbG9jYXRpb246IHByb3BzLmxvY2F0aW9uLFxuICAgICAgICByZXZhbGlkYXRpb246IHByb3BzLnJldmFsaWRhdGlvbixcbiAgICAgICAgZXJyb3I6IHByb3BzLmVycm9yXG4gICAgICB9O1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKGVycm9yKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBlcnJvcjogZXJyb3JcbiAgICAgIH07XG4gICAgfVxuICAgIHN0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMocHJvcHMsIHN0YXRlKSB7XG4gICAgICAvLyBXaGVuIHdlIGdldCBpbnRvIGFuIGVycm9yIHN0YXRlLCB0aGUgdXNlciB3aWxsIGxpa2VseSBjbGljayBcImJhY2tcIiB0byB0aGVcbiAgICAgIC8vIHByZXZpb3VzIHBhZ2UgdGhhdCBkaWRuJ3QgaGF2ZSBhbiBlcnJvci4gQmVjYXVzZSB0aGlzIHdyYXBzIHRoZSBlbnRpcmVcbiAgICAgIC8vIGFwcGxpY2F0aW9uLCB0aGF0IHdpbGwgaGF2ZSBubyBlZmZlY3QtLXRoZSBlcnJvciBwYWdlIGNvbnRpbnVlcyB0byBkaXNwbGF5LlxuICAgICAgLy8gVGhpcyBnaXZlcyB1cyBhIG1lY2hhbmlzbSB0byByZWNvdmVyIGZyb20gdGhlIGVycm9yIHdoZW4gdGhlIGxvY2F0aW9uIGNoYW5nZXMuXG4gICAgICAvL1xuICAgICAgLy8gV2hldGhlciB3ZSdyZSBpbiBhbiBlcnJvciBzdGF0ZSBvciBub3QsIHdlIHVwZGF0ZSB0aGUgbG9jYXRpb24gaW4gc3RhdGVcbiAgICAgIC8vIHNvIHRoYXQgd2hlbiB3ZSBhcmUgaW4gYW4gZXJyb3Igc3RhdGUsIGl0IGdldHMgcmVzZXQgd2hlbiBhIG5ldyBsb2NhdGlvblxuICAgICAgLy8gY29tZXMgaW4gYW5kIHRoZSB1c2VyIHJlY292ZXJzIGZyb20gdGhlIGVycm9yLlxuICAgICAgaWYgKHN0YXRlLmxvY2F0aW9uICE9PSBwcm9wcy5sb2NhdGlvbiB8fCBzdGF0ZS5yZXZhbGlkYXRpb24gIT09IFwiaWRsZVwiICYmIHByb3BzLnJldmFsaWRhdGlvbiA9PT0gXCJpZGxlXCIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBlcnJvcjogcHJvcHMuZXJyb3IsXG4gICAgICAgICAgbG9jYXRpb246IHByb3BzLmxvY2F0aW9uLFxuICAgICAgICAgIHJldmFsaWRhdGlvbjogcHJvcHMucmV2YWxpZGF0aW9uXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHdlJ3JlIG5vdCBjaGFuZ2luZyBsb2NhdGlvbnMsIHByZXNlcnZlIHRoZSBsb2NhdGlvbiBidXQgc3RpbGwgc3VyZmFjZVxuICAgICAgLy8gYW55IG5ldyBlcnJvcnMgdGhhdCBtYXkgY29tZSB0aHJvdWdoLiBXZSByZXRhaW4gdGhlIGV4aXN0aW5nIGVycm9yLCB3ZSBkb1xuICAgICAgLy8gdGhpcyBiZWNhdXNlIHRoZSBlcnJvciBwcm92aWRlZCBmcm9tIHRoZSBhcHAgc3RhdGUgbWF5IGJlIGNsZWFyZWQgd2l0aG91dFxuICAgICAgLy8gdGhlIGxvY2F0aW9uIGNoYW5naW5nLlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXJyb3I6IHByb3BzLmVycm9yICE9PSB1bmRlZmluZWQgPyBwcm9wcy5lcnJvciA6IHN0YXRlLmVycm9yLFxuICAgICAgICBsb2NhdGlvbjogc3RhdGUubG9jYXRpb24sXG4gICAgICAgIHJldmFsaWRhdGlvbjogcHJvcHMucmV2YWxpZGF0aW9uIHx8IHN0YXRlLnJldmFsaWRhdGlvblxuICAgICAgfTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkQ2F0Y2goZXJyb3IsIGVycm9ySW5mbykge1xuICAgICAgY29uc29sZS5lcnJvcihcIlJlYWN0IFJvdXRlciBjYXVnaHQgdGhlIGZvbGxvd2luZyBlcnJvciBkdXJpbmcgcmVuZGVyXCIsIGVycm9yLCBlcnJvckluZm8pO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zdGF0ZS5lcnJvciAhPT0gdW5kZWZpbmVkID8gLyojX19QVVJFX18qL1JlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChSb3V0ZUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgdmFsdWU6IHRoaXMucHJvcHMucm91dGVDb250ZXh0XG4gICAgICB9LCAvKiNfX1BVUkVfXyovUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFJvdXRlRXJyb3JDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgIHZhbHVlOiB0aGlzLnN0YXRlLmVycm9yLFxuICAgICAgICBjaGlsZHJlbjogdGhpcy5wcm9wcy5jb21wb25lbnRcbiAgICAgIH0pKSA6IHRoaXMucHJvcHMuY2hpbGRyZW47XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIFJlbmRlcmVkUm91dGUoX3JlZikge1xuICAgIGxldCB7XG4gICAgICByb3V0ZUNvbnRleHQsXG4gICAgICBtYXRjaCxcbiAgICAgIGNoaWxkcmVuXG4gICAgfSA9IF9yZWY7XG4gICAgbGV0IGRhdGFSb3V0ZXJDb250ZXh0ID0gUmVhY3RfX25hbWVzcGFjZS51c2VDb250ZXh0KERhdGFSb3V0ZXJDb250ZXh0KTtcblxuICAgIC8vIFRyYWNrIGhvdyBkZWVwIHdlIGdvdCBpbiBvdXIgcmVuZGVyIHBhc3MgdG8gZW11bGF0ZSBTU1IgY29tcG9uZW50RGlkQ2F0Y2hcbiAgICAvLyBpbiBhIERhdGFTdGF0aWNSb3V0ZXJcbiAgICBpZiAoZGF0YVJvdXRlckNvbnRleHQgJiYgZGF0YVJvdXRlckNvbnRleHQuc3RhdGljICYmIGRhdGFSb3V0ZXJDb250ZXh0LnN0YXRpY0NvbnRleHQgJiYgKG1hdGNoLnJvdXRlLmVycm9yRWxlbWVudCB8fCBtYXRjaC5yb3V0ZS5FcnJvckJvdW5kYXJ5KSkge1xuICAgICAgZGF0YVJvdXRlckNvbnRleHQuc3RhdGljQ29udGV4dC5fZGVlcGVzdFJlbmRlcmVkQm91bmRhcnlJZCA9IG1hdGNoLnJvdXRlLmlkO1xuICAgIH1cbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChSb3V0ZUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgIHZhbHVlOiByb3V0ZUNvbnRleHRcbiAgICB9LCBjaGlsZHJlbik7XG4gIH1cbiAgZnVuY3Rpb24gX3JlbmRlck1hdGNoZXMobWF0Y2hlcywgcGFyZW50TWF0Y2hlcywgZGF0YVJvdXRlclN0YXRlLCBmdXR1cmUpIHtcbiAgICB2YXIgX2RhdGFSb3V0ZXJTdGF0ZTI7XG4gICAgaWYgKHBhcmVudE1hdGNoZXMgPT09IHZvaWQgMCkge1xuICAgICAgcGFyZW50TWF0Y2hlcyA9IFtdO1xuICAgIH1cbiAgICBpZiAoZGF0YVJvdXRlclN0YXRlID09PSB2b2lkIDApIHtcbiAgICAgIGRhdGFSb3V0ZXJTdGF0ZSA9IG51bGw7XG4gICAgfVxuICAgIGlmIChmdXR1cmUgPT09IHZvaWQgMCkge1xuICAgICAgZnV0dXJlID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKG1hdGNoZXMgPT0gbnVsbCkge1xuICAgICAgdmFyIF9kYXRhUm91dGVyU3RhdGU7XG4gICAgICBpZiAoKF9kYXRhUm91dGVyU3RhdGUgPSBkYXRhUm91dGVyU3RhdGUpICE9IG51bGwgJiYgX2RhdGFSb3V0ZXJTdGF0ZS5lcnJvcnMpIHtcbiAgICAgICAgLy8gRG9uJ3QgYmFpbCBpZiB3ZSBoYXZlIGRhdGEgcm91dGVyIGVycm9ycyBzbyB3ZSBjYW4gcmVuZGVyIHRoZW0gaW4gdGhlXG4gICAgICAgIC8vIGJvdW5kYXJ5LiAgVXNlIHRoZSBwcmUtbWF0Y2hlZCAob3Igc2hpbW1lZCkgbWF0Y2hlc1xuICAgICAgICBtYXRjaGVzID0gZGF0YVJvdXRlclN0YXRlLm1hdGNoZXM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IHJlbmRlcmVkTWF0Y2hlcyA9IG1hdGNoZXM7XG5cbiAgICAvLyBJZiB3ZSBoYXZlIGRhdGEgZXJyb3JzLCB0cmltIG1hdGNoZXMgdG8gdGhlIGhpZ2hlc3QgZXJyb3IgYm91bmRhcnlcbiAgICBsZXQgZXJyb3JzID0gKF9kYXRhUm91dGVyU3RhdGUyID0gZGF0YVJvdXRlclN0YXRlKSA9PSBudWxsID8gdm9pZCAwIDogX2RhdGFSb3V0ZXJTdGF0ZTIuZXJyb3JzO1xuICAgIGlmIChlcnJvcnMgIT0gbnVsbCkge1xuICAgICAgbGV0IGVycm9ySW5kZXggPSByZW5kZXJlZE1hdGNoZXMuZmluZEluZGV4KG0gPT4gbS5yb3V0ZS5pZCAmJiAoZXJyb3JzID09IG51bGwgPyB2b2lkIDAgOiBlcnJvcnNbbS5yb3V0ZS5pZF0pKTtcbiAgICAgICEoZXJyb3JJbmRleCA+PSAwKSA/IHJvdXRlci5VTlNBRkVfaW52YXJpYW50KGZhbHNlLCBcIkNvdWxkIG5vdCBmaW5kIGEgbWF0Y2hpbmcgcm91dGUgZm9yIGVycm9ycyBvbiByb3V0ZSBJRHM6IFwiICsgT2JqZWN0LmtleXMoZXJyb3JzKS5qb2luKFwiLFwiKSkgIDogdm9pZCAwO1xuICAgICAgcmVuZGVyZWRNYXRjaGVzID0gcmVuZGVyZWRNYXRjaGVzLnNsaWNlKDAsIE1hdGgubWluKHJlbmRlcmVkTWF0Y2hlcy5sZW5ndGgsIGVycm9ySW5kZXggKyAxKSk7XG4gICAgfVxuXG4gICAgLy8gSWYgd2UncmUgaW4gYSBwYXJ0aWFsIGh5ZHJhdGlvbiBtb2RlLCBkZXRlY3QgaWYgd2UgbmVlZCB0byByZW5kZXIgZG93biB0b1xuICAgIC8vIGEgZ2l2ZW4gSHlkcmF0ZUZhbGxiYWNrIHdoaWxlIHdlIGxvYWQgdGhlIHJlc3Qgb2YgdGhlIGh5ZHJhdGlvbiBkYXRhXG4gICAgbGV0IHJlbmRlckZhbGxiYWNrID0gZmFsc2U7XG4gICAgbGV0IGZhbGxiYWNrSW5kZXggPSAtMTtcbiAgICBpZiAoZGF0YVJvdXRlclN0YXRlICYmIGZ1dHVyZSAmJiBmdXR1cmUudjdfcGFydGlhbEh5ZHJhdGlvbikge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZW5kZXJlZE1hdGNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IG1hdGNoID0gcmVuZGVyZWRNYXRjaGVzW2ldO1xuICAgICAgICAvLyBUcmFjayB0aGUgZGVlcGVzdCBmYWxsYmFjayB1cCB1bnRpbCB0aGUgZmlyc3Qgcm91dGUgd2l0aG91dCBkYXRhXG4gICAgICAgIGlmIChtYXRjaC5yb3V0ZS5IeWRyYXRlRmFsbGJhY2sgfHwgbWF0Y2gucm91dGUuaHlkcmF0ZUZhbGxiYWNrRWxlbWVudCkge1xuICAgICAgICAgIGZhbGxiYWNrSW5kZXggPSBpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRjaC5yb3V0ZS5pZCkge1xuICAgICAgICAgIGxldCB7XG4gICAgICAgICAgICBsb2FkZXJEYXRhLFxuICAgICAgICAgICAgZXJyb3JzXG4gICAgICAgICAgfSA9IGRhdGFSb3V0ZXJTdGF0ZTtcbiAgICAgICAgICBsZXQgbmVlZHNUb1J1bkxvYWRlciA9IG1hdGNoLnJvdXRlLmxvYWRlciAmJiBsb2FkZXJEYXRhW21hdGNoLnJvdXRlLmlkXSA9PT0gdW5kZWZpbmVkICYmICghZXJyb3JzIHx8IGVycm9yc1ttYXRjaC5yb3V0ZS5pZF0gPT09IHVuZGVmaW5lZCk7XG4gICAgICAgICAgaWYgKG1hdGNoLnJvdXRlLmxhenkgfHwgbmVlZHNUb1J1bkxvYWRlcikge1xuICAgICAgICAgICAgLy8gV2UgZm91bmQgdGhlIGZpcnN0IHJvdXRlIHRoYXQncyBub3QgcmVhZHkgdG8gcmVuZGVyICh3YWl0aW5nIG9uXG4gICAgICAgICAgICAvLyBsYXp5LCBvciBoYXMgYSBsb2FkZXIgdGhhdCBoYXNuJ3QgcnVuIHlldCkuICBGbGFnIHRoYXQgd2UgbmVlZCB0b1xuICAgICAgICAgICAgLy8gcmVuZGVyIGEgZmFsbGJhY2sgYW5kIHJlbmRlciB1cCB1bnRpbCB0aGUgYXBwcm9wcmlhdGUgZmFsbGJhY2tcbiAgICAgICAgICAgIHJlbmRlckZhbGxiYWNrID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChmYWxsYmFja0luZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgcmVuZGVyZWRNYXRjaGVzID0gcmVuZGVyZWRNYXRjaGVzLnNsaWNlKDAsIGZhbGxiYWNrSW5kZXggKyAxKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlbmRlcmVkTWF0Y2hlcyA9IFtyZW5kZXJlZE1hdGNoZXNbMF1dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZW5kZXJlZE1hdGNoZXMucmVkdWNlUmlnaHQoKG91dGxldCwgbWF0Y2gsIGluZGV4KSA9PiB7XG4gICAgICAvLyBPbmx5IGRhdGEgcm91dGVycyBoYW5kbGUgZXJyb3JzL2ZhbGxiYWNrc1xuICAgICAgbGV0IGVycm9yO1xuICAgICAgbGV0IHNob3VsZFJlbmRlckh5ZHJhdGVGYWxsYmFjayA9IGZhbHNlO1xuICAgICAgbGV0IGVycm9yRWxlbWVudCA9IG51bGw7XG4gICAgICBsZXQgaHlkcmF0ZUZhbGxiYWNrRWxlbWVudCA9IG51bGw7XG4gICAgICBpZiAoZGF0YVJvdXRlclN0YXRlKSB7XG4gICAgICAgIGVycm9yID0gZXJyb3JzICYmIG1hdGNoLnJvdXRlLmlkID8gZXJyb3JzW21hdGNoLnJvdXRlLmlkXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgZXJyb3JFbGVtZW50ID0gbWF0Y2gucm91dGUuZXJyb3JFbGVtZW50IHx8IGRlZmF1bHRFcnJvckVsZW1lbnQ7XG4gICAgICAgIGlmIChyZW5kZXJGYWxsYmFjaykge1xuICAgICAgICAgIGlmIChmYWxsYmFja0luZGV4IDwgMCAmJiBpbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgd2FybmluZ09uY2UoXCJyb3V0ZS1mYWxsYmFja1wiLCBmYWxzZSwgXCJObyBgSHlkcmF0ZUZhbGxiYWNrYCBlbGVtZW50IHByb3ZpZGVkIHRvIHJlbmRlciBkdXJpbmcgaW5pdGlhbCBoeWRyYXRpb25cIik7XG4gICAgICAgICAgICBzaG91bGRSZW5kZXJIeWRyYXRlRmFsbGJhY2sgPSB0cnVlO1xuICAgICAgICAgICAgaHlkcmF0ZUZhbGxiYWNrRWxlbWVudCA9IG51bGw7XG4gICAgICAgICAgfSBlbHNlIGlmIChmYWxsYmFja0luZGV4ID09PSBpbmRleCkge1xuICAgICAgICAgICAgc2hvdWxkUmVuZGVySHlkcmF0ZUZhbGxiYWNrID0gdHJ1ZTtcbiAgICAgICAgICAgIGh5ZHJhdGVGYWxsYmFja0VsZW1lbnQgPSBtYXRjaC5yb3V0ZS5oeWRyYXRlRmFsbGJhY2tFbGVtZW50IHx8IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsZXQgbWF0Y2hlcyA9IHBhcmVudE1hdGNoZXMuY29uY2F0KHJlbmRlcmVkTWF0Y2hlcy5zbGljZSgwLCBpbmRleCArIDEpKTtcbiAgICAgIGxldCBnZXRDaGlsZHJlbiA9ICgpID0+IHtcbiAgICAgICAgbGV0IGNoaWxkcmVuO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICBjaGlsZHJlbiA9IGVycm9yRWxlbWVudDtcbiAgICAgICAgfSBlbHNlIGlmIChzaG91bGRSZW5kZXJIeWRyYXRlRmFsbGJhY2spIHtcbiAgICAgICAgICBjaGlsZHJlbiA9IGh5ZHJhdGVGYWxsYmFja0VsZW1lbnQ7XG4gICAgICAgIH0gZWxzZSBpZiAobWF0Y2gucm91dGUuQ29tcG9uZW50KSB7XG4gICAgICAgICAgLy8gTm90ZTogVGhpcyBpcyBhIGRlLW9wdGltaXplZCBwYXRoIHNpbmNlIFJlYWN0IHdvbid0IHJlLXVzZSB0aGVcbiAgICAgICAgICAvLyBSZWFjdEVsZW1lbnQgc2luY2UgaXQncyBpZGVudGl0eSBjaGFuZ2VzIHdpdGggZWFjaCBuZXdcbiAgICAgICAgICAvLyBSZWFjdC5jcmVhdGVFbGVtZW50IGNhbGwuICBXZSBrZWVwIHRoaXMgc28gZm9sa3MgY2FuIHVzZVxuICAgICAgICAgIC8vIGA8Um91dGUgQ29tcG9uZW50PXsuLi59PmAgaW4gYDxSb3V0ZXM+YCBidXQgZ2VuZXJhbGx5IGBDb21wb25lbnRgXG4gICAgICAgICAgLy8gdXNhZ2UgaXMgb25seSBhZHZpc2VkIGluIGBSb3V0ZXJQcm92aWRlcmAgd2hlbiB3ZSBjYW4gY29udmVydCBpdCB0b1xuICAgICAgICAgIC8vIGBlbGVtZW50YCBhaGVhZCBvZiB0aW1lLlxuICAgICAgICAgIGNoaWxkcmVuID0gLyojX19QVVJFX18qL1JlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChtYXRjaC5yb3V0ZS5Db21wb25lbnQsIG51bGwpO1xuICAgICAgICB9IGVsc2UgaWYgKG1hdGNoLnJvdXRlLmVsZW1lbnQpIHtcbiAgICAgICAgICBjaGlsZHJlbiA9IG1hdGNoLnJvdXRlLmVsZW1lbnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2hpbGRyZW4gPSBvdXRsZXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoUmVuZGVyZWRSb3V0ZSwge1xuICAgICAgICAgIG1hdGNoOiBtYXRjaCxcbiAgICAgICAgICByb3V0ZUNvbnRleHQ6IHtcbiAgICAgICAgICAgIG91dGxldCxcbiAgICAgICAgICAgIG1hdGNoZXMsXG4gICAgICAgICAgICBpc0RhdGFSb3V0ZTogZGF0YVJvdXRlclN0YXRlICE9IG51bGxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNoaWxkcmVuOiBjaGlsZHJlblxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICAvLyBPbmx5IHdyYXAgaW4gYW4gZXJyb3IgYm91bmRhcnkgd2l0aGluIGRhdGEgcm91dGVyIHVzYWdlcyB3aGVuIHdlIGhhdmUgYW5cbiAgICAgIC8vIEVycm9yQm91bmRhcnkvZXJyb3JFbGVtZW50IG9uIHRoaXMgcm91dGUuICBPdGhlcndpc2UgbGV0IGl0IGJ1YmJsZSB1cCB0b1xuICAgICAgLy8gYW4gYW5jZXN0b3IgRXJyb3JCb3VuZGFyeS9lcnJvckVsZW1lbnRcbiAgICAgIHJldHVybiBkYXRhUm91dGVyU3RhdGUgJiYgKG1hdGNoLnJvdXRlLkVycm9yQm91bmRhcnkgfHwgbWF0Y2gucm91dGUuZXJyb3JFbGVtZW50IHx8IGluZGV4ID09PSAwKSA/IC8qI19fUFVSRV9fKi9SZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoUmVuZGVyRXJyb3JCb3VuZGFyeSwge1xuICAgICAgICBsb2NhdGlvbjogZGF0YVJvdXRlclN0YXRlLmxvY2F0aW9uLFxuICAgICAgICByZXZhbGlkYXRpb246IGRhdGFSb3V0ZXJTdGF0ZS5yZXZhbGlkYXRpb24sXG4gICAgICAgIGNvbXBvbmVudDogZXJyb3JFbGVtZW50LFxuICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgIGNoaWxkcmVuOiBnZXRDaGlsZHJlbigpLFxuICAgICAgICByb3V0ZUNvbnRleHQ6IHtcbiAgICAgICAgICBvdXRsZXQ6IG51bGwsXG4gICAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgICBpc0RhdGFSb3V0ZTogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9KSA6IGdldENoaWxkcmVuKCk7XG4gICAgfSwgbnVsbCk7XG4gIH1cbiAgdmFyIERhdGFSb3V0ZXJIb29rID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChEYXRhUm91dGVySG9vaykge1xuICAgIERhdGFSb3V0ZXJIb29rW1wiVXNlQmxvY2tlclwiXSA9IFwidXNlQmxvY2tlclwiO1xuICAgIERhdGFSb3V0ZXJIb29rW1wiVXNlUmV2YWxpZGF0b3JcIl0gPSBcInVzZVJldmFsaWRhdG9yXCI7XG4gICAgRGF0YVJvdXRlckhvb2tbXCJVc2VOYXZpZ2F0ZVN0YWJsZVwiXSA9IFwidXNlTmF2aWdhdGVcIjtcbiAgICByZXR1cm4gRGF0YVJvdXRlckhvb2s7XG4gIH0oRGF0YVJvdXRlckhvb2sgfHwge30pO1xuICB2YXIgRGF0YVJvdXRlclN0YXRlSG9vayA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoRGF0YVJvdXRlclN0YXRlSG9vaykge1xuICAgIERhdGFSb3V0ZXJTdGF0ZUhvb2tbXCJVc2VCbG9ja2VyXCJdID0gXCJ1c2VCbG9ja2VyXCI7XG4gICAgRGF0YVJvdXRlclN0YXRlSG9va1tcIlVzZUxvYWRlckRhdGFcIl0gPSBcInVzZUxvYWRlckRhdGFcIjtcbiAgICBEYXRhUm91dGVyU3RhdGVIb29rW1wiVXNlQWN0aW9uRGF0YVwiXSA9IFwidXNlQWN0aW9uRGF0YVwiO1xuICAgIERhdGFSb3V0ZXJTdGF0ZUhvb2tbXCJVc2VSb3V0ZUVycm9yXCJdID0gXCJ1c2VSb3V0ZUVycm9yXCI7XG4gICAgRGF0YVJvdXRlclN0YXRlSG9va1tcIlVzZU5hdmlnYXRpb25cIl0gPSBcInVzZU5hdmlnYXRpb25cIjtcbiAgICBEYXRhUm91dGVyU3RhdGVIb29rW1wiVXNlUm91dGVMb2FkZXJEYXRhXCJdID0gXCJ1c2VSb3V0ZUxvYWRlckRhdGFcIjtcbiAgICBEYXRhUm91dGVyU3RhdGVIb29rW1wiVXNlTWF0Y2hlc1wiXSA9IFwidXNlTWF0Y2hlc1wiO1xuICAgIERhdGFSb3V0ZXJTdGF0ZUhvb2tbXCJVc2VSZXZhbGlkYXRvclwiXSA9IFwidXNlUmV2YWxpZGF0b3JcIjtcbiAgICBEYXRhUm91dGVyU3RhdGVIb29rW1wiVXNlTmF2aWdhdGVTdGFibGVcIl0gPSBcInVzZU5hdmlnYXRlXCI7XG4gICAgRGF0YVJvdXRlclN0YXRlSG9va1tcIlVzZVJvdXRlSWRcIl0gPSBcInVzZVJvdXRlSWRcIjtcbiAgICByZXR1cm4gRGF0YVJvdXRlclN0YXRlSG9vaztcbiAgfShEYXRhUm91dGVyU3RhdGVIb29rIHx8IHt9KTtcbiAgZnVuY3Rpb24gZ2V0RGF0YVJvdXRlckNvbnNvbGVFcnJvcihob29rTmFtZSkge1xuICAgIHJldHVybiBob29rTmFtZSArIFwiIG11c3QgYmUgdXNlZCB3aXRoaW4gYSBkYXRhIHJvdXRlci4gIFNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9yb3V0ZXJzL3BpY2tpbmctYS1yb3V0ZXIuXCI7XG4gIH1cbiAgZnVuY3Rpb24gdXNlRGF0YVJvdXRlckNvbnRleHQoaG9va05hbWUpIHtcbiAgICBsZXQgY3R4ID0gUmVhY3RfX25hbWVzcGFjZS51c2VDb250ZXh0KERhdGFSb3V0ZXJDb250ZXh0KTtcbiAgICAhY3R4ID8gcm91dGVyLlVOU0FGRV9pbnZhcmlhbnQoZmFsc2UsIGdldERhdGFSb3V0ZXJDb25zb2xlRXJyb3IoaG9va05hbWUpKSAgOiB2b2lkIDA7XG4gICAgcmV0dXJuIGN0eDtcbiAgfVxuICBmdW5jdGlvbiB1c2VEYXRhUm91dGVyU3RhdGUoaG9va05hbWUpIHtcbiAgICBsZXQgc3RhdGUgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZUNvbnRleHQoRGF0YVJvdXRlclN0YXRlQ29udGV4dCk7XG4gICAgIXN0YXRlID8gcm91dGVyLlVOU0FGRV9pbnZhcmlhbnQoZmFsc2UsIGdldERhdGFSb3V0ZXJDb25zb2xlRXJyb3IoaG9va05hbWUpKSAgOiB2b2lkIDA7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG4gIGZ1bmN0aW9uIHVzZVJvdXRlQ29udGV4dChob29rTmFtZSkge1xuICAgIGxldCByb3V0ZSA9IFJlYWN0X19uYW1lc3BhY2UudXNlQ29udGV4dChSb3V0ZUNvbnRleHQpO1xuICAgICFyb3V0ZSA/IHJvdXRlci5VTlNBRkVfaW52YXJpYW50KGZhbHNlLCBnZXREYXRhUm91dGVyQ29uc29sZUVycm9yKGhvb2tOYW1lKSkgIDogdm9pZCAwO1xuICAgIHJldHVybiByb3V0ZTtcbiAgfVxuXG4gIC8vIEludGVybmFsIHZlcnNpb24gd2l0aCBob29rTmFtZS1hd2FyZSBkZWJ1Z2dpbmdcbiAgZnVuY3Rpb24gdXNlQ3VycmVudFJvdXRlSWQoaG9va05hbWUpIHtcbiAgICBsZXQgcm91dGUgPSB1c2VSb3V0ZUNvbnRleHQoaG9va05hbWUpO1xuICAgIGxldCB0aGlzUm91dGUgPSByb3V0ZS5tYXRjaGVzW3JvdXRlLm1hdGNoZXMubGVuZ3RoIC0gMV07XG4gICAgIXRoaXNSb3V0ZS5yb3V0ZS5pZCA/IHJvdXRlci5VTlNBRkVfaW52YXJpYW50KGZhbHNlLCBob29rTmFtZSArIFwiIGNhbiBvbmx5IGJlIHVzZWQgb24gcm91dGVzIHRoYXQgY29udGFpbiBhIHVuaXF1ZSBcXFwiaWRcXFwiXCIpICA6IHZvaWQgMDtcbiAgICByZXR1cm4gdGhpc1JvdXRlLnJvdXRlLmlkO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIElEIGZvciB0aGUgbmVhcmVzdCBjb250ZXh0dWFsIHJvdXRlXG4gICAqL1xuICBmdW5jdGlvbiB1c2VSb3V0ZUlkKCkge1xuICAgIHJldHVybiB1c2VDdXJyZW50Um91dGVJZChEYXRhUm91dGVyU3RhdGVIb29rLlVzZVJvdXRlSWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgbmF2aWdhdGlvbiwgZGVmYXVsdGluZyB0byBhbiBcImlkbGVcIiBuYXZpZ2F0aW9uIHdoZW5cbiAgICogbm8gbmF2aWdhdGlvbiBpcyBpbiBwcm9ncmVzc1xuICAgKi9cbiAgZnVuY3Rpb24gdXNlTmF2aWdhdGlvbigpIHtcbiAgICBsZXQgc3RhdGUgPSB1c2VEYXRhUm91dGVyU3RhdGUoRGF0YVJvdXRlclN0YXRlSG9vay5Vc2VOYXZpZ2F0aW9uKTtcbiAgICByZXR1cm4gc3RhdGUubmF2aWdhdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgcmV2YWxpZGF0ZSBmdW5jdGlvbiBmb3IgbWFudWFsbHkgdHJpZ2dlcmluZyByZXZhbGlkYXRpb24sIGFzIHdlbGxcbiAgICogYXMgdGhlIGN1cnJlbnQgc3RhdGUgb2YgYW55IG1hbnVhbCByZXZhbGlkYXRpb25zXG4gICAqL1xuICBmdW5jdGlvbiB1c2VSZXZhbGlkYXRvcigpIHtcbiAgICBsZXQgZGF0YVJvdXRlckNvbnRleHQgPSB1c2VEYXRhUm91dGVyQ29udGV4dChEYXRhUm91dGVySG9vay5Vc2VSZXZhbGlkYXRvcik7XG4gICAgbGV0IHN0YXRlID0gdXNlRGF0YVJvdXRlclN0YXRlKERhdGFSb3V0ZXJTdGF0ZUhvb2suVXNlUmV2YWxpZGF0b3IpO1xuICAgIHJldHVybiBSZWFjdF9fbmFtZXNwYWNlLnVzZU1lbW8oKCkgPT4gKHtcbiAgICAgIHJldmFsaWRhdGU6IGRhdGFSb3V0ZXJDb250ZXh0LnJvdXRlci5yZXZhbGlkYXRlLFxuICAgICAgc3RhdGU6IHN0YXRlLnJldmFsaWRhdGlvblxuICAgIH0pLCBbZGF0YVJvdXRlckNvbnRleHQucm91dGVyLnJldmFsaWRhdGUsIHN0YXRlLnJldmFsaWRhdGlvbl0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFjdGl2ZSByb3V0ZSBtYXRjaGVzLCB1c2VmdWwgZm9yIGFjY2Vzc2luZyBsb2FkZXJEYXRhIGZvclxuICAgKiBwYXJlbnQvY2hpbGQgcm91dGVzIG9yIHRoZSByb3V0ZSBcImhhbmRsZVwiIHByb3BlcnR5XG4gICAqL1xuICBmdW5jdGlvbiB1c2VNYXRjaGVzKCkge1xuICAgIGxldCB7XG4gICAgICBtYXRjaGVzLFxuICAgICAgbG9hZGVyRGF0YVxuICAgIH0gPSB1c2VEYXRhUm91dGVyU3RhdGUoRGF0YVJvdXRlclN0YXRlSG9vay5Vc2VNYXRjaGVzKTtcbiAgICByZXR1cm4gUmVhY3RfX25hbWVzcGFjZS51c2VNZW1vKCgpID0+IG1hdGNoZXMubWFwKG0gPT4gcm91dGVyLlVOU0FGRV9jb252ZXJ0Um91dGVNYXRjaFRvVWlNYXRjaChtLCBsb2FkZXJEYXRhKSksIFttYXRjaGVzLCBsb2FkZXJEYXRhXSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbG9hZGVyIGRhdGEgZm9yIHRoZSBuZWFyZXN0IGFuY2VzdG9yIFJvdXRlIGxvYWRlclxuICAgKi9cbiAgZnVuY3Rpb24gdXNlTG9hZGVyRGF0YSgpIHtcbiAgICBsZXQgc3RhdGUgPSB1c2VEYXRhUm91dGVyU3RhdGUoRGF0YVJvdXRlclN0YXRlSG9vay5Vc2VMb2FkZXJEYXRhKTtcbiAgICBsZXQgcm91dGVJZCA9IHVzZUN1cnJlbnRSb3V0ZUlkKERhdGFSb3V0ZXJTdGF0ZUhvb2suVXNlTG9hZGVyRGF0YSk7XG4gICAgaWYgKHN0YXRlLmVycm9ycyAmJiBzdGF0ZS5lcnJvcnNbcm91dGVJZF0gIT0gbnVsbCkge1xuICAgICAgY29uc29sZS5lcnJvcihcIllvdSBjYW5ub3QgYHVzZUxvYWRlckRhdGFgIGluIGFuIGVycm9yRWxlbWVudCAocm91dGVJZDogXCIgKyByb3V0ZUlkICsgXCIpXCIpO1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIHN0YXRlLmxvYWRlckRhdGFbcm91dGVJZF07XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbG9hZGVyRGF0YSBmb3IgdGhlIGdpdmVuIHJvdXRlSWRcbiAgICovXG4gIGZ1bmN0aW9uIHVzZVJvdXRlTG9hZGVyRGF0YShyb3V0ZUlkKSB7XG4gICAgbGV0IHN0YXRlID0gdXNlRGF0YVJvdXRlclN0YXRlKERhdGFSb3V0ZXJTdGF0ZUhvb2suVXNlUm91dGVMb2FkZXJEYXRhKTtcbiAgICByZXR1cm4gc3RhdGUubG9hZGVyRGF0YVtyb3V0ZUlkXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhY3Rpb24gZGF0YSBmb3IgdGhlIG5lYXJlc3QgYW5jZXN0b3IgUm91dGUgYWN0aW9uXG4gICAqL1xuICBmdW5jdGlvbiB1c2VBY3Rpb25EYXRhKCkge1xuICAgIGxldCBzdGF0ZSA9IHVzZURhdGFSb3V0ZXJTdGF0ZShEYXRhUm91dGVyU3RhdGVIb29rLlVzZUFjdGlvbkRhdGEpO1xuICAgIGxldCByb3V0ZUlkID0gdXNlQ3VycmVudFJvdXRlSWQoRGF0YVJvdXRlclN0YXRlSG9vay5Vc2VMb2FkZXJEYXRhKTtcbiAgICByZXR1cm4gc3RhdGUuYWN0aW9uRGF0YSA/IHN0YXRlLmFjdGlvbkRhdGFbcm91dGVJZF0gOiB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbmVhcmVzdCBhbmNlc3RvciBSb3V0ZSBlcnJvciwgd2hpY2ggY291bGQgYmUgYSBsb2FkZXIvYWN0aW9uXG4gICAqIGVycm9yIG9yIGEgcmVuZGVyIGVycm9yLiAgVGhpcyBpcyBpbnRlbmRlZCB0byBiZSBjYWxsZWQgZnJvbSB5b3VyXG4gICAqIEVycm9yQm91bmRhcnkvZXJyb3JFbGVtZW50IHRvIGRpc3BsYXkgYSBwcm9wZXIgZXJyb3IgbWVzc2FnZS5cbiAgICovXG4gIGZ1bmN0aW9uIHVzZVJvdXRlRXJyb3IoKSB7XG4gICAgdmFyIF9zdGF0ZSRlcnJvcnM7XG4gICAgbGV0IGVycm9yID0gUmVhY3RfX25hbWVzcGFjZS51c2VDb250ZXh0KFJvdXRlRXJyb3JDb250ZXh0KTtcbiAgICBsZXQgc3RhdGUgPSB1c2VEYXRhUm91dGVyU3RhdGUoRGF0YVJvdXRlclN0YXRlSG9vay5Vc2VSb3V0ZUVycm9yKTtcbiAgICBsZXQgcm91dGVJZCA9IHVzZUN1cnJlbnRSb3V0ZUlkKERhdGFSb3V0ZXJTdGF0ZUhvb2suVXNlUm91dGVFcnJvcik7XG5cbiAgICAvLyBJZiB0aGlzIHdhcyBhIHJlbmRlciBlcnJvciwgd2UgcHV0IGl0IGluIGEgUm91dGVFcnJvciBjb250ZXh0IGluc2lkZVxuICAgIC8vIG9mIFJlbmRlckVycm9yQm91bmRhcnlcbiAgICBpZiAoZXJyb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH1cblxuICAgIC8vIE90aGVyd2lzZSBsb29rIGZvciBlcnJvcnMgZnJvbSBvdXIgZGF0YSByb3V0ZXIgc3RhdGVcbiAgICByZXR1cm4gKF9zdGF0ZSRlcnJvcnMgPSBzdGF0ZS5lcnJvcnMpID09IG51bGwgPyB2b2lkIDAgOiBfc3RhdGUkZXJyb3JzW3JvdXRlSWRdO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGhhcHB5LXBhdGggZGF0YSBmcm9tIHRoZSBuZWFyZXN0IGFuY2VzdG9yIGA8QXdhaXQgLz5gIHZhbHVlXG4gICAqL1xuICBmdW5jdGlvbiB1c2VBc3luY1ZhbHVlKCkge1xuICAgIGxldCB2YWx1ZSA9IFJlYWN0X19uYW1lc3BhY2UudXNlQ29udGV4dChBd2FpdENvbnRleHQpO1xuICAgIHJldHVybiB2YWx1ZSA9PSBudWxsID8gdm9pZCAwIDogdmFsdWUuX2RhdGE7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZXJyb3IgZnJvbSB0aGUgbmVhcmVzdCBhbmNlc3RvciBgPEF3YWl0IC8+YCB2YWx1ZVxuICAgKi9cbiAgZnVuY3Rpb24gdXNlQXN5bmNFcnJvcigpIHtcbiAgICBsZXQgdmFsdWUgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZUNvbnRleHQoQXdhaXRDb250ZXh0KTtcbiAgICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/IHZvaWQgMCA6IHZhbHVlLl9lcnJvcjtcbiAgfVxuICBsZXQgYmxvY2tlcklkID0gMDtcblxuICAvKipcbiAgICogQWxsb3cgdGhlIGFwcGxpY2F0aW9uIHRvIGJsb2NrIG5hdmlnYXRpb25zIHdpdGhpbiB0aGUgU1BBIGFuZCBwcmVzZW50IHRoZVxuICAgKiB1c2VyIGEgY29uZmlybWF0aW9uIGRpYWxvZyB0byBjb25maXJtIHRoZSBuYXZpZ2F0aW9uLiAgTW9zdGx5IHVzZWQgdG8gYXZvaWRcbiAgICogdXNpbmcgaGFsZi1maWxsZWQgZm9ybSBkYXRhLiAgVGhpcyBkb2VzIG5vdCBoYW5kbGUgaGFyZC1yZWxvYWRzIG9yXG4gICAqIGNyb3NzLW9yaWdpbiBuYXZpZ2F0aW9ucy5cbiAgICovXG4gIGZ1bmN0aW9uIHVzZUJsb2NrZXIoc2hvdWxkQmxvY2spIHtcbiAgICBsZXQge1xuICAgICAgcm91dGVyOiByb3V0ZXIkMSxcbiAgICAgIGJhc2VuYW1lXG4gICAgfSA9IHVzZURhdGFSb3V0ZXJDb250ZXh0KERhdGFSb3V0ZXJIb29rLlVzZUJsb2NrZXIpO1xuICAgIGxldCBzdGF0ZSA9IHVzZURhdGFSb3V0ZXJTdGF0ZShEYXRhUm91dGVyU3RhdGVIb29rLlVzZUJsb2NrZXIpO1xuICAgIGxldCBbYmxvY2tlcktleSwgc2V0QmxvY2tlcktleV0gPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVN0YXRlKFwiXCIpO1xuICAgIGxldCBibG9ja2VyRnVuY3Rpb24gPSBSZWFjdF9fbmFtZXNwYWNlLnVzZUNhbGxiYWNrKGFyZyA9PiB7XG4gICAgICBpZiAodHlwZW9mIHNob3VsZEJsb2NrICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuICEhc2hvdWxkQmxvY2s7XG4gICAgICB9XG4gICAgICBpZiAoYmFzZW5hbWUgPT09IFwiL1wiKSB7XG4gICAgICAgIHJldHVybiBzaG91bGRCbG9jayhhcmcpO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGV5IHByb3ZpZGVkIHVzIGEgZnVuY3Rpb24gYW5kIHdlJ3ZlIGdvdCBhbiBhY3RpdmUgYmFzZW5hbWUsIHN0cmlwXG4gICAgICAvLyBpdCBmcm9tIHRoZSBsb2NhdGlvbnMgd2UgZXhwb3NlIHRvIHRoZSB1c2VyIHRvIG1hdGNoIHRoZSBiZWhhdmlvciBvZlxuICAgICAgLy8gdXNlTG9jYXRpb25cbiAgICAgIGxldCB7XG4gICAgICAgIGN1cnJlbnRMb2NhdGlvbixcbiAgICAgICAgbmV4dExvY2F0aW9uLFxuICAgICAgICBoaXN0b3J5QWN0aW9uXG4gICAgICB9ID0gYXJnO1xuICAgICAgcmV0dXJuIHNob3VsZEJsb2NrKHtcbiAgICAgICAgY3VycmVudExvY2F0aW9uOiBfZXh0ZW5kcyh7fSwgY3VycmVudExvY2F0aW9uLCB7XG4gICAgICAgICAgcGF0aG5hbWU6IHJvdXRlci5zdHJpcEJhc2VuYW1lKGN1cnJlbnRMb2NhdGlvbi5wYXRobmFtZSwgYmFzZW5hbWUpIHx8IGN1cnJlbnRMb2NhdGlvbi5wYXRobmFtZVxuICAgICAgICB9KSxcbiAgICAgICAgbmV4dExvY2F0aW9uOiBfZXh0ZW5kcyh7fSwgbmV4dExvY2F0aW9uLCB7XG4gICAgICAgICAgcGF0aG5hbWU6IHJvdXRlci5zdHJpcEJhc2VuYW1lKG5leHRMb2NhdGlvbi5wYXRobmFtZSwgYmFzZW5hbWUpIHx8IG5leHRMb2NhdGlvbi5wYXRobmFtZVxuICAgICAgICB9KSxcbiAgICAgICAgaGlzdG9yeUFjdGlvblxuICAgICAgfSk7XG4gICAgfSwgW2Jhc2VuYW1lLCBzaG91bGRCbG9ja10pO1xuXG4gICAgLy8gVGhpcyBlZmZlY3QgaXMgaW4gY2hhcmdlIG9mIGJsb2NrZXIga2V5IGFzc2lnbm1lbnQgYW5kIGRlbGV0aW9uICh3aGljaCBpc1xuICAgIC8vIHRpZ2h0bHkgY291cGxlZCB0byB0aGUga2V5KVxuICAgIFJlYWN0X19uYW1lc3BhY2UudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgIGxldCBrZXkgPSBTdHJpbmcoKytibG9ja2VySWQpO1xuICAgICAgc2V0QmxvY2tlcktleShrZXkpO1xuICAgICAgcmV0dXJuICgpID0+IHJvdXRlciQxLmRlbGV0ZUJsb2NrZXIoa2V5KTtcbiAgICB9LCBbcm91dGVyJDFdKTtcblxuICAgIC8vIFRoaXMgZWZmZWN0IGhhbmRsZXMgYXNzaWduaW5nIHRoZSBibG9ja2VyRnVuY3Rpb24uICBUaGlzIGlzIHRvIGhhbmRsZVxuICAgIC8vIHVuc3RhYmxlIGJsb2NrZXIgZnVuY3Rpb24gaWRlbnRpdGllcywgYW5kIGhhcHBlbnMgb25seSBhZnRlciB0aGUgcHJpb3JcbiAgICAvLyBlZmZlY3Qgc28gd2UgZG9uJ3QgZ2V0IGFuIG9ycGhhbmVkIGJsb2NrZXJGdW5jdGlvbiBpbiB0aGUgcm91dGVyIHdpdGggYVxuICAgIC8vIGtleSBvZiBcIlwiLiAgVW50aWwgdGhlbiB3ZSBqdXN0IGhhdmUgdGhlIElETEVfQkxPQ0tFUi5cbiAgICBSZWFjdF9fbmFtZXNwYWNlLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICBpZiAoYmxvY2tlcktleSAhPT0gXCJcIikge1xuICAgICAgICByb3V0ZXIkMS5nZXRCbG9ja2VyKGJsb2NrZXJLZXksIGJsb2NrZXJGdW5jdGlvbik7XG4gICAgICB9XG4gICAgfSwgW3JvdXRlciQxLCBibG9ja2VyS2V5LCBibG9ja2VyRnVuY3Rpb25dKTtcblxuICAgIC8vIFByZWZlciB0aGUgYmxvY2tlciBmcm9tIGBzdGF0ZWAgbm90IGByb3V0ZXIuc3RhdGVgIHNpbmNlIERhdGFSb3V0ZXJDb250ZXh0XG4gICAgLy8gaXMgbWVtb2l6ZWQgc28gdGhpcyBlbnN1cmVzIHdlIHVwZGF0ZSBvbiBibG9ja2VyIHN0YXRlIHVwZGF0ZXNcbiAgICByZXR1cm4gYmxvY2tlcktleSAmJiBzdGF0ZS5ibG9ja2Vycy5oYXMoYmxvY2tlcktleSkgPyBzdGF0ZS5ibG9ja2Vycy5nZXQoYmxvY2tlcktleSkgOiByb3V0ZXIuSURMRV9CTE9DS0VSO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YWJsZSB2ZXJzaW9uIG9mIHVzZU5hdmlnYXRlIHRoYXQgaXMgdXNlZCB3aGVuIHdlIGFyZSBpbiB0aGUgY29udGV4dCBvZlxuICAgKiBhIFJvdXRlclByb3ZpZGVyLlxuICAgKi9cbiAgZnVuY3Rpb24gdXNlTmF2aWdhdGVTdGFibGUoKSB7XG4gICAgbGV0IHtcbiAgICAgIHJvdXRlcjogcm91dGVyJDFcbiAgICB9ID0gdXNlRGF0YVJvdXRlckNvbnRleHQoRGF0YVJvdXRlckhvb2suVXNlTmF2aWdhdGVTdGFibGUpO1xuICAgIGxldCBpZCA9IHVzZUN1cnJlbnRSb3V0ZUlkKERhdGFSb3V0ZXJTdGF0ZUhvb2suVXNlTmF2aWdhdGVTdGFibGUpO1xuICAgIGxldCBhY3RpdmVSZWYgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVJlZihmYWxzZSk7XG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICBhY3RpdmVSZWYuY3VycmVudCA9IHRydWU7XG4gICAgfSk7XG4gICAgbGV0IG5hdmlnYXRlID0gUmVhY3RfX25hbWVzcGFjZS51c2VDYWxsYmFjayhmdW5jdGlvbiAodG8sIG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgfVxuICAgICAgcm91dGVyLlVOU0FGRV93YXJuaW5nKGFjdGl2ZVJlZi5jdXJyZW50LCBuYXZpZ2F0ZUVmZmVjdFdhcm5pbmcpIDtcblxuICAgICAgLy8gU2hvcnQgY2lyY3VpdCBoZXJlIHNpbmNlIGlmIHRoaXMgaGFwcGVucyBvbiBmaXJzdCByZW5kZXIgdGhlIG5hdmlnYXRlXG4gICAgICAvLyBpcyB1c2VsZXNzIGJlY2F1c2Ugd2UgaGF2ZW4ndCB3aXJlZCB1cCBvdXIgcm91dGVyIHN1YnNjcmliZXIgeWV0XG4gICAgICBpZiAoIWFjdGl2ZVJlZi5jdXJyZW50KSByZXR1cm47XG4gICAgICBpZiAodHlwZW9mIHRvID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHJvdXRlciQxLm5hdmlnYXRlKHRvKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJvdXRlciQxLm5hdmlnYXRlKHRvLCBfZXh0ZW5kcyh7XG4gICAgICAgICAgZnJvbVJvdXRlSWQ6IGlkXG4gICAgICAgIH0sIG9wdGlvbnMpKTtcbiAgICAgIH1cbiAgICB9LCBbcm91dGVyJDEsIGlkXSk7XG4gICAgcmV0dXJuIG5hdmlnYXRlO1xuICB9XG4gIGNvbnN0IGFscmVhZHlXYXJuZWQgPSB7fTtcbiAgZnVuY3Rpb24gd2FybmluZ09uY2Uoa2V5LCBjb25kLCBtZXNzYWdlKSB7XG4gICAgaWYgKCFjb25kICYmICFhbHJlYWR5V2FybmVkW2tleV0pIHtcbiAgICAgIGFscmVhZHlXYXJuZWRba2V5XSA9IHRydWU7XG4gICAgICByb3V0ZXIuVU5TQUZFX3dhcm5pbmcoZmFsc2UsIG1lc3NhZ2UpIDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICBXZWJwYWNrICsgUmVhY3QgMTcgZmFpbHMgdG8gY29tcGlsZSBvbiBhbnkgb2YgdGhlIGZvbGxvd2luZyBiZWNhdXNlIHdlYnBhY2tcbiAgICBjb21wbGFpbnMgdGhhdCBgc3RhcnRUcmFuc2l0aW9uYCBkb2Vzbid0IGV4aXN0IGluIGBSZWFjdGA6XG4gICAgKiBpbXBvcnQgeyBzdGFydFRyYW5zaXRpb24gfSBmcm9tIFwicmVhY3RcIlxuICAgICogaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBmcm9tIFwicmVhY3RcIjtcbiAgICAgIFwic3RhcnRUcmFuc2l0aW9uXCIgaW4gUmVhY3QgPyBSZWFjdC5zdGFydFRyYW5zaXRpb24oKCkgPT4gc2V0U3RhdGUoKSkgOiBzZXRTdGF0ZSgpXG4gICAgKiBpbXBvcnQgKiBhcyBSZWFjdCBmcm9tIGZyb20gXCJyZWFjdFwiO1xuICAgICAgXCJzdGFydFRyYW5zaXRpb25cIiBpbiBSZWFjdCA/IFJlYWN0W1wic3RhcnRUcmFuc2l0aW9uXCJdKCgpID0+IHNldFN0YXRlKCkpIDogc2V0U3RhdGUoKVxuXG4gICAgTW92aW5nIGl0IHRvIGEgY29uc3RhbnQgc3VjaCBhcyB0aGUgZm9sbG93aW5nIHNvbHZlcyB0aGUgV2VicGFjay9SZWFjdCAxNyBpc3N1ZTpcbiAgICAqIGltcG9ydCAqIGFzIFJlYWN0IGZyb20gZnJvbSBcInJlYWN0XCI7XG4gICAgICBjb25zdCBTVEFSVF9UUkFOU0lUSU9OID0gXCJzdGFydFRyYW5zaXRpb25cIjtcbiAgICAgIFNUQVJUX1RSQU5TSVRJT04gaW4gUmVhY3QgPyBSZWFjdFtTVEFSVF9UUkFOU0lUSU9OXSgoKSA9PiBzZXRTdGF0ZSgpKSA6IHNldFN0YXRlKClcblxuICAgIEhvd2V2ZXIsIHRoYXQgaW50cm9kdWNlcyB3ZWJwYWNrL3RlcnNlciBtaW5pZmljYXRpb24gaXNzdWVzIGluIHByb2R1Y3Rpb24gYnVpbGRzXG4gICAgaW4gUmVhY3QgMTggd2hlcmUgbWluaWZpY2F0aW9uL29iZnVzY2F0aW9uIGVuZHMgdXAgcmVtb3ZpbmcgdGhlIGNhbGwgb2ZcbiAgICBSZWFjdC5zdGFydFRyYW5zaXRpb24gZW50aXJlbHkgZnJvbSB0aGUgZmlyc3QgaGFsZiBvZiB0aGUgdGVybmFyeS4gIEdyYWJiaW5nXG4gICAgdGhpcyBleHBvcnRlZCByZWZlcmVuY2Ugb25jZSB1cCBmcm9udCByZXNvbHZlcyB0aGF0IGlzc3VlLlxuXG4gICAgU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9yZW1peC1ydW4vcmVhY3Qtcm91dGVyL2lzc3Vlcy8xMDU3OVxuICAqL1xuICBjb25zdCBTVEFSVF9UUkFOU0lUSU9OID0gXCJzdGFydFRyYW5zaXRpb25cIjtcbiAgY29uc3Qgc3RhcnRUcmFuc2l0aW9uSW1wbCA9IFJlYWN0X19uYW1lc3BhY2VbU1RBUlRfVFJBTlNJVElPTl07XG5cbiAgLyoqXG4gICAqIEdpdmVuIGEgUmVtaXggUm91dGVyIGluc3RhbmNlLCByZW5kZXIgdGhlIGFwcHJvcHJpYXRlIFVJXG4gICAqL1xuICBmdW5jdGlvbiBSb3V0ZXJQcm92aWRlcihfcmVmKSB7XG4gICAgbGV0IHtcbiAgICAgIGZhbGxiYWNrRWxlbWVudCxcbiAgICAgIHJvdXRlcjogcm91dGVyJDEsXG4gICAgICBmdXR1cmVcbiAgICB9ID0gX3JlZjtcbiAgICBsZXQgW3N0YXRlLCBzZXRTdGF0ZUltcGxdID0gUmVhY3RfX25hbWVzcGFjZS51c2VTdGF0ZShyb3V0ZXIkMS5zdGF0ZSk7XG4gICAgbGV0IHtcbiAgICAgIHY3X3N0YXJ0VHJhbnNpdGlvblxuICAgIH0gPSBmdXR1cmUgfHwge307XG4gICAgbGV0IHNldFN0YXRlID0gUmVhY3RfX25hbWVzcGFjZS51c2VDYWxsYmFjayhuZXdTdGF0ZSA9PiB7XG4gICAgICBpZiAodjdfc3RhcnRUcmFuc2l0aW9uICYmIHN0YXJ0VHJhbnNpdGlvbkltcGwpIHtcbiAgICAgICAgc3RhcnRUcmFuc2l0aW9uSW1wbCgoKSA9PiBzZXRTdGF0ZUltcGwobmV3U3RhdGUpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldFN0YXRlSW1wbChuZXdTdGF0ZSk7XG4gICAgICB9XG4gICAgfSwgW3NldFN0YXRlSW1wbCwgdjdfc3RhcnRUcmFuc2l0aW9uXSk7XG5cbiAgICAvLyBOZWVkIHRvIHVzZSBhIGxheW91dCBlZmZlY3QgaGVyZSBzbyB3ZSBhcmUgc3Vic2NyaWJlZCBlYXJseSBlbm91Z2ggdG9cbiAgICAvLyBwaWNrIHVwIG9uIGFueSByZW5kZXItZHJpdmVuIHJlZGlyZWN0cy9uYXZpZ2F0aW9ucyAodXNlRWZmZWN0LzxOYXZpZ2F0ZT4pXG4gICAgUmVhY3RfX25hbWVzcGFjZS51c2VMYXlvdXRFZmZlY3QoKCkgPT4gcm91dGVyJDEuc3Vic2NyaWJlKHNldFN0YXRlKSwgW3JvdXRlciQxLCBzZXRTdGF0ZV0pO1xuICAgIFJlYWN0X19uYW1lc3BhY2UudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgIHJvdXRlci5VTlNBRkVfd2FybmluZyhmYWxsYmFja0VsZW1lbnQgPT0gbnVsbCB8fCAhcm91dGVyJDEuZnV0dXJlLnY3X3BhcnRpYWxIeWRyYXRpb24sIFwiYDxSb3V0ZXJQcm92aWRlciBmYWxsYmFja0VsZW1lbnQ+YCBpcyBkZXByZWNhdGVkIHdoZW4gdXNpbmcgXCIgKyBcImB2N19wYXJ0aWFsSHlkcmF0aW9uYCwgdXNlIGEgYEh5ZHJhdGVGYWxsYmFja2AgY29tcG9uZW50IGluc3RlYWRcIikgO1xuICAgICAgLy8gT25seSBsb2cgdGhpcyBvbmNlIG9uIGluaXRpYWwgbW91bnRcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICB9LCBbXSk7XG4gICAgbGV0IG5hdmlnYXRvciA9IFJlYWN0X19uYW1lc3BhY2UudXNlTWVtbygoKSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjcmVhdGVIcmVmOiByb3V0ZXIkMS5jcmVhdGVIcmVmLFxuICAgICAgICBlbmNvZGVMb2NhdGlvbjogcm91dGVyJDEuZW5jb2RlTG9jYXRpb24sXG4gICAgICAgIGdvOiBuID0+IHJvdXRlciQxLm5hdmlnYXRlKG4pLFxuICAgICAgICBwdXNoOiAodG8sIHN0YXRlLCBvcHRzKSA9PiByb3V0ZXIkMS5uYXZpZ2F0ZSh0bywge1xuICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgIHByZXZlbnRTY3JvbGxSZXNldDogb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5wcmV2ZW50U2Nyb2xsUmVzZXRcbiAgICAgICAgfSksXG4gICAgICAgIHJlcGxhY2U6ICh0bywgc3RhdGUsIG9wdHMpID0+IHJvdXRlciQxLm5hdmlnYXRlKHRvLCB7XG4gICAgICAgICAgcmVwbGFjZTogdHJ1ZSxcbiAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQ6IG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMucHJldmVudFNjcm9sbFJlc2V0XG4gICAgICAgIH0pXG4gICAgICB9O1xuICAgIH0sIFtyb3V0ZXIkMV0pO1xuICAgIGxldCBiYXNlbmFtZSA9IHJvdXRlciQxLmJhc2VuYW1lIHx8IFwiL1wiO1xuICAgIGxldCBkYXRhUm91dGVyQ29udGV4dCA9IFJlYWN0X19uYW1lc3BhY2UudXNlTWVtbygoKSA9PiAoe1xuICAgICAgcm91dGVyOiByb3V0ZXIkMSxcbiAgICAgIG5hdmlnYXRvcixcbiAgICAgIHN0YXRpYzogZmFsc2UsXG4gICAgICBiYXNlbmFtZVxuICAgIH0pLCBbcm91dGVyJDEsIG5hdmlnYXRvciwgYmFzZW5hbWVdKTtcblxuICAgIC8vIFRoZSBmcmFnbWVudCBhbmQge251bGx9IGhlcmUgYXJlIGltcG9ydGFudCEgIFdlIG5lZWQgdGhlbSB0byBrZWVwIFJlYWN0IDE4J3NcbiAgICAvLyB1c2VJZCBoYXBweSB3aGVuIHdlIGFyZSBzZXJ2ZXItcmVuZGVyaW5nIHNpbmNlIHdlIG1heSBoYXZlIGEgPHNjcmlwdD4gaGVyZVxuICAgIC8vIGNvbnRhaW5pbmcgdGhlIGh5ZHJhdGVkIHNlcnZlci1zaWRlIHN0YXRpY0NvbnRleHQgKGZyb20gU3RhdGljUm91dGVyUHJvdmlkZXIpLlxuICAgIC8vIHVzZUlkIHJlbGllcyBvbiB0aGUgY29tcG9uZW50IHRyZWUgc3RydWN0dXJlIHRvIGdlbmVyYXRlIGRldGVybWluaXN0aWMgaWQnc1xuICAgIC8vIHNvIHdlIG5lZWQgdG8gZW5zdXJlIGl0IHJlbWFpbnMgdGhlIHNhbWUgb24gdGhlIGNsaWVudCBldmVuIHRob3VnaFxuICAgIC8vIHdlIGRvbid0IG5lZWQgdGhlIDxzY3JpcHQ+IHRhZ1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFJlYWN0X19uYW1lc3BhY2UuRnJhZ21lbnQsIG51bGwsIC8qI19fUFVSRV9fKi9SZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoRGF0YVJvdXRlckNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgIHZhbHVlOiBkYXRhUm91dGVyQ29udGV4dFxuICAgIH0sIC8qI19fUFVSRV9fKi9SZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoRGF0YVJvdXRlclN0YXRlQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgdmFsdWU6IHN0YXRlXG4gICAgfSwgLyojX19QVVJFX18qL1JlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChSb3V0ZXIsIHtcbiAgICAgIGJhc2VuYW1lOiBiYXNlbmFtZSxcbiAgICAgIGxvY2F0aW9uOiBzdGF0ZS5sb2NhdGlvbixcbiAgICAgIG5hdmlnYXRpb25UeXBlOiBzdGF0ZS5oaXN0b3J5QWN0aW9uLFxuICAgICAgbmF2aWdhdG9yOiBuYXZpZ2F0b3IsXG4gICAgICBmdXR1cmU6IHtcbiAgICAgICAgdjdfcmVsYXRpdmVTcGxhdFBhdGg6IHJvdXRlciQxLmZ1dHVyZS52N19yZWxhdGl2ZVNwbGF0UGF0aFxuICAgICAgfVxuICAgIH0sIHN0YXRlLmluaXRpYWxpemVkIHx8IHJvdXRlciQxLmZ1dHVyZS52N19wYXJ0aWFsSHlkcmF0aW9uID8gLyojX19QVVJFX18qL1JlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChEYXRhUm91dGVzLCB7XG4gICAgICByb3V0ZXM6IHJvdXRlciQxLnJvdXRlcyxcbiAgICAgIGZ1dHVyZTogcm91dGVyJDEuZnV0dXJlLFxuICAgICAgc3RhdGU6IHN0YXRlXG4gICAgfSkgOiBmYWxsYmFja0VsZW1lbnQpKSksIG51bGwpO1xuICB9XG4gIGZ1bmN0aW9uIERhdGFSb3V0ZXMoX3JlZjIpIHtcbiAgICBsZXQge1xuICAgICAgcm91dGVzLFxuICAgICAgZnV0dXJlLFxuICAgICAgc3RhdGVcbiAgICB9ID0gX3JlZjI7XG4gICAgcmV0dXJuIHVzZVJvdXRlc0ltcGwocm91dGVzLCB1bmRlZmluZWQsIHN0YXRlLCBmdXR1cmUpO1xuICB9XG4gIC8qKlxuICAgKiBBIGA8Um91dGVyPmAgdGhhdCBzdG9yZXMgYWxsIGVudHJpZXMgaW4gbWVtb3J5LlxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL3JvdXRlci1jb21wb25lbnRzL21lbW9yeS1yb3V0ZXJcbiAgICovXG4gIGZ1bmN0aW9uIE1lbW9yeVJvdXRlcihfcmVmMykge1xuICAgIGxldCB7XG4gICAgICBiYXNlbmFtZSxcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgaW5pdGlhbEVudHJpZXMsXG4gICAgICBpbml0aWFsSW5kZXgsXG4gICAgICBmdXR1cmVcbiAgICB9ID0gX3JlZjM7XG4gICAgbGV0IGhpc3RvcnlSZWYgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVJlZigpO1xuICAgIGlmIChoaXN0b3J5UmVmLmN1cnJlbnQgPT0gbnVsbCkge1xuICAgICAgaGlzdG9yeVJlZi5jdXJyZW50ID0gcm91dGVyLmNyZWF0ZU1lbW9yeUhpc3Rvcnkoe1xuICAgICAgICBpbml0aWFsRW50cmllcyxcbiAgICAgICAgaW5pdGlhbEluZGV4LFxuICAgICAgICB2NUNvbXBhdDogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGxldCBoaXN0b3J5ID0gaGlzdG9yeVJlZi5jdXJyZW50O1xuICAgIGxldCBbc3RhdGUsIHNldFN0YXRlSW1wbF0gPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVN0YXRlKHtcbiAgICAgIGFjdGlvbjogaGlzdG9yeS5hY3Rpb24sXG4gICAgICBsb2NhdGlvbjogaGlzdG9yeS5sb2NhdGlvblxuICAgIH0pO1xuICAgIGxldCB7XG4gICAgICB2N19zdGFydFRyYW5zaXRpb25cbiAgICB9ID0gZnV0dXJlIHx8IHt9O1xuICAgIGxldCBzZXRTdGF0ZSA9IFJlYWN0X19uYW1lc3BhY2UudXNlQ2FsbGJhY2sobmV3U3RhdGUgPT4ge1xuICAgICAgdjdfc3RhcnRUcmFuc2l0aW9uICYmIHN0YXJ0VHJhbnNpdGlvbkltcGwgPyBzdGFydFRyYW5zaXRpb25JbXBsKCgpID0+IHNldFN0YXRlSW1wbChuZXdTdGF0ZSkpIDogc2V0U3RhdGVJbXBsKG5ld1N0YXRlKTtcbiAgICB9LCBbc2V0U3RhdGVJbXBsLCB2N19zdGFydFRyYW5zaXRpb25dKTtcbiAgICBSZWFjdF9fbmFtZXNwYWNlLnVzZUxheW91dEVmZmVjdCgoKSA9PiBoaXN0b3J5Lmxpc3RlbihzZXRTdGF0ZSksIFtoaXN0b3J5LCBzZXRTdGF0ZV0pO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFJvdXRlciwge1xuICAgICAgYmFzZW5hbWU6IGJhc2VuYW1lLFxuICAgICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgICAgbG9jYXRpb246IHN0YXRlLmxvY2F0aW9uLFxuICAgICAgbmF2aWdhdGlvblR5cGU6IHN0YXRlLmFjdGlvbixcbiAgICAgIG5hdmlnYXRvcjogaGlzdG9yeSxcbiAgICAgIGZ1dHVyZTogZnV0dXJlXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENoYW5nZXMgdGhlIGN1cnJlbnQgbG9jYXRpb24uXG4gICAqXG4gICAqIE5vdGU6IFRoaXMgQVBJIGlzIG1vc3RseSB1c2VmdWwgaW4gUmVhY3QuQ29tcG9uZW50IHN1YmNsYXNzZXMgdGhhdCBhcmUgbm90XG4gICAqIGFibGUgdG8gdXNlIGhvb2tzLiBJbiBmdW5jdGlvbmFsIGNvbXBvbmVudHMsIHdlIHJlY29tbWVuZCB5b3UgdXNlIHRoZVxuICAgKiBgdXNlTmF2aWdhdGVgIGhvb2sgaW5zdGVhZC5cbiAgICpcbiAgICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9jb21wb25lbnRzL25hdmlnYXRlXG4gICAqL1xuICBmdW5jdGlvbiBOYXZpZ2F0ZShfcmVmNCkge1xuICAgIGxldCB7XG4gICAgICB0byxcbiAgICAgIHJlcGxhY2UsXG4gICAgICBzdGF0ZSxcbiAgICAgIHJlbGF0aXZlXG4gICAgfSA9IF9yZWY0O1xuICAgICF1c2VJblJvdXRlckNvbnRleHQoKSA/IHJvdXRlci5VTlNBRkVfaW52YXJpYW50KGZhbHNlLCAvLyBUT0RPOiBUaGlzIGVycm9yIGlzIHByb2JhYmx5IGJlY2F1c2UgdGhleSBzb21laG93IGhhdmUgMiB2ZXJzaW9ucyBvZlxuICAgIC8vIHRoZSByb3V0ZXIgbG9hZGVkLiBXZSBjYW4gaGVscCB0aGVtIHVuZGVyc3RhbmQgaG93IHRvIGF2b2lkIHRoYXQuXG4gICAgXCI8TmF2aWdhdGU+IG1heSBiZSB1c2VkIG9ubHkgaW4gdGhlIGNvbnRleHQgb2YgYSA8Um91dGVyPiBjb21wb25lbnQuXCIpICA6IHZvaWQgMDtcbiAgICBsZXQge1xuICAgICAgZnV0dXJlLFxuICAgICAgc3RhdGljOiBpc1N0YXRpY1xuICAgIH0gPSBSZWFjdF9fbmFtZXNwYWNlLnVzZUNvbnRleHQoTmF2aWdhdGlvbkNvbnRleHQpO1xuICAgIHJvdXRlci5VTlNBRkVfd2FybmluZyghaXNTdGF0aWMsIFwiPE5hdmlnYXRlPiBtdXN0IG5vdCBiZSB1c2VkIG9uIHRoZSBpbml0aWFsIHJlbmRlciBpbiBhIDxTdGF0aWNSb3V0ZXI+LiBcIiArIFwiVGhpcyBpcyBhIG5vLW9wLCBidXQgeW91IHNob3VsZCBtb2RpZnkgeW91ciBjb2RlIHNvIHRoZSA8TmF2aWdhdGU+IGlzIFwiICsgXCJvbmx5IGV2ZXIgcmVuZGVyZWQgaW4gcmVzcG9uc2UgdG8gc29tZSB1c2VyIGludGVyYWN0aW9uIG9yIHN0YXRlIGNoYW5nZS5cIikgO1xuICAgIGxldCB7XG4gICAgICBtYXRjaGVzXG4gICAgfSA9IFJlYWN0X19uYW1lc3BhY2UudXNlQ29udGV4dChSb3V0ZUNvbnRleHQpO1xuICAgIGxldCB7XG4gICAgICBwYXRobmFtZTogbG9jYXRpb25QYXRobmFtZVxuICAgIH0gPSB1c2VMb2NhdGlvbigpO1xuICAgIGxldCBuYXZpZ2F0ZSA9IHVzZU5hdmlnYXRlKCk7XG5cbiAgICAvLyBSZXNvbHZlIHRoZSBwYXRoIG91dHNpZGUgb2YgdGhlIGVmZmVjdCBzbyB0aGF0IHdoZW4gZWZmZWN0cyBydW4gdHdpY2UgaW5cbiAgICAvLyBTdHJpY3RNb2RlIHRoZXkgbmF2aWdhdGUgdG8gdGhlIHNhbWUgcGxhY2VcbiAgICBsZXQgcGF0aCA9IHJvdXRlci5yZXNvbHZlVG8odG8sIHJvdXRlci5VTlNBRkVfZ2V0UmVzb2x2ZVRvTWF0Y2hlcyhtYXRjaGVzLCBmdXR1cmUudjdfcmVsYXRpdmVTcGxhdFBhdGgpLCBsb2NhdGlvblBhdGhuYW1lLCByZWxhdGl2ZSA9PT0gXCJwYXRoXCIpO1xuICAgIGxldCBqc29uUGF0aCA9IEpTT04uc3RyaW5naWZ5KHBhdGgpO1xuICAgIFJlYWN0X19uYW1lc3BhY2UudXNlRWZmZWN0KCgpID0+IG5hdmlnYXRlKEpTT04ucGFyc2UoanNvblBhdGgpLCB7XG4gICAgICByZXBsYWNlLFxuICAgICAgc3RhdGUsXG4gICAgICByZWxhdGl2ZVxuICAgIH0pLCBbbmF2aWdhdGUsIGpzb25QYXRoLCByZWxhdGl2ZSwgcmVwbGFjZSwgc3RhdGVdKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICAvKipcbiAgICogUmVuZGVycyB0aGUgY2hpbGQgcm91dGUncyBlbGVtZW50LCBpZiB0aGVyZSBpcyBvbmUuXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vY29tcG9uZW50cy9vdXRsZXRcbiAgICovXG4gIGZ1bmN0aW9uIE91dGxldChwcm9wcykge1xuICAgIHJldHVybiB1c2VPdXRsZXQocHJvcHMuY29udGV4dCk7XG4gIH1cbiAgLyoqXG4gICAqIERlY2xhcmVzIGFuIGVsZW1lbnQgdGhhdCBzaG91bGQgYmUgcmVuZGVyZWQgYXQgYSBjZXJ0YWluIFVSTCBwYXRoLlxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2NvbXBvbmVudHMvcm91dGVcbiAgICovXG4gIGZ1bmN0aW9uIFJvdXRlKF9wcm9wcykge1xuICAgIHJvdXRlci5VTlNBRkVfaW52YXJpYW50KGZhbHNlLCBcIkEgPFJvdXRlPiBpcyBvbmx5IGV2ZXIgdG8gYmUgdXNlZCBhcyB0aGUgY2hpbGQgb2YgPFJvdXRlcz4gZWxlbWVudCwgXCIgKyBcIm5ldmVyIHJlbmRlcmVkIGRpcmVjdGx5LiBQbGVhc2Ugd3JhcCB5b3VyIDxSb3V0ZT4gaW4gYSA8Um91dGVzPi5cIikgIDtcbiAgfVxuICAvKipcbiAgICogUHJvdmlkZXMgbG9jYXRpb24gY29udGV4dCBmb3IgdGhlIHJlc3Qgb2YgdGhlIGFwcC5cbiAgICpcbiAgICogTm90ZTogWW91IHVzdWFsbHkgd29uJ3QgcmVuZGVyIGEgYDxSb3V0ZXI+YCBkaXJlY3RseS4gSW5zdGVhZCwgeW91J2xsIHJlbmRlciBhXG4gICAqIHJvdXRlciB0aGF0IGlzIG1vcmUgc3BlY2lmaWMgdG8geW91ciBlbnZpcm9ubWVudCBzdWNoIGFzIGEgYDxCcm93c2VyUm91dGVyPmBcbiAgICogaW4gd2ViIGJyb3dzZXJzIG9yIGEgYDxTdGF0aWNSb3V0ZXI+YCBmb3Igc2VydmVyIHJlbmRlcmluZy5cbiAgICpcbiAgICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9yb3V0ZXItY29tcG9uZW50cy9yb3V0ZXJcbiAgICovXG4gIGZ1bmN0aW9uIFJvdXRlcihfcmVmNSkge1xuICAgIGxldCB7XG4gICAgICBiYXNlbmFtZTogYmFzZW5hbWVQcm9wID0gXCIvXCIsXG4gICAgICBjaGlsZHJlbiA9IG51bGwsXG4gICAgICBsb2NhdGlvbjogbG9jYXRpb25Qcm9wLFxuICAgICAgbmF2aWdhdGlvblR5cGUgPSByb3V0ZXIuQWN0aW9uLlBvcCxcbiAgICAgIG5hdmlnYXRvcixcbiAgICAgIHN0YXRpYzogc3RhdGljUHJvcCA9IGZhbHNlLFxuICAgICAgZnV0dXJlXG4gICAgfSA9IF9yZWY1O1xuICAgICEhdXNlSW5Sb3V0ZXJDb250ZXh0KCkgPyByb3V0ZXIuVU5TQUZFX2ludmFyaWFudChmYWxzZSwgXCJZb3UgY2Fubm90IHJlbmRlciBhIDxSb3V0ZXI+IGluc2lkZSBhbm90aGVyIDxSb3V0ZXI+LlwiICsgXCIgWW91IHNob3VsZCBuZXZlciBoYXZlIG1vcmUgdGhhbiBvbmUgaW4geW91ciBhcHAuXCIpICA6IHZvaWQgMDtcblxuICAgIC8vIFByZXNlcnZlIHRyYWlsaW5nIHNsYXNoZXMgb24gYmFzZW5hbWUsIHNvIHdlIGNhbiBsZXQgdGhlIHVzZXIgY29udHJvbFxuICAgIC8vIHRoZSBlbmZvcmNlbWVudCBvZiB0cmFpbGluZyBzbGFzaGVzIHRocm91Z2hvdXQgdGhlIGFwcFxuICAgIGxldCBiYXNlbmFtZSA9IGJhc2VuYW1lUHJvcC5yZXBsYWNlKC9eXFwvKi8sIFwiL1wiKTtcbiAgICBsZXQgbmF2aWdhdGlvbkNvbnRleHQgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZU1lbW8oKCkgPT4gKHtcbiAgICAgIGJhc2VuYW1lLFxuICAgICAgbmF2aWdhdG9yLFxuICAgICAgc3RhdGljOiBzdGF0aWNQcm9wLFxuICAgICAgZnV0dXJlOiBfZXh0ZW5kcyh7XG4gICAgICAgIHY3X3JlbGF0aXZlU3BsYXRQYXRoOiBmYWxzZVxuICAgICAgfSwgZnV0dXJlKVxuICAgIH0pLCBbYmFzZW5hbWUsIGZ1dHVyZSwgbmF2aWdhdG9yLCBzdGF0aWNQcm9wXSk7XG4gICAgaWYgKHR5cGVvZiBsb2NhdGlvblByb3AgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGxvY2F0aW9uUHJvcCA9IHJvdXRlci5wYXJzZVBhdGgobG9jYXRpb25Qcm9wKTtcbiAgICB9XG4gICAgbGV0IHtcbiAgICAgIHBhdGhuYW1lID0gXCIvXCIsXG4gICAgICBzZWFyY2ggPSBcIlwiLFxuICAgICAgaGFzaCA9IFwiXCIsXG4gICAgICBzdGF0ZSA9IG51bGwsXG4gICAgICBrZXkgPSBcImRlZmF1bHRcIlxuICAgIH0gPSBsb2NhdGlvblByb3A7XG4gICAgbGV0IGxvY2F0aW9uQ29udGV4dCA9IFJlYWN0X19uYW1lc3BhY2UudXNlTWVtbygoKSA9PiB7XG4gICAgICBsZXQgdHJhaWxpbmdQYXRobmFtZSA9IHJvdXRlci5zdHJpcEJhc2VuYW1lKHBhdGhuYW1lLCBiYXNlbmFtZSk7XG4gICAgICBpZiAodHJhaWxpbmdQYXRobmFtZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbG9jYXRpb246IHtcbiAgICAgICAgICBwYXRobmFtZTogdHJhaWxpbmdQYXRobmFtZSxcbiAgICAgICAgICBzZWFyY2gsXG4gICAgICAgICAgaGFzaCxcbiAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICBrZXlcbiAgICAgICAgfSxcbiAgICAgICAgbmF2aWdhdGlvblR5cGVcbiAgICAgIH07XG4gICAgfSwgW2Jhc2VuYW1lLCBwYXRobmFtZSwgc2VhcmNoLCBoYXNoLCBzdGF0ZSwga2V5LCBuYXZpZ2F0aW9uVHlwZV0pO1xuICAgIHJvdXRlci5VTlNBRkVfd2FybmluZyhsb2NhdGlvbkNvbnRleHQgIT0gbnVsbCwgXCI8Um91dGVyIGJhc2VuYW1lPVxcXCJcIiArIGJhc2VuYW1lICsgXCJcXFwiPiBpcyBub3QgYWJsZSB0byBtYXRjaCB0aGUgVVJMIFwiICsgKFwiXFxcIlwiICsgcGF0aG5hbWUgKyBzZWFyY2ggKyBoYXNoICsgXCJcXFwiIGJlY2F1c2UgaXQgZG9lcyBub3Qgc3RhcnQgd2l0aCB0aGUgXCIpICsgXCJiYXNlbmFtZSwgc28gdGhlIDxSb3V0ZXI+IHdvbid0IHJlbmRlciBhbnl0aGluZy5cIikgO1xuICAgIGlmIChsb2NhdGlvbkNvbnRleHQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KE5hdmlnYXRpb25Db250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICB2YWx1ZTogbmF2aWdhdGlvbkNvbnRleHRcbiAgICB9LCAvKiNfX1BVUkVfXyovUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KExvY2F0aW9uQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgICAgdmFsdWU6IGxvY2F0aW9uQ29udGV4dFxuICAgIH0pKTtcbiAgfVxuICAvKipcbiAgICogQSBjb250YWluZXIgZm9yIGEgbmVzdGVkIHRyZWUgb2YgYDxSb3V0ZT5gIGVsZW1lbnRzIHRoYXQgcmVuZGVycyB0aGUgYnJhbmNoXG4gICAqIHRoYXQgYmVzdCBtYXRjaGVzIHRoZSBjdXJyZW50IGxvY2F0aW9uLlxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2NvbXBvbmVudHMvcm91dGVzXG4gICAqL1xuICBmdW5jdGlvbiBSb3V0ZXMoX3JlZjYpIHtcbiAgICBsZXQge1xuICAgICAgY2hpbGRyZW4sXG4gICAgICBsb2NhdGlvblxuICAgIH0gPSBfcmVmNjtcbiAgICByZXR1cm4gdXNlUm91dGVzKGNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbihjaGlsZHJlbiksIGxvY2F0aW9uKTtcbiAgfVxuICAvKipcbiAgICogQ29tcG9uZW50IHRvIHVzZSBmb3IgcmVuZGVyaW5nIGxhemlseSBsb2FkZWQgZGF0YSBmcm9tIHJldHVybmluZyBkZWZlcigpXG4gICAqIGluIGEgbG9hZGVyIGZ1bmN0aW9uXG4gICAqL1xuICBmdW5jdGlvbiBBd2FpdChfcmVmNykge1xuICAgIGxldCB7XG4gICAgICBjaGlsZHJlbixcbiAgICAgIGVycm9yRWxlbWVudCxcbiAgICAgIHJlc29sdmVcbiAgICB9ID0gX3JlZjc7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoQXdhaXRFcnJvckJvdW5kYXJ5LCB7XG4gICAgICByZXNvbHZlOiByZXNvbHZlLFxuICAgICAgZXJyb3JFbGVtZW50OiBlcnJvckVsZW1lbnRcbiAgICB9LCAvKiNfX1BVUkVfXyovUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFJlc29sdmVBd2FpdCwgbnVsbCwgY2hpbGRyZW4pKTtcbiAgfVxuICB2YXIgQXdhaXRSZW5kZXJTdGF0dXMgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKEF3YWl0UmVuZGVyU3RhdHVzKSB7XG4gICAgQXdhaXRSZW5kZXJTdGF0dXNbQXdhaXRSZW5kZXJTdGF0dXNbXCJwZW5kaW5nXCJdID0gMF0gPSBcInBlbmRpbmdcIjtcbiAgICBBd2FpdFJlbmRlclN0YXR1c1tBd2FpdFJlbmRlclN0YXR1c1tcInN1Y2Nlc3NcIl0gPSAxXSA9IFwic3VjY2Vzc1wiO1xuICAgIEF3YWl0UmVuZGVyU3RhdHVzW0F3YWl0UmVuZGVyU3RhdHVzW1wiZXJyb3JcIl0gPSAyXSA9IFwiZXJyb3JcIjtcbiAgICByZXR1cm4gQXdhaXRSZW5kZXJTdGF0dXM7XG4gIH0oQXdhaXRSZW5kZXJTdGF0dXMgfHwge30pO1xuICBjb25zdCBuZXZlclNldHRsZWRQcm9taXNlID0gbmV3IFByb21pc2UoKCkgPT4ge30pO1xuICBjbGFzcyBBd2FpdEVycm9yQm91bmRhcnkgZXh0ZW5kcyBSZWFjdF9fbmFtZXNwYWNlLkNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgIHN1cGVyKHByb3BzKTtcbiAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgIGVycm9yOiBudWxsXG4gICAgICB9O1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKGVycm9yKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBlcnJvclxuICAgICAgfTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkQ2F0Y2goZXJyb3IsIGVycm9ySW5mbykge1xuICAgICAgY29uc29sZS5lcnJvcihcIjxBd2FpdD4gY2F1Z2h0IHRoZSBmb2xsb3dpbmcgZXJyb3IgZHVyaW5nIHJlbmRlclwiLCBlcnJvciwgZXJyb3JJbmZvKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgbGV0IHtcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIGVycm9yRWxlbWVudCxcbiAgICAgICAgcmVzb2x2ZVxuICAgICAgfSA9IHRoaXMucHJvcHM7XG4gICAgICBsZXQgcHJvbWlzZSA9IG51bGw7XG4gICAgICBsZXQgc3RhdHVzID0gQXdhaXRSZW5kZXJTdGF0dXMucGVuZGluZztcbiAgICAgIGlmICghKHJlc29sdmUgaW5zdGFuY2VvZiBQcm9taXNlKSkge1xuICAgICAgICAvLyBEaWRuJ3QgZ2V0IGEgcHJvbWlzZSAtIHByb3ZpZGUgYXMgYSByZXNvbHZlZCBwcm9taXNlXG4gICAgICAgIHN0YXR1cyA9IEF3YWl0UmVuZGVyU3RhdHVzLnN1Y2Nlc3M7XG4gICAgICAgIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb21pc2UsIFwiX3RyYWNrZWRcIiwge1xuICAgICAgICAgIGdldDogKCkgPT4gdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb21pc2UsIFwiX2RhdGFcIiwge1xuICAgICAgICAgIGdldDogKCkgPT4gcmVzb2x2ZVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0ZS5lcnJvcikge1xuICAgICAgICAvLyBDYXVnaHQgYSByZW5kZXIgZXJyb3IsIHByb3ZpZGUgaXQgYXMgYSByZWplY3RlZCBwcm9taXNlXG4gICAgICAgIHN0YXR1cyA9IEF3YWl0UmVuZGVyU3RhdHVzLmVycm9yO1xuICAgICAgICBsZXQgcmVuZGVyRXJyb3IgPSB0aGlzLnN0YXRlLmVycm9yO1xuICAgICAgICBwcm9taXNlID0gUHJvbWlzZS5yZWplY3QoKS5jYXRjaCgoKSA9PiB7fSk7IC8vIEF2b2lkIHVuaGFuZGxlZCByZWplY3Rpb24gd2FybmluZ3NcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb21pc2UsIFwiX3RyYWNrZWRcIiwge1xuICAgICAgICAgIGdldDogKCkgPT4gdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb21pc2UsIFwiX2Vycm9yXCIsIHtcbiAgICAgICAgICBnZXQ6ICgpID0+IHJlbmRlckVycm9yXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChyZXNvbHZlLl90cmFja2VkKSB7XG4gICAgICAgIC8vIEFscmVhZHkgdHJhY2tlZCBwcm9taXNlIC0gY2hlY2sgY29udGVudHNcbiAgICAgICAgcHJvbWlzZSA9IHJlc29sdmU7XG4gICAgICAgIHN0YXR1cyA9IHByb21pc2UuX2Vycm9yICE9PSB1bmRlZmluZWQgPyBBd2FpdFJlbmRlclN0YXR1cy5lcnJvciA6IHByb21pc2UuX2RhdGEgIT09IHVuZGVmaW5lZCA/IEF3YWl0UmVuZGVyU3RhdHVzLnN1Y2Nlc3MgOiBBd2FpdFJlbmRlclN0YXR1cy5wZW5kaW5nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUmF3ICh1bnRyYWNrZWQpIHByb21pc2UgLSB0cmFjayBpdFxuICAgICAgICBzdGF0dXMgPSBBd2FpdFJlbmRlclN0YXR1cy5wZW5kaW5nO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVzb2x2ZSwgXCJfdHJhY2tlZFwiLCB7XG4gICAgICAgICAgZ2V0OiAoKSA9PiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBwcm9taXNlID0gcmVzb2x2ZS50aGVuKGRhdGEgPT4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlc29sdmUsIFwiX2RhdGFcIiwge1xuICAgICAgICAgIGdldDogKCkgPT4gZGF0YVxuICAgICAgICB9KSwgZXJyb3IgPT4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlc29sdmUsIFwiX2Vycm9yXCIsIHtcbiAgICAgICAgICBnZXQ6ICgpID0+IGVycm9yXG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0dXMgPT09IEF3YWl0UmVuZGVyU3RhdHVzLmVycm9yICYmIHByb21pc2UuX2Vycm9yIGluc3RhbmNlb2Ygcm91dGVyLkFib3J0ZWREZWZlcnJlZEVycm9yKSB7XG4gICAgICAgIC8vIEZyZWV6ZSB0aGUgVUkgYnkgdGhyb3dpbmcgYSBuZXZlciByZXNvbHZlZCBwcm9taXNlXG4gICAgICAgIHRocm93IG5ldmVyU2V0dGxlZFByb21pc2U7XG4gICAgICB9XG4gICAgICBpZiAoc3RhdHVzID09PSBBd2FpdFJlbmRlclN0YXR1cy5lcnJvciAmJiAhZXJyb3JFbGVtZW50KSB7XG4gICAgICAgIC8vIE5vIGVycm9yRWxlbWVudCwgdGhyb3cgdG8gdGhlIG5lYXJlc3Qgcm91dGUtbGV2ZWwgZXJyb3IgYm91bmRhcnlcbiAgICAgICAgdGhyb3cgcHJvbWlzZS5fZXJyb3I7XG4gICAgICB9XG4gICAgICBpZiAoc3RhdHVzID09PSBBd2FpdFJlbmRlclN0YXR1cy5lcnJvcikge1xuICAgICAgICAvLyBSZW5kZXIgdmlhIG91ciBlcnJvckVsZW1lbnRcbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoQXdhaXRDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgICAgdmFsdWU6IHByb21pc2UsXG4gICAgICAgICAgY2hpbGRyZW46IGVycm9yRWxlbWVudFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0dXMgPT09IEF3YWl0UmVuZGVyU3RhdHVzLnN1Y2Nlc3MpIHtcbiAgICAgICAgLy8gUmVuZGVyIGNoaWxkcmVuIHdpdGggcmVzb2x2ZWQgdmFsdWVcbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoQXdhaXRDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgICAgdmFsdWU6IHByb21pc2UsXG4gICAgICAgICAgY2hpbGRyZW46IGNoaWxkcmVuXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBUaHJvdyB0byB0aGUgc3VzcGVuc2UgYm91bmRhcnlcbiAgICAgIHRocm93IHByb21pc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEluZGlyZWN0aW9uIHRvIGxldmVyYWdlIHVzZUFzeW5jVmFsdWUgZm9yIGEgcmVuZGVyLXByb3AgQVBJIG9uIGA8QXdhaXQ+YFxuICAgKi9cbiAgZnVuY3Rpb24gUmVzb2x2ZUF3YWl0KF9yZWY4KSB7XG4gICAgbGV0IHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSA9IF9yZWY4O1xuICAgIGxldCBkYXRhID0gdXNlQXN5bmNWYWx1ZSgpO1xuICAgIGxldCB0b1JlbmRlciA9IHR5cGVvZiBjaGlsZHJlbiA9PT0gXCJmdW5jdGlvblwiID8gY2hpbGRyZW4oZGF0YSkgOiBjaGlsZHJlbjtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChSZWFjdF9fbmFtZXNwYWNlLkZyYWdtZW50LCBudWxsLCB0b1JlbmRlcik7XG4gIH1cblxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIC8vIFVUSUxTXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHJvdXRlIGNvbmZpZyBmcm9tIGEgUmVhY3QgXCJjaGlsZHJlblwiIG9iamVjdCwgd2hpY2ggaXMgdXN1YWxseVxuICAgKiBlaXRoZXIgYSBgPFJvdXRlPmAgZWxlbWVudCBvciBhbiBhcnJheSBvZiB0aGVtLiBVc2VkIGludGVybmFsbHkgYnlcbiAgICogYDxSb3V0ZXM+YCB0byBjcmVhdGUgYSByb3V0ZSBjb25maWcgZnJvbSBpdHMgY2hpbGRyZW4uXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vdXRpbHMvY3JlYXRlLXJvdXRlcy1mcm9tLWNoaWxkcmVuXG4gICAqL1xuICBmdW5jdGlvbiBjcmVhdGVSb3V0ZXNGcm9tQ2hpbGRyZW4oY2hpbGRyZW4sIHBhcmVudFBhdGgpIHtcbiAgICBpZiAocGFyZW50UGF0aCA9PT0gdm9pZCAwKSB7XG4gICAgICBwYXJlbnRQYXRoID0gW107XG4gICAgfVxuICAgIGxldCByb3V0ZXMgPSBbXTtcbiAgICBSZWFjdF9fbmFtZXNwYWNlLkNoaWxkcmVuLmZvckVhY2goY2hpbGRyZW4sIChlbGVtZW50LCBpbmRleCkgPT4ge1xuICAgICAgaWYgKCEgLyojX19QVVJFX18qL1JlYWN0X19uYW1lc3BhY2UuaXNWYWxpZEVsZW1lbnQoZWxlbWVudCkpIHtcbiAgICAgICAgLy8gSWdub3JlIG5vbi1lbGVtZW50cy4gVGhpcyBhbGxvd3MgcGVvcGxlIHRvIG1vcmUgZWFzaWx5IGlubGluZVxuICAgICAgICAvLyBjb25kaXRpb25hbHMgaW4gdGhlaXIgcm91dGUgY29uZmlnLlxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZXQgdHJlZVBhdGggPSBbLi4ucGFyZW50UGF0aCwgaW5kZXhdO1xuICAgICAgaWYgKGVsZW1lbnQudHlwZSA9PT0gUmVhY3RfX25hbWVzcGFjZS5GcmFnbWVudCkge1xuICAgICAgICAvLyBUcmFuc3BhcmVudGx5IHN1cHBvcnQgUmVhY3QuRnJhZ21lbnQgYW5kIGl0cyBjaGlsZHJlbi5cbiAgICAgICAgcm91dGVzLnB1c2guYXBwbHkocm91dGVzLCBjcmVhdGVSb3V0ZXNGcm9tQ2hpbGRyZW4oZWxlbWVudC5wcm9wcy5jaGlsZHJlbiwgdHJlZVBhdGgpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgIShlbGVtZW50LnR5cGUgPT09IFJvdXRlKSA/IHJvdXRlci5VTlNBRkVfaW52YXJpYW50KGZhbHNlLCBcIltcIiArICh0eXBlb2YgZWxlbWVudC50eXBlID09PSBcInN0cmluZ1wiID8gZWxlbWVudC50eXBlIDogZWxlbWVudC50eXBlLm5hbWUpICsgXCJdIGlzIG5vdCBhIDxSb3V0ZT4gY29tcG9uZW50LiBBbGwgY29tcG9uZW50IGNoaWxkcmVuIG9mIDxSb3V0ZXM+IG11c3QgYmUgYSA8Um91dGU+IG9yIDxSZWFjdC5GcmFnbWVudD5cIikgIDogdm9pZCAwO1xuICAgICAgISghZWxlbWVudC5wcm9wcy5pbmRleCB8fCAhZWxlbWVudC5wcm9wcy5jaGlsZHJlbikgPyByb3V0ZXIuVU5TQUZFX2ludmFyaWFudChmYWxzZSwgXCJBbiBpbmRleCByb3V0ZSBjYW5ub3QgaGF2ZSBjaGlsZCByb3V0ZXMuXCIpICA6IHZvaWQgMDtcbiAgICAgIGxldCByb3V0ZSA9IHtcbiAgICAgICAgaWQ6IGVsZW1lbnQucHJvcHMuaWQgfHwgdHJlZVBhdGguam9pbihcIi1cIiksXG4gICAgICAgIGNhc2VTZW5zaXRpdmU6IGVsZW1lbnQucHJvcHMuY2FzZVNlbnNpdGl2ZSxcbiAgICAgICAgZWxlbWVudDogZWxlbWVudC5wcm9wcy5lbGVtZW50LFxuICAgICAgICBDb21wb25lbnQ6IGVsZW1lbnQucHJvcHMuQ29tcG9uZW50LFxuICAgICAgICBpbmRleDogZWxlbWVudC5wcm9wcy5pbmRleCxcbiAgICAgICAgcGF0aDogZWxlbWVudC5wcm9wcy5wYXRoLFxuICAgICAgICBsb2FkZXI6IGVsZW1lbnQucHJvcHMubG9hZGVyLFxuICAgICAgICBhY3Rpb246IGVsZW1lbnQucHJvcHMuYWN0aW9uLFxuICAgICAgICBlcnJvckVsZW1lbnQ6IGVsZW1lbnQucHJvcHMuZXJyb3JFbGVtZW50LFxuICAgICAgICBFcnJvckJvdW5kYXJ5OiBlbGVtZW50LnByb3BzLkVycm9yQm91bmRhcnksXG4gICAgICAgIGhhc0Vycm9yQm91bmRhcnk6IGVsZW1lbnQucHJvcHMuRXJyb3JCb3VuZGFyeSAhPSBudWxsIHx8IGVsZW1lbnQucHJvcHMuZXJyb3JFbGVtZW50ICE9IG51bGwsXG4gICAgICAgIHNob3VsZFJldmFsaWRhdGU6IGVsZW1lbnQucHJvcHMuc2hvdWxkUmV2YWxpZGF0ZSxcbiAgICAgICAgaGFuZGxlOiBlbGVtZW50LnByb3BzLmhhbmRsZSxcbiAgICAgICAgbGF6eTogZWxlbWVudC5wcm9wcy5sYXp5XG4gICAgICB9O1xuICAgICAgaWYgKGVsZW1lbnQucHJvcHMuY2hpbGRyZW4pIHtcbiAgICAgICAgcm91dGUuY2hpbGRyZW4gPSBjcmVhdGVSb3V0ZXNGcm9tQ2hpbGRyZW4oZWxlbWVudC5wcm9wcy5jaGlsZHJlbiwgdHJlZVBhdGgpO1xuICAgICAgfVxuICAgICAgcm91dGVzLnB1c2gocm91dGUpO1xuICAgIH0pO1xuICAgIHJldHVybiByb3V0ZXM7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgcmVzdWx0IG9mIGBtYXRjaFJvdXRlcygpYCBpbnRvIGEgUmVhY3QgZWxlbWVudC5cbiAgICovXG4gIGZ1bmN0aW9uIHJlbmRlck1hdGNoZXMobWF0Y2hlcykge1xuICAgIHJldHVybiBfcmVuZGVyTWF0Y2hlcyhtYXRjaGVzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcFJvdXRlUHJvcGVydGllcyhyb3V0ZSkge1xuICAgIGxldCB1cGRhdGVzID0ge1xuICAgICAgLy8gTm90ZTogdGhpcyBjaGVjayBhbHNvIG9jY3VycyBpbiBjcmVhdGVSb3V0ZXNGcm9tQ2hpbGRyZW4gc28gdXBkYXRlXG4gICAgICAvLyB0aGVyZSBpZiB5b3UgY2hhbmdlIHRoaXMgLS0gcGxlYXNlIGFuZCB0aGFuayB5b3UhXG4gICAgICBoYXNFcnJvckJvdW5kYXJ5OiByb3V0ZS5FcnJvckJvdW5kYXJ5ICE9IG51bGwgfHwgcm91dGUuZXJyb3JFbGVtZW50ICE9IG51bGxcbiAgICB9O1xuICAgIGlmIChyb3V0ZS5Db21wb25lbnQpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKHJvdXRlLmVsZW1lbnQpIHtcbiAgICAgICAgICByb3V0ZXIuVU5TQUZFX3dhcm5pbmcoZmFsc2UsIFwiWW91IHNob3VsZCBub3QgaW5jbHVkZSBib3RoIGBDb21wb25lbnRgIGFuZCBgZWxlbWVudGAgb24geW91ciByb3V0ZSAtIFwiICsgXCJgQ29tcG9uZW50YCB3aWxsIGJlIHVzZWQuXCIpIDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgT2JqZWN0LmFzc2lnbih1cGRhdGVzLCB7XG4gICAgICAgIGVsZW1lbnQ6IC8qI19fUFVSRV9fKi9SZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQocm91dGUuQ29tcG9uZW50KSxcbiAgICAgICAgQ29tcG9uZW50OiB1bmRlZmluZWRcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAocm91dGUuSHlkcmF0ZUZhbGxiYWNrKSB7XG4gICAgICB7XG4gICAgICAgIGlmIChyb3V0ZS5oeWRyYXRlRmFsbGJhY2tFbGVtZW50KSB7XG4gICAgICAgICAgcm91dGVyLlVOU0FGRV93YXJuaW5nKGZhbHNlLCBcIllvdSBzaG91bGQgbm90IGluY2x1ZGUgYm90aCBgSHlkcmF0ZUZhbGxiYWNrYCBhbmQgYGh5ZHJhdGVGYWxsYmFja0VsZW1lbnRgIG9uIHlvdXIgcm91dGUgLSBcIiArIFwiYEh5ZHJhdGVGYWxsYmFja2Agd2lsbCBiZSB1c2VkLlwiKSA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIE9iamVjdC5hc3NpZ24odXBkYXRlcywge1xuICAgICAgICBoeWRyYXRlRmFsbGJhY2tFbGVtZW50OiAvKiNfX1BVUkVfXyovUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KHJvdXRlLkh5ZHJhdGVGYWxsYmFjayksXG4gICAgICAgIEh5ZHJhdGVGYWxsYmFjazogdW5kZWZpbmVkXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHJvdXRlLkVycm9yQm91bmRhcnkpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKHJvdXRlLmVycm9yRWxlbWVudCkge1xuICAgICAgICAgIHJvdXRlci5VTlNBRkVfd2FybmluZyhmYWxzZSwgXCJZb3Ugc2hvdWxkIG5vdCBpbmNsdWRlIGJvdGggYEVycm9yQm91bmRhcnlgIGFuZCBgZXJyb3JFbGVtZW50YCBvbiB5b3VyIHJvdXRlIC0gXCIgKyBcImBFcnJvckJvdW5kYXJ5YCB3aWxsIGJlIHVzZWQuXCIpIDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgT2JqZWN0LmFzc2lnbih1cGRhdGVzLCB7XG4gICAgICAgIGVycm9yRWxlbWVudDogLyojX19QVVJFX18qL1JlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChyb3V0ZS5FcnJvckJvdW5kYXJ5KSxcbiAgICAgICAgRXJyb3JCb3VuZGFyeTogdW5kZWZpbmVkXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHVwZGF0ZXM7XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlTWVtb3J5Um91dGVyKHJvdXRlcywgb3B0cykge1xuICAgIHJldHVybiByb3V0ZXIuY3JlYXRlUm91dGVyKHtcbiAgICAgIGJhc2VuYW1lOiBvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLmJhc2VuYW1lLFxuICAgICAgZnV0dXJlOiBfZXh0ZW5kcyh7fSwgb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5mdXR1cmUsIHtcbiAgICAgICAgdjdfcHJlcGVuZEJhc2VuYW1lOiB0cnVlXG4gICAgICB9KSxcbiAgICAgIGhpc3Rvcnk6IHJvdXRlci5jcmVhdGVNZW1vcnlIaXN0b3J5KHtcbiAgICAgICAgaW5pdGlhbEVudHJpZXM6IG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMuaW5pdGlhbEVudHJpZXMsXG4gICAgICAgIGluaXRpYWxJbmRleDogb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5pbml0aWFsSW5kZXhcbiAgICAgIH0pLFxuICAgICAgaHlkcmF0aW9uRGF0YTogb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5oeWRyYXRpb25EYXRhLFxuICAgICAgcm91dGVzLFxuICAgICAgbWFwUm91dGVQcm9wZXJ0aWVzXG4gICAgfSkuaW5pdGlhbGl6ZSgpO1xuICB9XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdBYm9ydGVkRGVmZXJyZWRFcnJvcicsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcm91dGVyLkFib3J0ZWREZWZlcnJlZEVycm9yOyB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ05hdmlnYXRpb25UeXBlJywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByb3V0ZXIuQWN0aW9uOyB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ2NyZWF0ZVBhdGgnLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJvdXRlci5jcmVhdGVQYXRoOyB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ2RlZmVyJywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByb3V0ZXIuZGVmZXI7IH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnZ2VuZXJhdGVQYXRoJywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByb3V0ZXIuZ2VuZXJhdGVQYXRoOyB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ2lzUm91dGVFcnJvclJlc3BvbnNlJywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByb3V0ZXIuaXNSb3V0ZUVycm9yUmVzcG9uc2U7IH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnanNvbicsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcm91dGVyLmpzb247IH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnbWF0Y2hQYXRoJywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByb3V0ZXIubWF0Y2hQYXRoOyB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ21hdGNoUm91dGVzJywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByb3V0ZXIubWF0Y2hSb3V0ZXM7IH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAncGFyc2VQYXRoJywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByb3V0ZXIucGFyc2VQYXRoOyB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ3JlZGlyZWN0Jywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByb3V0ZXIucmVkaXJlY3Q7IH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAncmVkaXJlY3REb2N1bWVudCcsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcm91dGVyLnJlZGlyZWN0RG9jdW1lbnQ7IH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAncmVzb2x2ZVBhdGgnLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJvdXRlci5yZXNvbHZlUGF0aDsgfVxuICB9KTtcbiAgZXhwb3J0cy5Bd2FpdCA9IEF3YWl0O1xuICBleHBvcnRzLk1lbW9yeVJvdXRlciA9IE1lbW9yeVJvdXRlcjtcbiAgZXhwb3J0cy5OYXZpZ2F0ZSA9IE5hdmlnYXRlO1xuICBleHBvcnRzLk91dGxldCA9IE91dGxldDtcbiAgZXhwb3J0cy5Sb3V0ZSA9IFJvdXRlO1xuICBleHBvcnRzLlJvdXRlciA9IFJvdXRlcjtcbiAgZXhwb3J0cy5Sb3V0ZXJQcm92aWRlciA9IFJvdXRlclByb3ZpZGVyO1xuICBleHBvcnRzLlJvdXRlcyA9IFJvdXRlcztcbiAgZXhwb3J0cy5VTlNBRkVfRGF0YVJvdXRlckNvbnRleHQgPSBEYXRhUm91dGVyQ29udGV4dDtcbiAgZXhwb3J0cy5VTlNBRkVfRGF0YVJvdXRlclN0YXRlQ29udGV4dCA9IERhdGFSb3V0ZXJTdGF0ZUNvbnRleHQ7XG4gIGV4cG9ydHMuVU5TQUZFX0xvY2F0aW9uQ29udGV4dCA9IExvY2F0aW9uQ29udGV4dDtcbiAgZXhwb3J0cy5VTlNBRkVfTmF2aWdhdGlvbkNvbnRleHQgPSBOYXZpZ2F0aW9uQ29udGV4dDtcbiAgZXhwb3J0cy5VTlNBRkVfUm91dGVDb250ZXh0ID0gUm91dGVDb250ZXh0O1xuICBleHBvcnRzLlVOU0FGRV9tYXBSb3V0ZVByb3BlcnRpZXMgPSBtYXBSb3V0ZVByb3BlcnRpZXM7XG4gIGV4cG9ydHMuVU5TQUZFX3VzZVJvdXRlSWQgPSB1c2VSb3V0ZUlkO1xuICBleHBvcnRzLlVOU0FGRV91c2VSb3V0ZXNJbXBsID0gdXNlUm91dGVzSW1wbDtcbiAgZXhwb3J0cy5jcmVhdGVNZW1vcnlSb3V0ZXIgPSBjcmVhdGVNZW1vcnlSb3V0ZXI7XG4gIGV4cG9ydHMuY3JlYXRlUm91dGVzRnJvbUNoaWxkcmVuID0gY3JlYXRlUm91dGVzRnJvbUNoaWxkcmVuO1xuICBleHBvcnRzLmNyZWF0ZVJvdXRlc0Zyb21FbGVtZW50cyA9IGNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbjtcbiAgZXhwb3J0cy5yZW5kZXJNYXRjaGVzID0gcmVuZGVyTWF0Y2hlcztcbiAgZXhwb3J0cy51c2VBY3Rpb25EYXRhID0gdXNlQWN0aW9uRGF0YTtcbiAgZXhwb3J0cy51c2VBc3luY0Vycm9yID0gdXNlQXN5bmNFcnJvcjtcbiAgZXhwb3J0cy51c2VBc3luY1ZhbHVlID0gdXNlQXN5bmNWYWx1ZTtcbiAgZXhwb3J0cy51c2VCbG9ja2VyID0gdXNlQmxvY2tlcjtcbiAgZXhwb3J0cy51c2VIcmVmID0gdXNlSHJlZjtcbiAgZXhwb3J0cy51c2VJblJvdXRlckNvbnRleHQgPSB1c2VJblJvdXRlckNvbnRleHQ7XG4gIGV4cG9ydHMudXNlTG9hZGVyRGF0YSA9IHVzZUxvYWRlckRhdGE7XG4gIGV4cG9ydHMudXNlTG9jYXRpb24gPSB1c2VMb2NhdGlvbjtcbiAgZXhwb3J0cy51c2VNYXRjaCA9IHVzZU1hdGNoO1xuICBleHBvcnRzLnVzZU1hdGNoZXMgPSB1c2VNYXRjaGVzO1xuICBleHBvcnRzLnVzZU5hdmlnYXRlID0gdXNlTmF2aWdhdGU7XG4gIGV4cG9ydHMudXNlTmF2aWdhdGlvbiA9IHVzZU5hdmlnYXRpb247XG4gIGV4cG9ydHMudXNlTmF2aWdhdGlvblR5cGUgPSB1c2VOYXZpZ2F0aW9uVHlwZTtcbiAgZXhwb3J0cy51c2VPdXRsZXQgPSB1c2VPdXRsZXQ7XG4gIGV4cG9ydHMudXNlT3V0bGV0Q29udGV4dCA9IHVzZU91dGxldENvbnRleHQ7XG4gIGV4cG9ydHMudXNlUGFyYW1zID0gdXNlUGFyYW1zO1xuICBleHBvcnRzLnVzZVJlc29sdmVkUGF0aCA9IHVzZVJlc29sdmVkUGF0aDtcbiAgZXhwb3J0cy51c2VSZXZhbGlkYXRvciA9IHVzZVJldmFsaWRhdG9yO1xuICBleHBvcnRzLnVzZVJvdXRlRXJyb3IgPSB1c2VSb3V0ZUVycm9yO1xuICBleHBvcnRzLnVzZVJvdXRlTG9hZGVyRGF0YSA9IHVzZVJvdXRlTG9hZGVyRGF0YTtcbiAgZXhwb3J0cy51c2VSb3V0ZXMgPSB1c2VSb3V0ZXM7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVhY3Qtcm91dGVyLmRldmVsb3BtZW50LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-router/dist/umd/react-router.development.js\n");

/***/ })

};
;