"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/victory-axis";
exports.ids = ["vendor-chunks/victory-axis"];
exports.modules = {

/***/ "(ssr)/./node_modules/victory-axis/lib/helper-methods.js":
/*!*********************************************************!*\
  !*** ./node_modules/victory-axis/lib/helper-methods.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.getStyles = exports.getBaseProps = void 0;\nvar _defaults2 = _interopRequireDefault(__webpack_require__(/*! lodash/defaults */ \"(ssr)/./node_modules/lodash/defaults.js\"));\nvar _victoryCore = __webpack_require__(/*! victory-core */ \"(ssr)/./node_modules/victory-core/lib/index.js\");\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nconst orientationSign = {\n  top: -1,\n  left: -1,\n  right: 1,\n  bottom: 1\n};\nconst exists = val => val !== null && val !== undefined;\nconst getCurrentAxis = (props, axis) => {\n  const {\n    orientation,\n    horizontal\n  } = props;\n  if (orientation) {\n    const dimensions = {\n      top: \"x\",\n      bottom: \"x\",\n      left: \"y\",\n      right: \"y\"\n    };\n    return dimensions[orientation];\n  }\n  const otherAxis = axis === \"x\" ? \"y\" : \"x\";\n  return horizontal ? otherAxis : axis;\n};\nconst getScale = props => {\n  const axis = _victoryCore.Axis.getAxis(props);\n  const currentAxis = getCurrentAxis(props, axis);\n  const scale = _victoryCore.Scale.getBaseScale(props, axis);\n  const propsDomain = props.domain && props.domain[axis];\n  const domain = propsDomain || _victoryCore.Axis.getDomain(props) || scale.domain();\n  scale.range(_victoryCore.Helpers.getRange(props, currentAxis));\n  scale.domain(domain);\n  return scale;\n};\nconst getStyleObject = props => {\n  const {\n    theme,\n    dependentAxis\n  } = props;\n  const generalAxisStyle = theme && theme.axis && theme.axis.style;\n  const axisType = dependentAxis ? \"dependentAxis\" : \"independentAxis\";\n  const specificAxisStyle = theme && theme[axisType] && theme[axisType].style;\n  const mergeStyles = () => {\n    const styleNamespaces = [\"axis\", \"axisLabel\", \"grid\", \"parent\", \"tickLabels\", \"ticks\"];\n    return styleNamespaces.reduce((memo, curr) => {\n      memo[curr] = (0, _defaults2.default)({}, specificAxisStyle[curr], generalAxisStyle[curr]);\n      return memo;\n    }, {});\n  };\n  return generalAxisStyle && specificAxisStyle ? mergeStyles() : specificAxisStyle || generalAxisStyle;\n};\nconst getStyles = function (props, styleObject) {\n  if (styleObject === void 0) {\n    styleObject = {};\n  }\n  const style = props.style || {};\n  const parentStyleProps = {\n    height: \"100%\",\n    width: \"100%\"\n  };\n  return {\n    parent: (0, _defaults2.default)(style.parent, styleObject.parent, parentStyleProps),\n    axis: (0, _defaults2.default)({}, style.axis, styleObject.axis),\n    axisLabel: (0, _defaults2.default)({}, style.axisLabel, styleObject.axisLabel),\n    grid: (0, _defaults2.default)({}, style.grid, styleObject.grid),\n    ticks: (0, _defaults2.default)({}, style.ticks, styleObject.ticks),\n    tickLabels: (0, _defaults2.default)({}, style.tickLabels, styleObject.tickLabels)\n  };\n};\nexports.getStyles = getStyles;\nconst getTickProps = (layout, style, datum) => {\n  const {\n    position,\n    transform\n  } = layout;\n  return {\n    x1: transform.x,\n    y1: transform.y,\n    x2: transform.x + position.x2,\n    y2: transform.y + position.y2,\n    style,\n    datum\n  };\n};\n\n// eslint-disable-next-line max-params\nconst getTickLabelProps = (layout, style, anchors, datum, text) => {\n  const {\n    position,\n    transform\n  } = layout;\n  return {\n    style,\n    x: transform.x + position.x,\n    y: transform.y + position.y,\n    verticalAnchor: anchors.verticalAnchor,\n    textAnchor: anchors.textAnchor,\n    angle: style.angle,\n    text,\n    datum\n  };\n};\nconst getGridProps = (layout, style, datum) => {\n  const {\n    edge,\n    transform\n  } = layout;\n  return {\n    x1: transform.x,\n    y1: transform.y,\n    x2: edge.x + transform.x,\n    y2: edge.y + transform.y,\n    style,\n    datum\n  };\n};\nconst getAxisProps = (modifiedProps, calculatedValues, globalTransform) => {\n  const {\n    style,\n    padding,\n    isVertical\n  } = calculatedValues;\n  const {\n    width,\n    height\n  } = modifiedProps;\n  return {\n    style: style.axis,\n    x1: isVertical ? globalTransform.x : padding.left + globalTransform.x,\n    x2: isVertical ? globalTransform.x : width - padding.right + globalTransform.x,\n    y1: isVertical ? padding.top + globalTransform.y : globalTransform.y,\n    y2: isVertical ? height - padding.bottom + globalTransform.y : globalTransform.y\n  };\n};\nconst getEvaluatedStyles = (style, props) => {\n  return {\n    tickStyle: _victoryCore.Helpers.evaluateStyle(style.ticks, props),\n    labelStyle: _victoryCore.Helpers.evaluateStyle(style.tickLabels, props),\n    gridStyle: _victoryCore.Helpers.evaluateStyle(style.grid, props)\n  };\n};\nconst getAxisLabelProps = (props, calculatedValues, globalTransform) => {\n  const {\n    style,\n    orientation,\n    padding,\n    labelPadding,\n    isVertical\n  } = calculatedValues;\n  const sign = orientationSign[orientation];\n  const hPadding = padding.left + padding.right;\n  const vPadding = padding.top + padding.bottom;\n  const verticalAnchor = sign < 0 ? \"end\" : \"start\";\n  const labelStyle = style.axisLabel;\n  const angle = isVertical ? -90 : 0; // eslint-disable-line no-magic-numbers\n  const x = isVertical ? globalTransform.x + sign * labelPadding : (props.width - hPadding) / 2 + padding.left + globalTransform.x;\n  const y = isVertical ? (props.height - vPadding) / 2 + padding.top + globalTransform.y : sign * labelPadding + globalTransform.y;\n  return {\n    x,\n    y,\n    verticalAnchor: labelStyle.verticalAnchor || verticalAnchor,\n    textAnchor: labelStyle.textAnchor || \"middle\",\n    angle: labelStyle.angle === undefined ? angle : labelStyle.angle,\n    style: labelStyle,\n    text: props.label\n  };\n};\nconst getAnchors = (orientation, isVertical) => {\n  const anchorOrientation = {\n    top: \"end\",\n    left: \"end\",\n    right: \"start\",\n    bottom: \"start\"\n  };\n  const anchor = anchorOrientation[orientation];\n  return {\n    textAnchor: isVertical ? anchor : \"middle\",\n    verticalAnchor: isVertical ? \"middle\" : anchor\n  };\n};\nconst getLabelPadding = (props, style) => {\n  const labelStyle = style.axisLabel || {};\n  if (labelStyle.padding !== undefined && labelStyle.padding !== null) {\n    return labelStyle.padding;\n  }\n  const isVertical = _victoryCore.Axis.isVertical(props);\n  // TODO: magic numbers\n  /* eslint-disable no-magic-numbers*/\n  const fontSize = labelStyle.fontSize || 14;\n  return props.label ? fontSize * (isVertical ? 2.3 : 1.6) : 0;\n  /* eslint-enable no-magic-numbers*/\n};\nconst getDefaultOrientations = (axis, originSign, horizontal) => {\n  const sign = originSign || \"positive\";\n  const orientations = {\n    positive: {\n      x: \"bottom\",\n      y: \"left\"\n    },\n    negative: {\n      x: \"top\",\n      y: \"right\"\n    }\n  };\n  const horizontalOrientations = {\n    positive: {\n      x: \"left\",\n      y: \"bottom\"\n    },\n    negative: {\n      x: \"right\",\n      y: \"top\"\n    }\n  };\n  return horizontal ? horizontalOrientations[sign][axis] : orientations[sign][axis];\n};\nconst getStandaloneOffset = (props, calculatedValues) => {\n  const {\n    style,\n    scale,\n    orientation,\n    padding,\n    axis,\n    ticks,\n    stringTicks,\n    isVertical,\n    labelPadding\n  } = calculatedValues;\n  const {\n    polar,\n    horizontal\n  } = props;\n  const sharedProps = {\n    scale: {\n      [axis]: scale\n    },\n    polar,\n    horizontal,\n    ticks,\n    stringTicks\n  };\n  const xPadding = orientation === \"right\" ? padding.right : padding.left;\n  const yPadding = orientation === \"top\" ? padding.top : padding.bottom;\n  const offsetX = props.offsetX !== null && props.offsetX !== undefined ? props.offsetX : xPadding;\n  const offsetY = props.offsetY !== null && props.offsetY !== undefined ? props.offsetY : yPadding;\n  const fontSize = style.axisLabel.fontSize || 14; // eslint-disable-line no-magic-numbers\n  const tickSizes = ticks.map((data, index) => {\n    const tick = stringTicks ? props.tickValues[data - 1] : data;\n    const tickStyle = _victoryCore.Helpers.evaluateStyle(style.ticks, Object.assign({}, sharedProps, {\n      tick,\n      index\n    }));\n    return tickStyle.size || 0;\n  });\n  const totalPadding = fontSize + 2 * Math.max(...tickSizes) + labelPadding;\n  const minimumPadding = 1.2 * fontSize; // eslint-disable-line no-magic-numbers\n  const x = isVertical ? totalPadding : minimumPadding;\n  const y = isVertical ? minimumPadding : totalPadding;\n  return {\n    x: offsetX !== null && offsetX !== undefined ? offsetX : x,\n    y: offsetY !== null && offsetY !== undefined ? offsetY : y\n  };\n};\nconst isEqual = (a, b) => {\n  if (a instanceof Date && b instanceof Date) {\n    return a.getTime() === b.getTime();\n  }\n  return a === b;\n};\n\n// eslint-disable-next-line complexity\nconst getOffset = (props, calculatedValues) => {\n  const {\n    scale,\n    origin,\n    orientation,\n    orientations,\n    domain,\n    padding\n  } = calculatedValues;\n  const {\n    top,\n    bottom,\n    left,\n    right\n  } = padding;\n  const calculatedOrientation = {\n    x: orientation === \"bottom\" || orientation === \"top\" ? orientation : orientations.x,\n    y: orientation === \"left\" || orientation === \"right\" ? orientation : orientations.y\n  };\n\n  // make the axes line up, and cross when appropriate\n  const orientationOffset = {\n    x: calculatedOrientation.y === \"left\" ? left : right,\n    y: calculatedOrientation.x === \"bottom\" ? bottom : top\n  };\n  const originOffset = {\n    x: calculatedOrientation.y === \"left\" ? 0 : props.width,\n    y: calculatedOrientation.x === \"bottom\" ? props.height : 0\n  };\n  const originPosition = {\n    x: isEqual(origin.x, domain.x[0]) || isEqual(origin.x, domain.x[1]) ? 0 : scale.x(origin.x),\n    y: isEqual(origin.y, domain.y[0]) || isEqual(origin.y, domain.y[1]) ? 0 : scale.y(origin.y)\n  };\n  const x = originPosition.x ? Math.abs(originOffset.x - originPosition.x) : orientationOffset.x;\n  const y = originPosition.y ? Math.abs(originOffset.y - originPosition.y) : orientationOffset.y;\n  const offsetX = exists(props.offsetX) ? props.offsetX : x;\n  const offsetY = exists(props.offsetY) ? props.offsetY : y;\n  return {\n    x: offsetX,\n    y: offsetY\n  };\n};\n\n// eslint-disable-next-line complexity\nconst getHorizontalOffset = (props, calculatedValues) => {\n  const {\n    scale,\n    origin,\n    orientation,\n    orientations,\n    domain,\n    padding\n  } = calculatedValues;\n  const {\n    top,\n    bottom,\n    left,\n    right\n  } = padding;\n  const calculatedOrientation = {\n    y: orientation === \"bottom\" || orientation === \"top\" ? orientation : orientations.x,\n    x: orientation === \"left\" || orientation === \"right\" ? orientation : orientations.y\n  };\n\n  // make the axes line up, and cross when appropriate\n  const orientationOffset = {\n    x: calculatedOrientation.y === \"bottom\" ? bottom : top,\n    y: calculatedOrientation.x === \"left\" ? left : right\n  };\n  const originOffset = {\n    y: calculatedOrientation.x === \"left\" ? 0 : props.width,\n    x: calculatedOrientation.y === \"bottom\" ? props.height : 0\n  };\n  const originPosition = {\n    x: isEqual(origin.x, domain.x[0]) || isEqual(origin.x, domain.x[1]) ? 0 : scale.x(origin.x),\n    y: isEqual(origin.y, domain.y[0]) || isEqual(origin.y, domain.y[1]) ? 0 : scale.y(origin.y)\n  };\n  const y = originPosition.x ? Math.abs(originOffset.x - originPosition.x) : orientationOffset.x;\n  const x = originPosition.y ? Math.abs(originOffset.y - originPosition.y) : orientationOffset.y;\n  const offsetX = exists(props.offsetX) ? props.offsetX : x;\n  const offsetY = exists(props.offsetY) ? props.offsetY : y;\n  return {\n    x: offsetX,\n    y: offsetY\n  };\n};\nconst getTransform = (props, calculatedValues, offset) => {\n  const {\n    orientation,\n    axis\n  } = calculatedValues;\n  const axisValue = _victoryCore.Axis.getAxisValue(props, axis);\n  return {\n    top: {\n      x: 0,\n      y: axisValue !== undefined ? axisValue : offset.y\n    },\n    bottom: {\n      x: 0,\n      y: axisValue !== undefined ? axisValue : props.height - offset.y\n    },\n    left: {\n      x: axisValue !== undefined ? axisValue : offset.x,\n      y: 0\n    },\n    right: {\n      x: axisValue !== undefined ? axisValue : props.width - offset.x,\n      y: 0\n    }\n  }[orientation];\n};\nconst getTickPosition = (style, orientation, isVertical) => {\n  const {\n    tickStyle,\n    labelStyle\n  } = style;\n  const size = tickStyle.size || 0;\n  const tickPadding = tickStyle.padding || 0;\n  const labelPadding = labelStyle.padding || 0;\n  const tickSpacing = size + tickPadding + labelPadding;\n  const sign = orientationSign[orientation];\n  return {\n    x: isVertical ? sign * tickSpacing : 0,\n    x2: isVertical ? sign * size : 0,\n    y: isVertical ? 0 : sign * tickSpacing,\n    y2: isVertical ? 0 : sign * size\n  };\n};\nconst getTickTransform = (tick, globalTransform, isVertical) => {\n  return {\n    x: isVertical ? globalTransform.x : tick + globalTransform.x,\n    y: isVertical ? tick + globalTransform.y : globalTransform.y\n  };\n};\nconst getGridEdge = (props, calculatedValues) => {\n  const {\n    orientation,\n    padding,\n    isVertical\n  } = calculatedValues;\n  const sign = -orientationSign[orientation];\n  const x = isVertical ? sign * (props.width - (padding.left + padding.right)) : 0;\n  const y = isVertical ? 0 : sign * (props.height - (padding.top + padding.bottom));\n  return {\n    x,\n    y\n  };\n};\nconst getGridOffset = (calculatedValues, offset) => {\n  const {\n    padding,\n    orientation,\n    crossAxis\n  } = calculatedValues;\n  const xPadding = orientation === \"right\" ? padding.right : padding.left;\n  const yPadding = orientation === \"top\" ? padding.top : padding.bottom;\n  return {\n    x: crossAxis ? offset.x - xPadding : 0,\n    y: crossAxis ? offset.y - yPadding : 0\n  };\n};\nconst getLayoutProps = (modifiedProps, calculatedValues) => {\n  let offset;\n  if (calculatedValues.domain.x && calculatedValues.domain.y) {\n    offset = modifiedProps.horizontal ? getHorizontalOffset(modifiedProps, calculatedValues) : getOffset(modifiedProps, calculatedValues);\n  } else {\n    offset = getStandaloneOffset(modifiedProps, calculatedValues);\n  }\n  return {\n    globalTransform: getTransform(modifiedProps, calculatedValues, offset),\n    gridOffset: getGridOffset(calculatedValues, offset),\n    gridEdge: getGridEdge(modifiedProps, calculatedValues)\n  };\n};\nconst getOrientation = props => {\n  if (props.orientation) {\n    return props.orientation;\n  }\n  const defaultOrientations = {\n    dependent: props.horizontal ? \"bottom\" : \"left\",\n    independent: props.horizontal ? \"left\" : \"bottom\"\n  };\n  return props.dependentAxis ? defaultOrientations.dependent : defaultOrientations.independent;\n};\n\n// eslint-disable-next-line complexity\nconst getCalculatedValues = props => {\n  const defaultStyles = getStyleObject(props);\n  const style = getStyles(props, defaultStyles);\n  const padding = _victoryCore.Helpers.getPadding(props);\n  const labelPadding = getLabelPadding(props, style);\n  const stringTicks = _victoryCore.Axis.stringTicks(props) ? props.tickValues : undefined;\n  const axis = _victoryCore.Axis.getAxis(props);\n  const axisDomain = _victoryCore.Axis.getDomain(props);\n  const axisScale = getScale(props);\n  const xAxisDomain = axis === \"x\" ? axisDomain : undefined;\n  const yAxisDomain = axis === \"y\" ? axisDomain : undefined;\n  const xAxisScale = axis === \"x\" ? axisScale : undefined;\n  const yAxisScale = axis === \"y\" ? axisScale : undefined;\n  const crossAxis = !(props.crossAxis === false || props.standalone === true);\n  const ticks = _victoryCore.Axis.getTicks(props, axisScale, crossAxis);\n  const tickFormat = _victoryCore.Axis.getTickFormat(props, axisScale);\n  const range = {\n    x: _victoryCore.Helpers.getRange(props, \"x\"),\n    y: _victoryCore.Helpers.getRange(props, \"y\")\n  };\n  // use full domain if passed in from parent,\n  // otherwise use the just the one axis available\n  const domain = {\n    x: props.domain && props.domain.x ? props.domain.x : xAxisDomain,\n    y: props.domain && props.domain.y ? props.domain.y : yAxisDomain\n  };\n  // use full scale if passed in from parent,\n  // otherwise use the just the one axis available\n  const scale = {\n    x: props.domain && props.domain.x ? _victoryCore.Scale.getBaseScale(props, \"x\").domain(props.domain.x).range(props.horizontal ? range.y : range.x) : xAxisScale,\n    y: props.domain && props.domain.y ? _victoryCore.Scale.getBaseScale(props, \"y\").domain(props.domain.y).range(props.horizontal ? range.x : range.y) : yAxisScale\n  };\n  const origin = domain.x && domain.y ? _victoryCore.Axis.getOrigin(domain) : undefined;\n  const originSign = origin ? {\n    x: _victoryCore.Axis.getOriginSign(origin.x, domain.x),\n    y: _victoryCore.Axis.getOriginSign(origin.y, domain.y)\n  } : undefined;\n  const orientations = originSign ? {\n    x: getDefaultOrientations(\"x\", originSign.y, props.horizontal),\n    y: getDefaultOrientations(\"y\", originSign.x, props.horizontal)\n  } : undefined;\n  const orientation = orientations ? props.orientation || orientations[axis] : getOrientation(props);\n  const isVertical = _victoryCore.Axis.isVertical(Object.assign({}, props, {\n    orientation\n  }));\n  const anchors = getAnchors(orientation, isVertical);\n  return {\n    anchors,\n    axis,\n    crossAxis,\n    domain,\n    isVertical,\n    labelPadding,\n    orientation,\n    orientations,\n    origin,\n    padding,\n    scale,\n    stringTicks,\n    style,\n    tickFormat,\n    ticks\n  };\n};\nconst getBaseProps = (initialProps, fallbackProps) => {\n  const props = _victoryCore.Axis.modifyProps(initialProps, fallbackProps);\n  const calculatedValues = getCalculatedValues(props);\n  const {\n    axis,\n    style,\n    orientation,\n    isVertical,\n    scale,\n    ticks,\n    tickFormat,\n    anchors,\n    domain,\n    stringTicks\n  } = calculatedValues;\n  const otherAxis = axis === \"x\" ? \"y\" : \"x\";\n  const {\n    width,\n    height,\n    standalone,\n    theme,\n    polar,\n    padding,\n    horizontal\n  } = props;\n  const {\n    globalTransform,\n    gridOffset,\n    gridEdge\n  } = getLayoutProps(props, calculatedValues);\n  const sharedProps = {\n    scale: {\n      [axis]: scale[axis]\n    },\n    polar,\n    horizontal,\n    ticks,\n    stringTicks\n  };\n  const axisProps = getAxisProps(props, calculatedValues, globalTransform);\n  const axisLabelProps = getAxisLabelProps(props, calculatedValues, globalTransform);\n  const initialChildProps = {\n    parent: Object.assign({\n      style: style.parent,\n      ticks,\n      standalone,\n      theme,\n      width,\n      height,\n      padding,\n      domain\n    }, sharedProps)\n  };\n  const gridProps = {\n    dimension: otherAxis,\n    range: {\n      [otherAxis]: _victoryCore.Helpers.getRange(props, otherAxis)\n    },\n    scale: props.scale && props.scale[otherAxis] ? {\n      [otherAxis]: props.scale[otherAxis]\n    } : undefined\n  };\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n  return ticks.reduce((childProps, tickValue, index) => {\n    const tick = stringTicks ? stringTicks[index] : tickValue;\n    const text = tickFormat(tickValue, index, ticks);\n    const styles = getEvaluatedStyles(style, Object.assign({}, sharedProps, {\n      tick,\n      tickValue,\n      index,\n      text\n    }));\n    const tickLayout = {\n      position: getTickPosition(styles, orientation, isVertical),\n      transform: getTickTransform(scale[axis]?.(tickValue), globalTransform, isVertical)\n    };\n    const gridLayout = {\n      edge: gridEdge,\n      transform: {\n        x: isVertical ? -gridOffset.x + globalTransform.x : scale[axis]?.(tickValue) + globalTransform.x,\n        y: isVertical ? scale[axis]?.(tickValue) + globalTransform.y : gridOffset.y + globalTransform.y\n      }\n    };\n    childProps[index] = {\n      axis: Object.assign({\n        dimension: axis\n      }, sharedProps, axisProps),\n      axisLabel: Object.assign({}, sharedProps, axisLabelProps),\n      ticks: Object.assign({}, sharedProps, getTickProps(tickLayout, styles.tickStyle, tickValue)),\n      tickLabels: Object.assign({}, sharedProps, getTickLabelProps(tickLayout, styles.labelStyle, anchors, tickValue, text)),\n      grid: Object.assign({}, sharedProps, gridProps, getGridProps(gridLayout, styles.gridStyle, tickValue))\n    };\n    return childProps;\n  }, initialChildProps);\n};\nexports.getBaseProps = getBaseProps;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdmljdG9yeS1heGlzL2xpYi9oZWxwZXItbWV0aG9kcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixpQkFBaUIsR0FBRyxvQkFBb0I7QUFDeEMsd0NBQXdDLG1CQUFPLENBQUMsZ0VBQWlCO0FBQ2pFLG1CQUFtQixtQkFBTyxDQUFDLG9FQUFjO0FBQ3pDLHVDQUF1Qyx1Q0FBdUM7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLEtBQUssSUFBSTtBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEMseUNBQXlDO0FBQ3pDLG9DQUFvQztBQUNwQyxxQ0FBcUM7QUFDckMsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0Esc0ZBQXNGO0FBQ3RGO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLGtFQUFrRTtBQUNsRTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsaUNBQWlDO0FBQ2pDLDZCQUE2QjtBQUM3QixrQ0FBa0M7QUFDbEMsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxvQkFBb0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90ZW1wLy4vbm9kZV9tb2R1bGVzL3ZpY3RvcnktYXhpcy9saWIvaGVscGVyLW1ldGhvZHMuanM/NTNkMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZ2V0U3R5bGVzID0gZXhwb3J0cy5nZXRCYXNlUHJvcHMgPSB2b2lkIDA7XG52YXIgX2RlZmF1bHRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImxvZGFzaC9kZWZhdWx0c1wiKSk7XG52YXIgX3ZpY3RvcnlDb3JlID0gcmVxdWlyZShcInZpY3RvcnktY29yZVwiKTtcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5jb25zdCBvcmllbnRhdGlvblNpZ24gPSB7XG4gIHRvcDogLTEsXG4gIGxlZnQ6IC0xLFxuICByaWdodDogMSxcbiAgYm90dG9tOiAxXG59O1xuY29uc3QgZXhpc3RzID0gdmFsID0+IHZhbCAhPT0gbnVsbCAmJiB2YWwgIT09IHVuZGVmaW5lZDtcbmNvbnN0IGdldEN1cnJlbnRBeGlzID0gKHByb3BzLCBheGlzKSA9PiB7XG4gIGNvbnN0IHtcbiAgICBvcmllbnRhdGlvbixcbiAgICBob3Jpem9udGFsXG4gIH0gPSBwcm9wcztcbiAgaWYgKG9yaWVudGF0aW9uKSB7XG4gICAgY29uc3QgZGltZW5zaW9ucyA9IHtcbiAgICAgIHRvcDogXCJ4XCIsXG4gICAgICBib3R0b206IFwieFwiLFxuICAgICAgbGVmdDogXCJ5XCIsXG4gICAgICByaWdodDogXCJ5XCJcbiAgICB9O1xuICAgIHJldHVybiBkaW1lbnNpb25zW29yaWVudGF0aW9uXTtcbiAgfVxuICBjb25zdCBvdGhlckF4aXMgPSBheGlzID09PSBcInhcIiA/IFwieVwiIDogXCJ4XCI7XG4gIHJldHVybiBob3Jpem9udGFsID8gb3RoZXJBeGlzIDogYXhpcztcbn07XG5jb25zdCBnZXRTY2FsZSA9IHByb3BzID0+IHtcbiAgY29uc3QgYXhpcyA9IF92aWN0b3J5Q29yZS5BeGlzLmdldEF4aXMocHJvcHMpO1xuICBjb25zdCBjdXJyZW50QXhpcyA9IGdldEN1cnJlbnRBeGlzKHByb3BzLCBheGlzKTtcbiAgY29uc3Qgc2NhbGUgPSBfdmljdG9yeUNvcmUuU2NhbGUuZ2V0QmFzZVNjYWxlKHByb3BzLCBheGlzKTtcbiAgY29uc3QgcHJvcHNEb21haW4gPSBwcm9wcy5kb21haW4gJiYgcHJvcHMuZG9tYWluW2F4aXNdO1xuICBjb25zdCBkb21haW4gPSBwcm9wc0RvbWFpbiB8fCBfdmljdG9yeUNvcmUuQXhpcy5nZXREb21haW4ocHJvcHMpIHx8IHNjYWxlLmRvbWFpbigpO1xuICBzY2FsZS5yYW5nZShfdmljdG9yeUNvcmUuSGVscGVycy5nZXRSYW5nZShwcm9wcywgY3VycmVudEF4aXMpKTtcbiAgc2NhbGUuZG9tYWluKGRvbWFpbik7XG4gIHJldHVybiBzY2FsZTtcbn07XG5jb25zdCBnZXRTdHlsZU9iamVjdCA9IHByb3BzID0+IHtcbiAgY29uc3Qge1xuICAgIHRoZW1lLFxuICAgIGRlcGVuZGVudEF4aXNcbiAgfSA9IHByb3BzO1xuICBjb25zdCBnZW5lcmFsQXhpc1N0eWxlID0gdGhlbWUgJiYgdGhlbWUuYXhpcyAmJiB0aGVtZS5heGlzLnN0eWxlO1xuICBjb25zdCBheGlzVHlwZSA9IGRlcGVuZGVudEF4aXMgPyBcImRlcGVuZGVudEF4aXNcIiA6IFwiaW5kZXBlbmRlbnRBeGlzXCI7XG4gIGNvbnN0IHNwZWNpZmljQXhpc1N0eWxlID0gdGhlbWUgJiYgdGhlbWVbYXhpc1R5cGVdICYmIHRoZW1lW2F4aXNUeXBlXS5zdHlsZTtcbiAgY29uc3QgbWVyZ2VTdHlsZXMgPSAoKSA9PiB7XG4gICAgY29uc3Qgc3R5bGVOYW1lc3BhY2VzID0gW1wiYXhpc1wiLCBcImF4aXNMYWJlbFwiLCBcImdyaWRcIiwgXCJwYXJlbnRcIiwgXCJ0aWNrTGFiZWxzXCIsIFwidGlja3NcIl07XG4gICAgcmV0dXJuIHN0eWxlTmFtZXNwYWNlcy5yZWR1Y2UoKG1lbW8sIGN1cnIpID0+IHtcbiAgICAgIG1lbW9bY3Vycl0gPSAoMCwgX2RlZmF1bHRzMi5kZWZhdWx0KSh7fSwgc3BlY2lmaWNBeGlzU3R5bGVbY3Vycl0sIGdlbmVyYWxBeGlzU3R5bGVbY3Vycl0pO1xuICAgICAgcmV0dXJuIG1lbW87XG4gICAgfSwge30pO1xuICB9O1xuICByZXR1cm4gZ2VuZXJhbEF4aXNTdHlsZSAmJiBzcGVjaWZpY0F4aXNTdHlsZSA/IG1lcmdlU3R5bGVzKCkgOiBzcGVjaWZpY0F4aXNTdHlsZSB8fCBnZW5lcmFsQXhpc1N0eWxlO1xufTtcbmNvbnN0IGdldFN0eWxlcyA9IGZ1bmN0aW9uIChwcm9wcywgc3R5bGVPYmplY3QpIHtcbiAgaWYgKHN0eWxlT2JqZWN0ID09PSB2b2lkIDApIHtcbiAgICBzdHlsZU9iamVjdCA9IHt9O1xuICB9XG4gIGNvbnN0IHN0eWxlID0gcHJvcHMuc3R5bGUgfHwge307XG4gIGNvbnN0IHBhcmVudFN0eWxlUHJvcHMgPSB7XG4gICAgaGVpZ2h0OiBcIjEwMCVcIixcbiAgICB3aWR0aDogXCIxMDAlXCJcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBwYXJlbnQ6ICgwLCBfZGVmYXVsdHMyLmRlZmF1bHQpKHN0eWxlLnBhcmVudCwgc3R5bGVPYmplY3QucGFyZW50LCBwYXJlbnRTdHlsZVByb3BzKSxcbiAgICBheGlzOiAoMCwgX2RlZmF1bHRzMi5kZWZhdWx0KSh7fSwgc3R5bGUuYXhpcywgc3R5bGVPYmplY3QuYXhpcyksXG4gICAgYXhpc0xhYmVsOiAoMCwgX2RlZmF1bHRzMi5kZWZhdWx0KSh7fSwgc3R5bGUuYXhpc0xhYmVsLCBzdHlsZU9iamVjdC5heGlzTGFiZWwpLFxuICAgIGdyaWQ6ICgwLCBfZGVmYXVsdHMyLmRlZmF1bHQpKHt9LCBzdHlsZS5ncmlkLCBzdHlsZU9iamVjdC5ncmlkKSxcbiAgICB0aWNrczogKDAsIF9kZWZhdWx0czIuZGVmYXVsdCkoe30sIHN0eWxlLnRpY2tzLCBzdHlsZU9iamVjdC50aWNrcyksXG4gICAgdGlja0xhYmVsczogKDAsIF9kZWZhdWx0czIuZGVmYXVsdCkoe30sIHN0eWxlLnRpY2tMYWJlbHMsIHN0eWxlT2JqZWN0LnRpY2tMYWJlbHMpXG4gIH07XG59O1xuZXhwb3J0cy5nZXRTdHlsZXMgPSBnZXRTdHlsZXM7XG5jb25zdCBnZXRUaWNrUHJvcHMgPSAobGF5b3V0LCBzdHlsZSwgZGF0dW0pID0+IHtcbiAgY29uc3Qge1xuICAgIHBvc2l0aW9uLFxuICAgIHRyYW5zZm9ybVxuICB9ID0gbGF5b3V0O1xuICByZXR1cm4ge1xuICAgIHgxOiB0cmFuc2Zvcm0ueCxcbiAgICB5MTogdHJhbnNmb3JtLnksXG4gICAgeDI6IHRyYW5zZm9ybS54ICsgcG9zaXRpb24ueDIsXG4gICAgeTI6IHRyYW5zZm9ybS55ICsgcG9zaXRpb24ueTIsXG4gICAgc3R5bGUsXG4gICAgZGF0dW1cbiAgfTtcbn07XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtcGFyYW1zXG5jb25zdCBnZXRUaWNrTGFiZWxQcm9wcyA9IChsYXlvdXQsIHN0eWxlLCBhbmNob3JzLCBkYXR1bSwgdGV4dCkgPT4ge1xuICBjb25zdCB7XG4gICAgcG9zaXRpb24sXG4gICAgdHJhbnNmb3JtXG4gIH0gPSBsYXlvdXQ7XG4gIHJldHVybiB7XG4gICAgc3R5bGUsXG4gICAgeDogdHJhbnNmb3JtLnggKyBwb3NpdGlvbi54LFxuICAgIHk6IHRyYW5zZm9ybS55ICsgcG9zaXRpb24ueSxcbiAgICB2ZXJ0aWNhbEFuY2hvcjogYW5jaG9ycy52ZXJ0aWNhbEFuY2hvcixcbiAgICB0ZXh0QW5jaG9yOiBhbmNob3JzLnRleHRBbmNob3IsXG4gICAgYW5nbGU6IHN0eWxlLmFuZ2xlLFxuICAgIHRleHQsXG4gICAgZGF0dW1cbiAgfTtcbn07XG5jb25zdCBnZXRHcmlkUHJvcHMgPSAobGF5b3V0LCBzdHlsZSwgZGF0dW0pID0+IHtcbiAgY29uc3Qge1xuICAgIGVkZ2UsXG4gICAgdHJhbnNmb3JtXG4gIH0gPSBsYXlvdXQ7XG4gIHJldHVybiB7XG4gICAgeDE6IHRyYW5zZm9ybS54LFxuICAgIHkxOiB0cmFuc2Zvcm0ueSxcbiAgICB4MjogZWRnZS54ICsgdHJhbnNmb3JtLngsXG4gICAgeTI6IGVkZ2UueSArIHRyYW5zZm9ybS55LFxuICAgIHN0eWxlLFxuICAgIGRhdHVtXG4gIH07XG59O1xuY29uc3QgZ2V0QXhpc1Byb3BzID0gKG1vZGlmaWVkUHJvcHMsIGNhbGN1bGF0ZWRWYWx1ZXMsIGdsb2JhbFRyYW5zZm9ybSkgPT4ge1xuICBjb25zdCB7XG4gICAgc3R5bGUsXG4gICAgcGFkZGluZyxcbiAgICBpc1ZlcnRpY2FsXG4gIH0gPSBjYWxjdWxhdGVkVmFsdWVzO1xuICBjb25zdCB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0XG4gIH0gPSBtb2RpZmllZFByb3BzO1xuICByZXR1cm4ge1xuICAgIHN0eWxlOiBzdHlsZS5heGlzLFxuICAgIHgxOiBpc1ZlcnRpY2FsID8gZ2xvYmFsVHJhbnNmb3JtLnggOiBwYWRkaW5nLmxlZnQgKyBnbG9iYWxUcmFuc2Zvcm0ueCxcbiAgICB4MjogaXNWZXJ0aWNhbCA/IGdsb2JhbFRyYW5zZm9ybS54IDogd2lkdGggLSBwYWRkaW5nLnJpZ2h0ICsgZ2xvYmFsVHJhbnNmb3JtLngsXG4gICAgeTE6IGlzVmVydGljYWwgPyBwYWRkaW5nLnRvcCArIGdsb2JhbFRyYW5zZm9ybS55IDogZ2xvYmFsVHJhbnNmb3JtLnksXG4gICAgeTI6IGlzVmVydGljYWwgPyBoZWlnaHQgLSBwYWRkaW5nLmJvdHRvbSArIGdsb2JhbFRyYW5zZm9ybS55IDogZ2xvYmFsVHJhbnNmb3JtLnlcbiAgfTtcbn07XG5jb25zdCBnZXRFdmFsdWF0ZWRTdHlsZXMgPSAoc3R5bGUsIHByb3BzKSA9PiB7XG4gIHJldHVybiB7XG4gICAgdGlja1N0eWxlOiBfdmljdG9yeUNvcmUuSGVscGVycy5ldmFsdWF0ZVN0eWxlKHN0eWxlLnRpY2tzLCBwcm9wcyksXG4gICAgbGFiZWxTdHlsZTogX3ZpY3RvcnlDb3JlLkhlbHBlcnMuZXZhbHVhdGVTdHlsZShzdHlsZS50aWNrTGFiZWxzLCBwcm9wcyksXG4gICAgZ3JpZFN0eWxlOiBfdmljdG9yeUNvcmUuSGVscGVycy5ldmFsdWF0ZVN0eWxlKHN0eWxlLmdyaWQsIHByb3BzKVxuICB9O1xufTtcbmNvbnN0IGdldEF4aXNMYWJlbFByb3BzID0gKHByb3BzLCBjYWxjdWxhdGVkVmFsdWVzLCBnbG9iYWxUcmFuc2Zvcm0pID0+IHtcbiAgY29uc3Qge1xuICAgIHN0eWxlLFxuICAgIG9yaWVudGF0aW9uLFxuICAgIHBhZGRpbmcsXG4gICAgbGFiZWxQYWRkaW5nLFxuICAgIGlzVmVydGljYWxcbiAgfSA9IGNhbGN1bGF0ZWRWYWx1ZXM7XG4gIGNvbnN0IHNpZ24gPSBvcmllbnRhdGlvblNpZ25bb3JpZW50YXRpb25dO1xuICBjb25zdCBoUGFkZGluZyA9IHBhZGRpbmcubGVmdCArIHBhZGRpbmcucmlnaHQ7XG4gIGNvbnN0IHZQYWRkaW5nID0gcGFkZGluZy50b3AgKyBwYWRkaW5nLmJvdHRvbTtcbiAgY29uc3QgdmVydGljYWxBbmNob3IgPSBzaWduIDwgMCA/IFwiZW5kXCIgOiBcInN0YXJ0XCI7XG4gIGNvbnN0IGxhYmVsU3R5bGUgPSBzdHlsZS5heGlzTGFiZWw7XG4gIGNvbnN0IGFuZ2xlID0gaXNWZXJ0aWNhbCA/IC05MCA6IDA7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbWFnaWMtbnVtYmVyc1xuICBjb25zdCB4ID0gaXNWZXJ0aWNhbCA/IGdsb2JhbFRyYW5zZm9ybS54ICsgc2lnbiAqIGxhYmVsUGFkZGluZyA6IChwcm9wcy53aWR0aCAtIGhQYWRkaW5nKSAvIDIgKyBwYWRkaW5nLmxlZnQgKyBnbG9iYWxUcmFuc2Zvcm0ueDtcbiAgY29uc3QgeSA9IGlzVmVydGljYWwgPyAocHJvcHMuaGVpZ2h0IC0gdlBhZGRpbmcpIC8gMiArIHBhZGRpbmcudG9wICsgZ2xvYmFsVHJhbnNmb3JtLnkgOiBzaWduICogbGFiZWxQYWRkaW5nICsgZ2xvYmFsVHJhbnNmb3JtLnk7XG4gIHJldHVybiB7XG4gICAgeCxcbiAgICB5LFxuICAgIHZlcnRpY2FsQW5jaG9yOiBsYWJlbFN0eWxlLnZlcnRpY2FsQW5jaG9yIHx8IHZlcnRpY2FsQW5jaG9yLFxuICAgIHRleHRBbmNob3I6IGxhYmVsU3R5bGUudGV4dEFuY2hvciB8fCBcIm1pZGRsZVwiLFxuICAgIGFuZ2xlOiBsYWJlbFN0eWxlLmFuZ2xlID09PSB1bmRlZmluZWQgPyBhbmdsZSA6IGxhYmVsU3R5bGUuYW5nbGUsXG4gICAgc3R5bGU6IGxhYmVsU3R5bGUsXG4gICAgdGV4dDogcHJvcHMubGFiZWxcbiAgfTtcbn07XG5jb25zdCBnZXRBbmNob3JzID0gKG9yaWVudGF0aW9uLCBpc1ZlcnRpY2FsKSA9PiB7XG4gIGNvbnN0IGFuY2hvck9yaWVudGF0aW9uID0ge1xuICAgIHRvcDogXCJlbmRcIixcbiAgICBsZWZ0OiBcImVuZFwiLFxuICAgIHJpZ2h0OiBcInN0YXJ0XCIsXG4gICAgYm90dG9tOiBcInN0YXJ0XCJcbiAgfTtcbiAgY29uc3QgYW5jaG9yID0gYW5jaG9yT3JpZW50YXRpb25bb3JpZW50YXRpb25dO1xuICByZXR1cm4ge1xuICAgIHRleHRBbmNob3I6IGlzVmVydGljYWwgPyBhbmNob3IgOiBcIm1pZGRsZVwiLFxuICAgIHZlcnRpY2FsQW5jaG9yOiBpc1ZlcnRpY2FsID8gXCJtaWRkbGVcIiA6IGFuY2hvclxuICB9O1xufTtcbmNvbnN0IGdldExhYmVsUGFkZGluZyA9IChwcm9wcywgc3R5bGUpID0+IHtcbiAgY29uc3QgbGFiZWxTdHlsZSA9IHN0eWxlLmF4aXNMYWJlbCB8fCB7fTtcbiAgaWYgKGxhYmVsU3R5bGUucGFkZGluZyAhPT0gdW5kZWZpbmVkICYmIGxhYmVsU3R5bGUucGFkZGluZyAhPT0gbnVsbCkge1xuICAgIHJldHVybiBsYWJlbFN0eWxlLnBhZGRpbmc7XG4gIH1cbiAgY29uc3QgaXNWZXJ0aWNhbCA9IF92aWN0b3J5Q29yZS5BeGlzLmlzVmVydGljYWwocHJvcHMpO1xuICAvLyBUT0RPOiBtYWdpYyBudW1iZXJzXG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLW1hZ2ljLW51bWJlcnMqL1xuICBjb25zdCBmb250U2l6ZSA9IGxhYmVsU3R5bGUuZm9udFNpemUgfHwgMTQ7XG4gIHJldHVybiBwcm9wcy5sYWJlbCA/IGZvbnRTaXplICogKGlzVmVydGljYWwgPyAyLjMgOiAxLjYpIDogMDtcbiAgLyogZXNsaW50LWVuYWJsZSBuby1tYWdpYy1udW1iZXJzKi9cbn07XG5jb25zdCBnZXREZWZhdWx0T3JpZW50YXRpb25zID0gKGF4aXMsIG9yaWdpblNpZ24sIGhvcml6b250YWwpID0+IHtcbiAgY29uc3Qgc2lnbiA9IG9yaWdpblNpZ24gfHwgXCJwb3NpdGl2ZVwiO1xuICBjb25zdCBvcmllbnRhdGlvbnMgPSB7XG4gICAgcG9zaXRpdmU6IHtcbiAgICAgIHg6IFwiYm90dG9tXCIsXG4gICAgICB5OiBcImxlZnRcIlxuICAgIH0sXG4gICAgbmVnYXRpdmU6IHtcbiAgICAgIHg6IFwidG9wXCIsXG4gICAgICB5OiBcInJpZ2h0XCJcbiAgICB9XG4gIH07XG4gIGNvbnN0IGhvcml6b250YWxPcmllbnRhdGlvbnMgPSB7XG4gICAgcG9zaXRpdmU6IHtcbiAgICAgIHg6IFwibGVmdFwiLFxuICAgICAgeTogXCJib3R0b21cIlxuICAgIH0sXG4gICAgbmVnYXRpdmU6IHtcbiAgICAgIHg6IFwicmlnaHRcIixcbiAgICAgIHk6IFwidG9wXCJcbiAgICB9XG4gIH07XG4gIHJldHVybiBob3Jpem9udGFsID8gaG9yaXpvbnRhbE9yaWVudGF0aW9uc1tzaWduXVtheGlzXSA6IG9yaWVudGF0aW9uc1tzaWduXVtheGlzXTtcbn07XG5jb25zdCBnZXRTdGFuZGFsb25lT2Zmc2V0ID0gKHByb3BzLCBjYWxjdWxhdGVkVmFsdWVzKSA9PiB7XG4gIGNvbnN0IHtcbiAgICBzdHlsZSxcbiAgICBzY2FsZSxcbiAgICBvcmllbnRhdGlvbixcbiAgICBwYWRkaW5nLFxuICAgIGF4aXMsXG4gICAgdGlja3MsXG4gICAgc3RyaW5nVGlja3MsXG4gICAgaXNWZXJ0aWNhbCxcbiAgICBsYWJlbFBhZGRpbmdcbiAgfSA9IGNhbGN1bGF0ZWRWYWx1ZXM7XG4gIGNvbnN0IHtcbiAgICBwb2xhcixcbiAgICBob3Jpem9udGFsXG4gIH0gPSBwcm9wcztcbiAgY29uc3Qgc2hhcmVkUHJvcHMgPSB7XG4gICAgc2NhbGU6IHtcbiAgICAgIFtheGlzXTogc2NhbGVcbiAgICB9LFxuICAgIHBvbGFyLFxuICAgIGhvcml6b250YWwsXG4gICAgdGlja3MsXG4gICAgc3RyaW5nVGlja3NcbiAgfTtcbiAgY29uc3QgeFBhZGRpbmcgPSBvcmllbnRhdGlvbiA9PT0gXCJyaWdodFwiID8gcGFkZGluZy5yaWdodCA6IHBhZGRpbmcubGVmdDtcbiAgY29uc3QgeVBhZGRpbmcgPSBvcmllbnRhdGlvbiA9PT0gXCJ0b3BcIiA/IHBhZGRpbmcudG9wIDogcGFkZGluZy5ib3R0b207XG4gIGNvbnN0IG9mZnNldFggPSBwcm9wcy5vZmZzZXRYICE9PSBudWxsICYmIHByb3BzLm9mZnNldFggIT09IHVuZGVmaW5lZCA/IHByb3BzLm9mZnNldFggOiB4UGFkZGluZztcbiAgY29uc3Qgb2Zmc2V0WSA9IHByb3BzLm9mZnNldFkgIT09IG51bGwgJiYgcHJvcHMub2Zmc2V0WSAhPT0gdW5kZWZpbmVkID8gcHJvcHMub2Zmc2V0WSA6IHlQYWRkaW5nO1xuICBjb25zdCBmb250U2l6ZSA9IHN0eWxlLmF4aXNMYWJlbC5mb250U2l6ZSB8fCAxNDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1tYWdpYy1udW1iZXJzXG4gIGNvbnN0IHRpY2tTaXplcyA9IHRpY2tzLm1hcCgoZGF0YSwgaW5kZXgpID0+IHtcbiAgICBjb25zdCB0aWNrID0gc3RyaW5nVGlja3MgPyBwcm9wcy50aWNrVmFsdWVzW2RhdGEgLSAxXSA6IGRhdGE7XG4gICAgY29uc3QgdGlja1N0eWxlID0gX3ZpY3RvcnlDb3JlLkhlbHBlcnMuZXZhbHVhdGVTdHlsZShzdHlsZS50aWNrcywgT2JqZWN0LmFzc2lnbih7fSwgc2hhcmVkUHJvcHMsIHtcbiAgICAgIHRpY2ssXG4gICAgICBpbmRleFxuICAgIH0pKTtcbiAgICByZXR1cm4gdGlja1N0eWxlLnNpemUgfHwgMDtcbiAgfSk7XG4gIGNvbnN0IHRvdGFsUGFkZGluZyA9IGZvbnRTaXplICsgMiAqIE1hdGgubWF4KC4uLnRpY2tTaXplcykgKyBsYWJlbFBhZGRpbmc7XG4gIGNvbnN0IG1pbmltdW1QYWRkaW5nID0gMS4yICogZm9udFNpemU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbWFnaWMtbnVtYmVyc1xuICBjb25zdCB4ID0gaXNWZXJ0aWNhbCA/IHRvdGFsUGFkZGluZyA6IG1pbmltdW1QYWRkaW5nO1xuICBjb25zdCB5ID0gaXNWZXJ0aWNhbCA/IG1pbmltdW1QYWRkaW5nIDogdG90YWxQYWRkaW5nO1xuICByZXR1cm4ge1xuICAgIHg6IG9mZnNldFggIT09IG51bGwgJiYgb2Zmc2V0WCAhPT0gdW5kZWZpbmVkID8gb2Zmc2V0WCA6IHgsXG4gICAgeTogb2Zmc2V0WSAhPT0gbnVsbCAmJiBvZmZzZXRZICE9PSB1bmRlZmluZWQgPyBvZmZzZXRZIDogeVxuICB9O1xufTtcbmNvbnN0IGlzRXF1YWwgPSAoYSwgYikgPT4ge1xuICBpZiAoYSBpbnN0YW5jZW9mIERhdGUgJiYgYiBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICByZXR1cm4gYS5nZXRUaW1lKCkgPT09IGIuZ2V0VGltZSgpO1xuICB9XG4gIHJldHVybiBhID09PSBiO1xufTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbmNvbnN0IGdldE9mZnNldCA9IChwcm9wcywgY2FsY3VsYXRlZFZhbHVlcykgPT4ge1xuICBjb25zdCB7XG4gICAgc2NhbGUsXG4gICAgb3JpZ2luLFxuICAgIG9yaWVudGF0aW9uLFxuICAgIG9yaWVudGF0aW9ucyxcbiAgICBkb21haW4sXG4gICAgcGFkZGluZ1xuICB9ID0gY2FsY3VsYXRlZFZhbHVlcztcbiAgY29uc3Qge1xuICAgIHRvcCxcbiAgICBib3R0b20sXG4gICAgbGVmdCxcbiAgICByaWdodFxuICB9ID0gcGFkZGluZztcbiAgY29uc3QgY2FsY3VsYXRlZE9yaWVudGF0aW9uID0ge1xuICAgIHg6IG9yaWVudGF0aW9uID09PSBcImJvdHRvbVwiIHx8IG9yaWVudGF0aW9uID09PSBcInRvcFwiID8gb3JpZW50YXRpb24gOiBvcmllbnRhdGlvbnMueCxcbiAgICB5OiBvcmllbnRhdGlvbiA9PT0gXCJsZWZ0XCIgfHwgb3JpZW50YXRpb24gPT09IFwicmlnaHRcIiA/IG9yaWVudGF0aW9uIDogb3JpZW50YXRpb25zLnlcbiAgfTtcblxuICAvLyBtYWtlIHRoZSBheGVzIGxpbmUgdXAsIGFuZCBjcm9zcyB3aGVuIGFwcHJvcHJpYXRlXG4gIGNvbnN0IG9yaWVudGF0aW9uT2Zmc2V0ID0ge1xuICAgIHg6IGNhbGN1bGF0ZWRPcmllbnRhdGlvbi55ID09PSBcImxlZnRcIiA/IGxlZnQgOiByaWdodCxcbiAgICB5OiBjYWxjdWxhdGVkT3JpZW50YXRpb24ueCA9PT0gXCJib3R0b21cIiA/IGJvdHRvbSA6IHRvcFxuICB9O1xuICBjb25zdCBvcmlnaW5PZmZzZXQgPSB7XG4gICAgeDogY2FsY3VsYXRlZE9yaWVudGF0aW9uLnkgPT09IFwibGVmdFwiID8gMCA6IHByb3BzLndpZHRoLFxuICAgIHk6IGNhbGN1bGF0ZWRPcmllbnRhdGlvbi54ID09PSBcImJvdHRvbVwiID8gcHJvcHMuaGVpZ2h0IDogMFxuICB9O1xuICBjb25zdCBvcmlnaW5Qb3NpdGlvbiA9IHtcbiAgICB4OiBpc0VxdWFsKG9yaWdpbi54LCBkb21haW4ueFswXSkgfHwgaXNFcXVhbChvcmlnaW4ueCwgZG9tYWluLnhbMV0pID8gMCA6IHNjYWxlLngob3JpZ2luLngpLFxuICAgIHk6IGlzRXF1YWwob3JpZ2luLnksIGRvbWFpbi55WzBdKSB8fCBpc0VxdWFsKG9yaWdpbi55LCBkb21haW4ueVsxXSkgPyAwIDogc2NhbGUueShvcmlnaW4ueSlcbiAgfTtcbiAgY29uc3QgeCA9IG9yaWdpblBvc2l0aW9uLnggPyBNYXRoLmFicyhvcmlnaW5PZmZzZXQueCAtIG9yaWdpblBvc2l0aW9uLngpIDogb3JpZW50YXRpb25PZmZzZXQueDtcbiAgY29uc3QgeSA9IG9yaWdpblBvc2l0aW9uLnkgPyBNYXRoLmFicyhvcmlnaW5PZmZzZXQueSAtIG9yaWdpblBvc2l0aW9uLnkpIDogb3JpZW50YXRpb25PZmZzZXQueTtcbiAgY29uc3Qgb2Zmc2V0WCA9IGV4aXN0cyhwcm9wcy5vZmZzZXRYKSA/IHByb3BzLm9mZnNldFggOiB4O1xuICBjb25zdCBvZmZzZXRZID0gZXhpc3RzKHByb3BzLm9mZnNldFkpID8gcHJvcHMub2Zmc2V0WSA6IHk7XG4gIHJldHVybiB7XG4gICAgeDogb2Zmc2V0WCxcbiAgICB5OiBvZmZzZXRZXG4gIH07XG59O1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuY29uc3QgZ2V0SG9yaXpvbnRhbE9mZnNldCA9IChwcm9wcywgY2FsY3VsYXRlZFZhbHVlcykgPT4ge1xuICBjb25zdCB7XG4gICAgc2NhbGUsXG4gICAgb3JpZ2luLFxuICAgIG9yaWVudGF0aW9uLFxuICAgIG9yaWVudGF0aW9ucyxcbiAgICBkb21haW4sXG4gICAgcGFkZGluZ1xuICB9ID0gY2FsY3VsYXRlZFZhbHVlcztcbiAgY29uc3Qge1xuICAgIHRvcCxcbiAgICBib3R0b20sXG4gICAgbGVmdCxcbiAgICByaWdodFxuICB9ID0gcGFkZGluZztcbiAgY29uc3QgY2FsY3VsYXRlZE9yaWVudGF0aW9uID0ge1xuICAgIHk6IG9yaWVudGF0aW9uID09PSBcImJvdHRvbVwiIHx8IG9yaWVudGF0aW9uID09PSBcInRvcFwiID8gb3JpZW50YXRpb24gOiBvcmllbnRhdGlvbnMueCxcbiAgICB4OiBvcmllbnRhdGlvbiA9PT0gXCJsZWZ0XCIgfHwgb3JpZW50YXRpb24gPT09IFwicmlnaHRcIiA/IG9yaWVudGF0aW9uIDogb3JpZW50YXRpb25zLnlcbiAgfTtcblxuICAvLyBtYWtlIHRoZSBheGVzIGxpbmUgdXAsIGFuZCBjcm9zcyB3aGVuIGFwcHJvcHJpYXRlXG4gIGNvbnN0IG9yaWVudGF0aW9uT2Zmc2V0ID0ge1xuICAgIHg6IGNhbGN1bGF0ZWRPcmllbnRhdGlvbi55ID09PSBcImJvdHRvbVwiID8gYm90dG9tIDogdG9wLFxuICAgIHk6IGNhbGN1bGF0ZWRPcmllbnRhdGlvbi54ID09PSBcImxlZnRcIiA/IGxlZnQgOiByaWdodFxuICB9O1xuICBjb25zdCBvcmlnaW5PZmZzZXQgPSB7XG4gICAgeTogY2FsY3VsYXRlZE9yaWVudGF0aW9uLnggPT09IFwibGVmdFwiID8gMCA6IHByb3BzLndpZHRoLFxuICAgIHg6IGNhbGN1bGF0ZWRPcmllbnRhdGlvbi55ID09PSBcImJvdHRvbVwiID8gcHJvcHMuaGVpZ2h0IDogMFxuICB9O1xuICBjb25zdCBvcmlnaW5Qb3NpdGlvbiA9IHtcbiAgICB4OiBpc0VxdWFsKG9yaWdpbi54LCBkb21haW4ueFswXSkgfHwgaXNFcXVhbChvcmlnaW4ueCwgZG9tYWluLnhbMV0pID8gMCA6IHNjYWxlLngob3JpZ2luLngpLFxuICAgIHk6IGlzRXF1YWwob3JpZ2luLnksIGRvbWFpbi55WzBdKSB8fCBpc0VxdWFsKG9yaWdpbi55LCBkb21haW4ueVsxXSkgPyAwIDogc2NhbGUueShvcmlnaW4ueSlcbiAgfTtcbiAgY29uc3QgeSA9IG9yaWdpblBvc2l0aW9uLnggPyBNYXRoLmFicyhvcmlnaW5PZmZzZXQueCAtIG9yaWdpblBvc2l0aW9uLngpIDogb3JpZW50YXRpb25PZmZzZXQueDtcbiAgY29uc3QgeCA9IG9yaWdpblBvc2l0aW9uLnkgPyBNYXRoLmFicyhvcmlnaW5PZmZzZXQueSAtIG9yaWdpblBvc2l0aW9uLnkpIDogb3JpZW50YXRpb25PZmZzZXQueTtcbiAgY29uc3Qgb2Zmc2V0WCA9IGV4aXN0cyhwcm9wcy5vZmZzZXRYKSA/IHByb3BzLm9mZnNldFggOiB4O1xuICBjb25zdCBvZmZzZXRZID0gZXhpc3RzKHByb3BzLm9mZnNldFkpID8gcHJvcHMub2Zmc2V0WSA6IHk7XG4gIHJldHVybiB7XG4gICAgeDogb2Zmc2V0WCxcbiAgICB5OiBvZmZzZXRZXG4gIH07XG59O1xuY29uc3QgZ2V0VHJhbnNmb3JtID0gKHByb3BzLCBjYWxjdWxhdGVkVmFsdWVzLCBvZmZzZXQpID0+IHtcbiAgY29uc3Qge1xuICAgIG9yaWVudGF0aW9uLFxuICAgIGF4aXNcbiAgfSA9IGNhbGN1bGF0ZWRWYWx1ZXM7XG4gIGNvbnN0IGF4aXNWYWx1ZSA9IF92aWN0b3J5Q29yZS5BeGlzLmdldEF4aXNWYWx1ZShwcm9wcywgYXhpcyk7XG4gIHJldHVybiB7XG4gICAgdG9wOiB7XG4gICAgICB4OiAwLFxuICAgICAgeTogYXhpc1ZhbHVlICE9PSB1bmRlZmluZWQgPyBheGlzVmFsdWUgOiBvZmZzZXQueVxuICAgIH0sXG4gICAgYm90dG9tOiB7XG4gICAgICB4OiAwLFxuICAgICAgeTogYXhpc1ZhbHVlICE9PSB1bmRlZmluZWQgPyBheGlzVmFsdWUgOiBwcm9wcy5oZWlnaHQgLSBvZmZzZXQueVxuICAgIH0sXG4gICAgbGVmdDoge1xuICAgICAgeDogYXhpc1ZhbHVlICE9PSB1bmRlZmluZWQgPyBheGlzVmFsdWUgOiBvZmZzZXQueCxcbiAgICAgIHk6IDBcbiAgICB9LFxuICAgIHJpZ2h0OiB7XG4gICAgICB4OiBheGlzVmFsdWUgIT09IHVuZGVmaW5lZCA/IGF4aXNWYWx1ZSA6IHByb3BzLndpZHRoIC0gb2Zmc2V0LngsXG4gICAgICB5OiAwXG4gICAgfVxuICB9W29yaWVudGF0aW9uXTtcbn07XG5jb25zdCBnZXRUaWNrUG9zaXRpb24gPSAoc3R5bGUsIG9yaWVudGF0aW9uLCBpc1ZlcnRpY2FsKSA9PiB7XG4gIGNvbnN0IHtcbiAgICB0aWNrU3R5bGUsXG4gICAgbGFiZWxTdHlsZVxuICB9ID0gc3R5bGU7XG4gIGNvbnN0IHNpemUgPSB0aWNrU3R5bGUuc2l6ZSB8fCAwO1xuICBjb25zdCB0aWNrUGFkZGluZyA9IHRpY2tTdHlsZS5wYWRkaW5nIHx8IDA7XG4gIGNvbnN0IGxhYmVsUGFkZGluZyA9IGxhYmVsU3R5bGUucGFkZGluZyB8fCAwO1xuICBjb25zdCB0aWNrU3BhY2luZyA9IHNpemUgKyB0aWNrUGFkZGluZyArIGxhYmVsUGFkZGluZztcbiAgY29uc3Qgc2lnbiA9IG9yaWVudGF0aW9uU2lnbltvcmllbnRhdGlvbl07XG4gIHJldHVybiB7XG4gICAgeDogaXNWZXJ0aWNhbCA/IHNpZ24gKiB0aWNrU3BhY2luZyA6IDAsXG4gICAgeDI6IGlzVmVydGljYWwgPyBzaWduICogc2l6ZSA6IDAsXG4gICAgeTogaXNWZXJ0aWNhbCA/IDAgOiBzaWduICogdGlja1NwYWNpbmcsXG4gICAgeTI6IGlzVmVydGljYWwgPyAwIDogc2lnbiAqIHNpemVcbiAgfTtcbn07XG5jb25zdCBnZXRUaWNrVHJhbnNmb3JtID0gKHRpY2ssIGdsb2JhbFRyYW5zZm9ybSwgaXNWZXJ0aWNhbCkgPT4ge1xuICByZXR1cm4ge1xuICAgIHg6IGlzVmVydGljYWwgPyBnbG9iYWxUcmFuc2Zvcm0ueCA6IHRpY2sgKyBnbG9iYWxUcmFuc2Zvcm0ueCxcbiAgICB5OiBpc1ZlcnRpY2FsID8gdGljayArIGdsb2JhbFRyYW5zZm9ybS55IDogZ2xvYmFsVHJhbnNmb3JtLnlcbiAgfTtcbn07XG5jb25zdCBnZXRHcmlkRWRnZSA9IChwcm9wcywgY2FsY3VsYXRlZFZhbHVlcykgPT4ge1xuICBjb25zdCB7XG4gICAgb3JpZW50YXRpb24sXG4gICAgcGFkZGluZyxcbiAgICBpc1ZlcnRpY2FsXG4gIH0gPSBjYWxjdWxhdGVkVmFsdWVzO1xuICBjb25zdCBzaWduID0gLW9yaWVudGF0aW9uU2lnbltvcmllbnRhdGlvbl07XG4gIGNvbnN0IHggPSBpc1ZlcnRpY2FsID8gc2lnbiAqIChwcm9wcy53aWR0aCAtIChwYWRkaW5nLmxlZnQgKyBwYWRkaW5nLnJpZ2h0KSkgOiAwO1xuICBjb25zdCB5ID0gaXNWZXJ0aWNhbCA/IDAgOiBzaWduICogKHByb3BzLmhlaWdodCAtIChwYWRkaW5nLnRvcCArIHBhZGRpbmcuYm90dG9tKSk7XG4gIHJldHVybiB7XG4gICAgeCxcbiAgICB5XG4gIH07XG59O1xuY29uc3QgZ2V0R3JpZE9mZnNldCA9IChjYWxjdWxhdGVkVmFsdWVzLCBvZmZzZXQpID0+IHtcbiAgY29uc3Qge1xuICAgIHBhZGRpbmcsXG4gICAgb3JpZW50YXRpb24sXG4gICAgY3Jvc3NBeGlzXG4gIH0gPSBjYWxjdWxhdGVkVmFsdWVzO1xuICBjb25zdCB4UGFkZGluZyA9IG9yaWVudGF0aW9uID09PSBcInJpZ2h0XCIgPyBwYWRkaW5nLnJpZ2h0IDogcGFkZGluZy5sZWZ0O1xuICBjb25zdCB5UGFkZGluZyA9IG9yaWVudGF0aW9uID09PSBcInRvcFwiID8gcGFkZGluZy50b3AgOiBwYWRkaW5nLmJvdHRvbTtcbiAgcmV0dXJuIHtcbiAgICB4OiBjcm9zc0F4aXMgPyBvZmZzZXQueCAtIHhQYWRkaW5nIDogMCxcbiAgICB5OiBjcm9zc0F4aXMgPyBvZmZzZXQueSAtIHlQYWRkaW5nIDogMFxuICB9O1xufTtcbmNvbnN0IGdldExheW91dFByb3BzID0gKG1vZGlmaWVkUHJvcHMsIGNhbGN1bGF0ZWRWYWx1ZXMpID0+IHtcbiAgbGV0IG9mZnNldDtcbiAgaWYgKGNhbGN1bGF0ZWRWYWx1ZXMuZG9tYWluLnggJiYgY2FsY3VsYXRlZFZhbHVlcy5kb21haW4ueSkge1xuICAgIG9mZnNldCA9IG1vZGlmaWVkUHJvcHMuaG9yaXpvbnRhbCA/IGdldEhvcml6b250YWxPZmZzZXQobW9kaWZpZWRQcm9wcywgY2FsY3VsYXRlZFZhbHVlcykgOiBnZXRPZmZzZXQobW9kaWZpZWRQcm9wcywgY2FsY3VsYXRlZFZhbHVlcyk7XG4gIH0gZWxzZSB7XG4gICAgb2Zmc2V0ID0gZ2V0U3RhbmRhbG9uZU9mZnNldChtb2RpZmllZFByb3BzLCBjYWxjdWxhdGVkVmFsdWVzKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGdsb2JhbFRyYW5zZm9ybTogZ2V0VHJhbnNmb3JtKG1vZGlmaWVkUHJvcHMsIGNhbGN1bGF0ZWRWYWx1ZXMsIG9mZnNldCksXG4gICAgZ3JpZE9mZnNldDogZ2V0R3JpZE9mZnNldChjYWxjdWxhdGVkVmFsdWVzLCBvZmZzZXQpLFxuICAgIGdyaWRFZGdlOiBnZXRHcmlkRWRnZShtb2RpZmllZFByb3BzLCBjYWxjdWxhdGVkVmFsdWVzKVxuICB9O1xufTtcbmNvbnN0IGdldE9yaWVudGF0aW9uID0gcHJvcHMgPT4ge1xuICBpZiAocHJvcHMub3JpZW50YXRpb24pIHtcbiAgICByZXR1cm4gcHJvcHMub3JpZW50YXRpb247XG4gIH1cbiAgY29uc3QgZGVmYXVsdE9yaWVudGF0aW9ucyA9IHtcbiAgICBkZXBlbmRlbnQ6IHByb3BzLmhvcml6b250YWwgPyBcImJvdHRvbVwiIDogXCJsZWZ0XCIsXG4gICAgaW5kZXBlbmRlbnQ6IHByb3BzLmhvcml6b250YWwgPyBcImxlZnRcIiA6IFwiYm90dG9tXCJcbiAgfTtcbiAgcmV0dXJuIHByb3BzLmRlcGVuZGVudEF4aXMgPyBkZWZhdWx0T3JpZW50YXRpb25zLmRlcGVuZGVudCA6IGRlZmF1bHRPcmllbnRhdGlvbnMuaW5kZXBlbmRlbnQ7XG59O1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuY29uc3QgZ2V0Q2FsY3VsYXRlZFZhbHVlcyA9IHByb3BzID0+IHtcbiAgY29uc3QgZGVmYXVsdFN0eWxlcyA9IGdldFN0eWxlT2JqZWN0KHByb3BzKTtcbiAgY29uc3Qgc3R5bGUgPSBnZXRTdHlsZXMocHJvcHMsIGRlZmF1bHRTdHlsZXMpO1xuICBjb25zdCBwYWRkaW5nID0gX3ZpY3RvcnlDb3JlLkhlbHBlcnMuZ2V0UGFkZGluZyhwcm9wcyk7XG4gIGNvbnN0IGxhYmVsUGFkZGluZyA9IGdldExhYmVsUGFkZGluZyhwcm9wcywgc3R5bGUpO1xuICBjb25zdCBzdHJpbmdUaWNrcyA9IF92aWN0b3J5Q29yZS5BeGlzLnN0cmluZ1RpY2tzKHByb3BzKSA/IHByb3BzLnRpY2tWYWx1ZXMgOiB1bmRlZmluZWQ7XG4gIGNvbnN0IGF4aXMgPSBfdmljdG9yeUNvcmUuQXhpcy5nZXRBeGlzKHByb3BzKTtcbiAgY29uc3QgYXhpc0RvbWFpbiA9IF92aWN0b3J5Q29yZS5BeGlzLmdldERvbWFpbihwcm9wcyk7XG4gIGNvbnN0IGF4aXNTY2FsZSA9IGdldFNjYWxlKHByb3BzKTtcbiAgY29uc3QgeEF4aXNEb21haW4gPSBheGlzID09PSBcInhcIiA/IGF4aXNEb21haW4gOiB1bmRlZmluZWQ7XG4gIGNvbnN0IHlBeGlzRG9tYWluID0gYXhpcyA9PT0gXCJ5XCIgPyBheGlzRG9tYWluIDogdW5kZWZpbmVkO1xuICBjb25zdCB4QXhpc1NjYWxlID0gYXhpcyA9PT0gXCJ4XCIgPyBheGlzU2NhbGUgOiB1bmRlZmluZWQ7XG4gIGNvbnN0IHlBeGlzU2NhbGUgPSBheGlzID09PSBcInlcIiA/IGF4aXNTY2FsZSA6IHVuZGVmaW5lZDtcbiAgY29uc3QgY3Jvc3NBeGlzID0gIShwcm9wcy5jcm9zc0F4aXMgPT09IGZhbHNlIHx8IHByb3BzLnN0YW5kYWxvbmUgPT09IHRydWUpO1xuICBjb25zdCB0aWNrcyA9IF92aWN0b3J5Q29yZS5BeGlzLmdldFRpY2tzKHByb3BzLCBheGlzU2NhbGUsIGNyb3NzQXhpcyk7XG4gIGNvbnN0IHRpY2tGb3JtYXQgPSBfdmljdG9yeUNvcmUuQXhpcy5nZXRUaWNrRm9ybWF0KHByb3BzLCBheGlzU2NhbGUpO1xuICBjb25zdCByYW5nZSA9IHtcbiAgICB4OiBfdmljdG9yeUNvcmUuSGVscGVycy5nZXRSYW5nZShwcm9wcywgXCJ4XCIpLFxuICAgIHk6IF92aWN0b3J5Q29yZS5IZWxwZXJzLmdldFJhbmdlKHByb3BzLCBcInlcIilcbiAgfTtcbiAgLy8gdXNlIGZ1bGwgZG9tYWluIGlmIHBhc3NlZCBpbiBmcm9tIHBhcmVudCxcbiAgLy8gb3RoZXJ3aXNlIHVzZSB0aGUganVzdCB0aGUgb25lIGF4aXMgYXZhaWxhYmxlXG4gIGNvbnN0IGRvbWFpbiA9IHtcbiAgICB4OiBwcm9wcy5kb21haW4gJiYgcHJvcHMuZG9tYWluLnggPyBwcm9wcy5kb21haW4ueCA6IHhBeGlzRG9tYWluLFxuICAgIHk6IHByb3BzLmRvbWFpbiAmJiBwcm9wcy5kb21haW4ueSA/IHByb3BzLmRvbWFpbi55IDogeUF4aXNEb21haW5cbiAgfTtcbiAgLy8gdXNlIGZ1bGwgc2NhbGUgaWYgcGFzc2VkIGluIGZyb20gcGFyZW50LFxuICAvLyBvdGhlcndpc2UgdXNlIHRoZSBqdXN0IHRoZSBvbmUgYXhpcyBhdmFpbGFibGVcbiAgY29uc3Qgc2NhbGUgPSB7XG4gICAgeDogcHJvcHMuZG9tYWluICYmIHByb3BzLmRvbWFpbi54ID8gX3ZpY3RvcnlDb3JlLlNjYWxlLmdldEJhc2VTY2FsZShwcm9wcywgXCJ4XCIpLmRvbWFpbihwcm9wcy5kb21haW4ueCkucmFuZ2UocHJvcHMuaG9yaXpvbnRhbCA/IHJhbmdlLnkgOiByYW5nZS54KSA6IHhBeGlzU2NhbGUsXG4gICAgeTogcHJvcHMuZG9tYWluICYmIHByb3BzLmRvbWFpbi55ID8gX3ZpY3RvcnlDb3JlLlNjYWxlLmdldEJhc2VTY2FsZShwcm9wcywgXCJ5XCIpLmRvbWFpbihwcm9wcy5kb21haW4ueSkucmFuZ2UocHJvcHMuaG9yaXpvbnRhbCA/IHJhbmdlLnggOiByYW5nZS55KSA6IHlBeGlzU2NhbGVcbiAgfTtcbiAgY29uc3Qgb3JpZ2luID0gZG9tYWluLnggJiYgZG9tYWluLnkgPyBfdmljdG9yeUNvcmUuQXhpcy5nZXRPcmlnaW4oZG9tYWluKSA6IHVuZGVmaW5lZDtcbiAgY29uc3Qgb3JpZ2luU2lnbiA9IG9yaWdpbiA/IHtcbiAgICB4OiBfdmljdG9yeUNvcmUuQXhpcy5nZXRPcmlnaW5TaWduKG9yaWdpbi54LCBkb21haW4ueCksXG4gICAgeTogX3ZpY3RvcnlDb3JlLkF4aXMuZ2V0T3JpZ2luU2lnbihvcmlnaW4ueSwgZG9tYWluLnkpXG4gIH0gOiB1bmRlZmluZWQ7XG4gIGNvbnN0IG9yaWVudGF0aW9ucyA9IG9yaWdpblNpZ24gPyB7XG4gICAgeDogZ2V0RGVmYXVsdE9yaWVudGF0aW9ucyhcInhcIiwgb3JpZ2luU2lnbi55LCBwcm9wcy5ob3Jpem9udGFsKSxcbiAgICB5OiBnZXREZWZhdWx0T3JpZW50YXRpb25zKFwieVwiLCBvcmlnaW5TaWduLngsIHByb3BzLmhvcml6b250YWwpXG4gIH0gOiB1bmRlZmluZWQ7XG4gIGNvbnN0IG9yaWVudGF0aW9uID0gb3JpZW50YXRpb25zID8gcHJvcHMub3JpZW50YXRpb24gfHwgb3JpZW50YXRpb25zW2F4aXNdIDogZ2V0T3JpZW50YXRpb24ocHJvcHMpO1xuICBjb25zdCBpc1ZlcnRpY2FsID0gX3ZpY3RvcnlDb3JlLkF4aXMuaXNWZXJ0aWNhbChPYmplY3QuYXNzaWduKHt9LCBwcm9wcywge1xuICAgIG9yaWVudGF0aW9uXG4gIH0pKTtcbiAgY29uc3QgYW5jaG9ycyA9IGdldEFuY2hvcnMob3JpZW50YXRpb24sIGlzVmVydGljYWwpO1xuICByZXR1cm4ge1xuICAgIGFuY2hvcnMsXG4gICAgYXhpcyxcbiAgICBjcm9zc0F4aXMsXG4gICAgZG9tYWluLFxuICAgIGlzVmVydGljYWwsXG4gICAgbGFiZWxQYWRkaW5nLFxuICAgIG9yaWVudGF0aW9uLFxuICAgIG9yaWVudGF0aW9ucyxcbiAgICBvcmlnaW4sXG4gICAgcGFkZGluZyxcbiAgICBzY2FsZSxcbiAgICBzdHJpbmdUaWNrcyxcbiAgICBzdHlsZSxcbiAgICB0aWNrRm9ybWF0LFxuICAgIHRpY2tzXG4gIH07XG59O1xuY29uc3QgZ2V0QmFzZVByb3BzID0gKGluaXRpYWxQcm9wcywgZmFsbGJhY2tQcm9wcykgPT4ge1xuICBjb25zdCBwcm9wcyA9IF92aWN0b3J5Q29yZS5BeGlzLm1vZGlmeVByb3BzKGluaXRpYWxQcm9wcywgZmFsbGJhY2tQcm9wcyk7XG4gIGNvbnN0IGNhbGN1bGF0ZWRWYWx1ZXMgPSBnZXRDYWxjdWxhdGVkVmFsdWVzKHByb3BzKTtcbiAgY29uc3Qge1xuICAgIGF4aXMsXG4gICAgc3R5bGUsXG4gICAgb3JpZW50YXRpb24sXG4gICAgaXNWZXJ0aWNhbCxcbiAgICBzY2FsZSxcbiAgICB0aWNrcyxcbiAgICB0aWNrRm9ybWF0LFxuICAgIGFuY2hvcnMsXG4gICAgZG9tYWluLFxuICAgIHN0cmluZ1RpY2tzXG4gIH0gPSBjYWxjdWxhdGVkVmFsdWVzO1xuICBjb25zdCBvdGhlckF4aXMgPSBheGlzID09PSBcInhcIiA/IFwieVwiIDogXCJ4XCI7XG4gIGNvbnN0IHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgc3RhbmRhbG9uZSxcbiAgICB0aGVtZSxcbiAgICBwb2xhcixcbiAgICBwYWRkaW5nLFxuICAgIGhvcml6b250YWxcbiAgfSA9IHByb3BzO1xuICBjb25zdCB7XG4gICAgZ2xvYmFsVHJhbnNmb3JtLFxuICAgIGdyaWRPZmZzZXQsXG4gICAgZ3JpZEVkZ2VcbiAgfSA9IGdldExheW91dFByb3BzKHByb3BzLCBjYWxjdWxhdGVkVmFsdWVzKTtcbiAgY29uc3Qgc2hhcmVkUHJvcHMgPSB7XG4gICAgc2NhbGU6IHtcbiAgICAgIFtheGlzXTogc2NhbGVbYXhpc11cbiAgICB9LFxuICAgIHBvbGFyLFxuICAgIGhvcml6b250YWwsXG4gICAgdGlja3MsXG4gICAgc3RyaW5nVGlja3NcbiAgfTtcbiAgY29uc3QgYXhpc1Byb3BzID0gZ2V0QXhpc1Byb3BzKHByb3BzLCBjYWxjdWxhdGVkVmFsdWVzLCBnbG9iYWxUcmFuc2Zvcm0pO1xuICBjb25zdCBheGlzTGFiZWxQcm9wcyA9IGdldEF4aXNMYWJlbFByb3BzKHByb3BzLCBjYWxjdWxhdGVkVmFsdWVzLCBnbG9iYWxUcmFuc2Zvcm0pO1xuICBjb25zdCBpbml0aWFsQ2hpbGRQcm9wcyA9IHtcbiAgICBwYXJlbnQ6IE9iamVjdC5hc3NpZ24oe1xuICAgICAgc3R5bGU6IHN0eWxlLnBhcmVudCxcbiAgICAgIHRpY2tzLFxuICAgICAgc3RhbmRhbG9uZSxcbiAgICAgIHRoZW1lLFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICBwYWRkaW5nLFxuICAgICAgZG9tYWluXG4gICAgfSwgc2hhcmVkUHJvcHMpXG4gIH07XG4gIGNvbnN0IGdyaWRQcm9wcyA9IHtcbiAgICBkaW1lbnNpb246IG90aGVyQXhpcyxcbiAgICByYW5nZToge1xuICAgICAgW290aGVyQXhpc106IF92aWN0b3J5Q29yZS5IZWxwZXJzLmdldFJhbmdlKHByb3BzLCBvdGhlckF4aXMpXG4gICAgfSxcbiAgICBzY2FsZTogcHJvcHMuc2NhbGUgJiYgcHJvcHMuc2NhbGVbb3RoZXJBeGlzXSA/IHtcbiAgICAgIFtvdGhlckF4aXNdOiBwcm9wcy5zY2FsZVtvdGhlckF4aXNdXG4gICAgfSA6IHVuZGVmaW5lZFxuICB9O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LXR5cGUtYXNzZXJ0aW9uXG4gIHJldHVybiB0aWNrcy5yZWR1Y2UoKGNoaWxkUHJvcHMsIHRpY2tWYWx1ZSwgaW5kZXgpID0+IHtcbiAgICBjb25zdCB0aWNrID0gc3RyaW5nVGlja3MgPyBzdHJpbmdUaWNrc1tpbmRleF0gOiB0aWNrVmFsdWU7XG4gICAgY29uc3QgdGV4dCA9IHRpY2tGb3JtYXQodGlja1ZhbHVlLCBpbmRleCwgdGlja3MpO1xuICAgIGNvbnN0IHN0eWxlcyA9IGdldEV2YWx1YXRlZFN0eWxlcyhzdHlsZSwgT2JqZWN0LmFzc2lnbih7fSwgc2hhcmVkUHJvcHMsIHtcbiAgICAgIHRpY2ssXG4gICAgICB0aWNrVmFsdWUsXG4gICAgICBpbmRleCxcbiAgICAgIHRleHRcbiAgICB9KSk7XG4gICAgY29uc3QgdGlja0xheW91dCA9IHtcbiAgICAgIHBvc2l0aW9uOiBnZXRUaWNrUG9zaXRpb24oc3R5bGVzLCBvcmllbnRhdGlvbiwgaXNWZXJ0aWNhbCksXG4gICAgICB0cmFuc2Zvcm06IGdldFRpY2tUcmFuc2Zvcm0oc2NhbGVbYXhpc10/Lih0aWNrVmFsdWUpLCBnbG9iYWxUcmFuc2Zvcm0sIGlzVmVydGljYWwpXG4gICAgfTtcbiAgICBjb25zdCBncmlkTGF5b3V0ID0ge1xuICAgICAgZWRnZTogZ3JpZEVkZ2UsXG4gICAgICB0cmFuc2Zvcm06IHtcbiAgICAgICAgeDogaXNWZXJ0aWNhbCA/IC1ncmlkT2Zmc2V0LnggKyBnbG9iYWxUcmFuc2Zvcm0ueCA6IHNjYWxlW2F4aXNdPy4odGlja1ZhbHVlKSArIGdsb2JhbFRyYW5zZm9ybS54LFxuICAgICAgICB5OiBpc1ZlcnRpY2FsID8gc2NhbGVbYXhpc10/Lih0aWNrVmFsdWUpICsgZ2xvYmFsVHJhbnNmb3JtLnkgOiBncmlkT2Zmc2V0LnkgKyBnbG9iYWxUcmFuc2Zvcm0ueVxuICAgICAgfVxuICAgIH07XG4gICAgY2hpbGRQcm9wc1tpbmRleF0gPSB7XG4gICAgICBheGlzOiBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgZGltZW5zaW9uOiBheGlzXG4gICAgICB9LCBzaGFyZWRQcm9wcywgYXhpc1Byb3BzKSxcbiAgICAgIGF4aXNMYWJlbDogT2JqZWN0LmFzc2lnbih7fSwgc2hhcmVkUHJvcHMsIGF4aXNMYWJlbFByb3BzKSxcbiAgICAgIHRpY2tzOiBPYmplY3QuYXNzaWduKHt9LCBzaGFyZWRQcm9wcywgZ2V0VGlja1Byb3BzKHRpY2tMYXlvdXQsIHN0eWxlcy50aWNrU3R5bGUsIHRpY2tWYWx1ZSkpLFxuICAgICAgdGlja0xhYmVsczogT2JqZWN0LmFzc2lnbih7fSwgc2hhcmVkUHJvcHMsIGdldFRpY2tMYWJlbFByb3BzKHRpY2tMYXlvdXQsIHN0eWxlcy5sYWJlbFN0eWxlLCBhbmNob3JzLCB0aWNrVmFsdWUsIHRleHQpKSxcbiAgICAgIGdyaWQ6IE9iamVjdC5hc3NpZ24oe30sIHNoYXJlZFByb3BzLCBncmlkUHJvcHMsIGdldEdyaWRQcm9wcyhncmlkTGF5b3V0LCBzdHlsZXMuZ3JpZFN0eWxlLCB0aWNrVmFsdWUpKVxuICAgIH07XG4gICAgcmV0dXJuIGNoaWxkUHJvcHM7XG4gIH0sIGluaXRpYWxDaGlsZFByb3BzKTtcbn07XG5leHBvcnRzLmdldEJhc2VQcm9wcyA9IGdldEJhc2VQcm9wczsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/victory-axis/lib/helper-methods.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/victory-axis/lib/index.js":
/*!************************************************!*\
  !*** ./node_modules/victory-axis/lib/index.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nvar _victoryAxis = __webpack_require__(/*! ./victory-axis */ \"(ssr)/./node_modules/victory-axis/lib/victory-axis.js\");\nObject.keys(_victoryAxis).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _victoryAxis[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _victoryAxis[key];\n    }\n  });\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdmljdG9yeS1heGlzL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixtQkFBbUIsbUJBQU8sQ0FBQyw2RUFBZ0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGVtcC8uL25vZGVfbW9kdWxlcy92aWN0b3J5LWF4aXMvbGliL2luZGV4LmpzP2JlZmQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG52YXIgX3ZpY3RvcnlBeGlzID0gcmVxdWlyZShcIi4vdmljdG9yeS1heGlzXCIpO1xuT2JqZWN0LmtleXMoX3ZpY3RvcnlBeGlzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfdmljdG9yeUF4aXNba2V5XSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfdmljdG9yeUF4aXNba2V5XTtcbiAgICB9XG4gIH0pO1xufSk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/victory-axis/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/victory-axis/lib/victory-axis.js":
/*!*******************************************************!*\
  !*** ./node_modules/victory-axis/lib/victory-axis.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.VictoryAxis = void 0;\nvar _isEmpty2 = _interopRequireDefault(__webpack_require__(/*! lodash/isEmpty */ \"(ssr)/./node_modules/lodash/isEmpty.js\"));\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\nvar _victoryCore = __webpack_require__(/*! victory-core */ \"(ssr)/./node_modules/victory-core/lib/index.js\");\nvar _helperMethods = __webpack_require__(/*! ./helper-methods */ \"(ssr)/./node_modules/victory-axis/lib/helper-methods.js\");\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nconst fallbackProps = {\n  width: 450,\n  height: 300,\n  padding: 50\n};\nconst options = {\n  components: [{\n    name: \"axis\",\n    index: 0\n  }, {\n    name: \"axisLabel\",\n    index: 0\n  }, {\n    name: \"grid\"\n  }, {\n    name: \"parent\",\n    index: \"parent\"\n  }, {\n    name: \"ticks\"\n  }, {\n    name: \"tickLabels\"\n  }]\n};\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\n\nclass VictoryAxisBase extends _react.default.Component {\n  static animationWhitelist = [\"style\", \"domain\", \"range\", \"tickCount\", \"tickValues\", \"offsetX\", \"offsetY\", \"padding\", \"width\", \"height\"];\n  static displayName = \"VictoryAxis\";\n  static role = \"axis\";\n  static defaultTransitions = {\n    onExit: {\n      duration: 500\n    },\n    onEnter: {\n      duration: 500\n    }\n  };\n  static defaultProps = {\n    axisComponent: /*#__PURE__*/_react.default.createElement(_victoryCore.LineSegment, null),\n    axisLabelComponent: /*#__PURE__*/_react.default.createElement(_victoryCore.VictoryLabel, null),\n    tickLabelComponent: /*#__PURE__*/_react.default.createElement(_victoryCore.VictoryLabel, null),\n    tickComponent: /*#__PURE__*/_react.default.createElement(_victoryCore.LineSegment, null),\n    gridComponent: /*#__PURE__*/_react.default.createElement(_victoryCore.LineSegment, null),\n    standalone: true,\n    theme: _victoryCore.VictoryTheme.grayscale,\n    containerComponent: /*#__PURE__*/_react.default.createElement(_victoryCore.VictoryContainer, null),\n    groupComponent: /*#__PURE__*/_react.default.createElement(\"g\", {\n      role: \"presentation\"\n    }),\n    fixLabelOverlap: false\n  };\n  static getDomain = _victoryCore.Axis.getDomain;\n  static getAxis = _victoryCore.Axis.getAxis;\n  static getStyles(props) {\n    return (0, _helperMethods.getStyles)(props);\n  }\n  static getBaseProps(props) {\n    return (0, _helperMethods.getBaseProps)(props, fallbackProps);\n  }\n  static expectedComponents = [\"axisComponent\", \"axisLabelComponent\", \"groupComponent\", \"containerComponent\", \"tickComponent\", \"tickLabelComponent\", \"gridComponent\"];\n  renderLine(props) {\n    const {\n      axisComponent\n    } = props;\n    const axisProps = this.getComponentProps(axisComponent, \"axis\", 0);\n    return /*#__PURE__*/_react.default.cloneElement(axisComponent, axisProps);\n  }\n  renderLabel(props) {\n    const {\n      axisLabelComponent,\n      label\n    } = props;\n    if (!label) {\n      return null;\n    }\n    const axisLabelProps = this.getComponentProps(axisLabelComponent, \"axisLabel\", 0);\n    return /*#__PURE__*/_react.default.cloneElement(axisLabelComponent, axisLabelProps);\n  }\n  renderGridAndTicks(props) {\n    const {\n      tickComponent,\n      tickLabelComponent,\n      gridComponent,\n      name\n    } = props;\n    const shouldRender = componentProps => {\n      const {\n        style = {},\n        events = {}\n      } = componentProps;\n      const visible = style.stroke !== \"transparent\" && style.stroke !== \"none\" && style.strokeWidth !== 0;\n      return visible || !(0, _isEmpty2.default)(events);\n    };\n    return this.dataKeys.map((key, index) => {\n      const tickProps = this.getComponentProps(tickComponent, \"ticks\", index);\n      const BaseTickComponent = /*#__PURE__*/_react.default.cloneElement(tickComponent, tickProps);\n      const TickComponent = shouldRender(BaseTickComponent.props) ? BaseTickComponent : undefined;\n      const gridProps = this.getComponentProps(gridComponent, \"grid\", index);\n      const BaseGridComponent = /*#__PURE__*/_react.default.cloneElement(gridComponent, gridProps);\n      const GridComponent = shouldRender(BaseGridComponent.props) ? BaseGridComponent : undefined;\n      const tickLabelProps = this.getComponentProps(tickLabelComponent, \"tickLabels\", index);\n      const TickLabel = /*#__PURE__*/_react.default.cloneElement(tickLabelComponent, tickLabelProps);\n      const children = [GridComponent, TickComponent, TickLabel].filter(Boolean);\n      return /*#__PURE__*/_react.default.cloneElement(props.groupComponent, {\n        key: `${name}-tick-group-${key}`\n      }, children);\n    });\n  }\n  fixLabelOverlap(gridAndTicks, props) {\n    const isVertical = _victoryCore.Axis.isVertical(props);\n    const size = isVertical ? props.height : props.width;\n    const isVictoryLabel = child => child.type && child.type.role === \"label\";\n    const labels = gridAndTicks.map(gridAndTick => gridAndTick.props.children).reduce((accumulator, childArr) => accumulator.concat(childArr), []).filter(isVictoryLabel).map(child => child.props);\n    const paddingToObject = padding => typeof padding === \"object\" ? Object.assign({}, {\n      top: 0,\n      right: 0,\n      bottom: 0,\n      left: 0\n    }, padding) : {\n      top: padding,\n      right: padding,\n      bottom: padding,\n      left: padding\n    };\n    const labelsSumSize = labels.reduce((sum, label) => {\n      const padding = paddingToObject(label.style.padding);\n      const labelSize = _victoryCore.TextSize.approximateTextSize(label.text, {\n        angle: label.angle,\n        fontSize: label.style.fontSize,\n        letterSpacing: label.style.letterSpacing,\n        fontFamily: label.style.fontFamily\n      });\n      return sum + (isVertical ? labelSize.height + padding.top + padding.bottom : labelSize.width + padding.right + padding.left);\n    }, 0);\n    const availiableLabelCount = Math.floor(size * gridAndTicks.length / labelsSumSize);\n    const divider = Math.ceil(gridAndTicks.length / availiableLabelCount) || 1;\n    const getLabelCoord = gridAndTick => gridAndTick.props.children.filter(isVictoryLabel).reduce((prev, child) => (isVertical ? child.props.y : child.props.x) || 0, 0);\n    const sorted = gridAndTicks.sort((a, b) => isVertical ? getLabelCoord(b) - getLabelCoord(a) // ordinary axis has top-bottom orientation\n    : getLabelCoord(a) - getLabelCoord(b) // ordinary axis has left-right orientation\n    );\n    return sorted.filter((gridAndTick, index) => index % divider === 0);\n  }\n\n  // Overridden in native versions\n  shouldAnimate() {\n    return !!this.props.animate;\n  }\n  render() {\n    const {\n      animationWhitelist\n    } = VictoryAxis;\n    const props = _victoryCore.Axis.modifyProps(this.props, fallbackProps);\n    const userProps = _victoryCore.UserProps.getSafeUserProps(this.props);\n    if (this.shouldAnimate()) {\n      return this.animateComponent(props, animationWhitelist);\n    }\n    const gridAndTicks = this.renderGridAndTicks(props);\n    const modifiedGridAndTicks = props.fixLabelOverlap ? this.fixLabelOverlap(gridAndTicks, props) : gridAndTicks;\n    const children = [this.renderLine(props), this.renderLabel(props), ...modifiedGridAndTicks];\n    const container = /*#__PURE__*/_react.default.cloneElement(props.containerComponent, userProps);\n    return props.standalone ? this.renderContainer(container, children) : /*#__PURE__*/_react.default.cloneElement(props.groupComponent, userProps, children);\n  }\n}\nconst VictoryAxis = exports.VictoryAxis = (0, _victoryCore.addEvents)(VictoryAxisBase, options);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdmljdG9yeS1heGlzL2xpYi92aWN0b3J5LWF4aXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsbUJBQW1CO0FBQ25CLHVDQUF1QyxtQkFBTyxDQUFDLDhEQUFnQjtBQUMvRCxvQ0FBb0MsbUJBQU8sQ0FBQyx3R0FBTztBQUNuRCxtQkFBbUIsbUJBQU8sQ0FBQyxvRUFBYztBQUN6QyxxQkFBcUIsbUJBQU8sQ0FBQyxpRkFBa0I7QUFDL0MsdUNBQXVDLHVDQUF1QztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsS0FBSyxjQUFjLElBQUk7QUFDdkMsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRkFBcUY7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQiIsInNvdXJjZXMiOlsid2VicGFjazovL3RlbXAvLi9ub2RlX21vZHVsZXMvdmljdG9yeS1heGlzL2xpYi92aWN0b3J5LWF4aXMuanM/MjE2NyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuVmljdG9yeUF4aXMgPSB2b2lkIDA7XG52YXIgX2lzRW1wdHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2lzRW1wdHlcIikpO1xudmFyIF9yZWFjdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBfdmljdG9yeUNvcmUgPSByZXF1aXJlKFwidmljdG9yeS1jb3JlXCIpO1xudmFyIF9oZWxwZXJNZXRob2RzID0gcmVxdWlyZShcIi4vaGVscGVyLW1ldGhvZHNcIik7XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuY29uc3QgZmFsbGJhY2tQcm9wcyA9IHtcbiAgd2lkdGg6IDQ1MCxcbiAgaGVpZ2h0OiAzMDAsXG4gIHBhZGRpbmc6IDUwXG59O1xuY29uc3Qgb3B0aW9ucyA9IHtcbiAgY29tcG9uZW50czogW3tcbiAgICBuYW1lOiBcImF4aXNcIixcbiAgICBpbmRleDogMFxuICB9LCB7XG4gICAgbmFtZTogXCJheGlzTGFiZWxcIixcbiAgICBpbmRleDogMFxuICB9LCB7XG4gICAgbmFtZTogXCJncmlkXCJcbiAgfSwge1xuICAgIG5hbWU6IFwicGFyZW50XCIsXG4gICAgaW5kZXg6IFwicGFyZW50XCJcbiAgfSwge1xuICAgIG5hbWU6IFwidGlja3NcIlxuICB9LCB7XG4gICAgbmFtZTogXCJ0aWNrTGFiZWxzXCJcbiAgfV1cbn07XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZW1wdHktaW50ZXJmYWNlXG5cbmNsYXNzIFZpY3RvcnlBeGlzQmFzZSBleHRlbmRzIF9yZWFjdC5kZWZhdWx0LkNvbXBvbmVudCB7XG4gIHN0YXRpYyBhbmltYXRpb25XaGl0ZWxpc3QgPSBbXCJzdHlsZVwiLCBcImRvbWFpblwiLCBcInJhbmdlXCIsIFwidGlja0NvdW50XCIsIFwidGlja1ZhbHVlc1wiLCBcIm9mZnNldFhcIiwgXCJvZmZzZXRZXCIsIFwicGFkZGluZ1wiLCBcIndpZHRoXCIsIFwiaGVpZ2h0XCJdO1xuICBzdGF0aWMgZGlzcGxheU5hbWUgPSBcIlZpY3RvcnlBeGlzXCI7XG4gIHN0YXRpYyByb2xlID0gXCJheGlzXCI7XG4gIHN0YXRpYyBkZWZhdWx0VHJhbnNpdGlvbnMgPSB7XG4gICAgb25FeGl0OiB7XG4gICAgICBkdXJhdGlvbjogNTAwXG4gICAgfSxcbiAgICBvbkVudGVyOiB7XG4gICAgICBkdXJhdGlvbjogNTAwXG4gICAgfVxuICB9O1xuICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgIGF4aXNDb21wb25lbnQ6IC8qI19fUFVSRV9fKi9fcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF92aWN0b3J5Q29yZS5MaW5lU2VnbWVudCwgbnVsbCksXG4gICAgYXhpc0xhYmVsQ29tcG9uZW50OiAvKiNfX1BVUkVfXyovX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfdmljdG9yeUNvcmUuVmljdG9yeUxhYmVsLCBudWxsKSxcbiAgICB0aWNrTGFiZWxDb21wb25lbnQ6IC8qI19fUFVSRV9fKi9fcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF92aWN0b3J5Q29yZS5WaWN0b3J5TGFiZWwsIG51bGwpLFxuICAgIHRpY2tDb21wb25lbnQ6IC8qI19fUFVSRV9fKi9fcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF92aWN0b3J5Q29yZS5MaW5lU2VnbWVudCwgbnVsbCksXG4gICAgZ3JpZENvbXBvbmVudDogLyojX19QVVJFX18qL19yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX3ZpY3RvcnlDb3JlLkxpbmVTZWdtZW50LCBudWxsKSxcbiAgICBzdGFuZGFsb25lOiB0cnVlLFxuICAgIHRoZW1lOiBfdmljdG9yeUNvcmUuVmljdG9yeVRoZW1lLmdyYXlzY2FsZSxcbiAgICBjb250YWluZXJDb21wb25lbnQ6IC8qI19fUFVSRV9fKi9fcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF92aWN0b3J5Q29yZS5WaWN0b3J5Q29udGFpbmVyLCBudWxsKSxcbiAgICBncm91cENvbXBvbmVudDogLyojX19QVVJFX18qL19yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJnXCIsIHtcbiAgICAgIHJvbGU6IFwicHJlc2VudGF0aW9uXCJcbiAgICB9KSxcbiAgICBmaXhMYWJlbE92ZXJsYXA6IGZhbHNlXG4gIH07XG4gIHN0YXRpYyBnZXREb21haW4gPSBfdmljdG9yeUNvcmUuQXhpcy5nZXREb21haW47XG4gIHN0YXRpYyBnZXRBeGlzID0gX3ZpY3RvcnlDb3JlLkF4aXMuZ2V0QXhpcztcbiAgc3RhdGljIGdldFN0eWxlcyhwcm9wcykge1xuICAgIHJldHVybiAoMCwgX2hlbHBlck1ldGhvZHMuZ2V0U3R5bGVzKShwcm9wcyk7XG4gIH1cbiAgc3RhdGljIGdldEJhc2VQcm9wcyhwcm9wcykge1xuICAgIHJldHVybiAoMCwgX2hlbHBlck1ldGhvZHMuZ2V0QmFzZVByb3BzKShwcm9wcywgZmFsbGJhY2tQcm9wcyk7XG4gIH1cbiAgc3RhdGljIGV4cGVjdGVkQ29tcG9uZW50cyA9IFtcImF4aXNDb21wb25lbnRcIiwgXCJheGlzTGFiZWxDb21wb25lbnRcIiwgXCJncm91cENvbXBvbmVudFwiLCBcImNvbnRhaW5lckNvbXBvbmVudFwiLCBcInRpY2tDb21wb25lbnRcIiwgXCJ0aWNrTGFiZWxDb21wb25lbnRcIiwgXCJncmlkQ29tcG9uZW50XCJdO1xuICByZW5kZXJMaW5lKHByb3BzKSB7XG4gICAgY29uc3Qge1xuICAgICAgYXhpc0NvbXBvbmVudFxuICAgIH0gPSBwcm9wcztcbiAgICBjb25zdCBheGlzUHJvcHMgPSB0aGlzLmdldENvbXBvbmVudFByb3BzKGF4aXNDb21wb25lbnQsIFwiYXhpc1wiLCAwKTtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdC5kZWZhdWx0LmNsb25lRWxlbWVudChheGlzQ29tcG9uZW50LCBheGlzUHJvcHMpO1xuICB9XG4gIHJlbmRlckxhYmVsKHByb3BzKSB7XG4gICAgY29uc3Qge1xuICAgICAgYXhpc0xhYmVsQ29tcG9uZW50LFxuICAgICAgbGFiZWxcbiAgICB9ID0gcHJvcHM7XG4gICAgaWYgKCFsYWJlbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGF4aXNMYWJlbFByb3BzID0gdGhpcy5nZXRDb21wb25lbnRQcm9wcyhheGlzTGFiZWxDb21wb25lbnQsIFwiYXhpc0xhYmVsXCIsIDApO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0LmRlZmF1bHQuY2xvbmVFbGVtZW50KGF4aXNMYWJlbENvbXBvbmVudCwgYXhpc0xhYmVsUHJvcHMpO1xuICB9XG4gIHJlbmRlckdyaWRBbmRUaWNrcyhwcm9wcykge1xuICAgIGNvbnN0IHtcbiAgICAgIHRpY2tDb21wb25lbnQsXG4gICAgICB0aWNrTGFiZWxDb21wb25lbnQsXG4gICAgICBncmlkQ29tcG9uZW50LFxuICAgICAgbmFtZVxuICAgIH0gPSBwcm9wcztcbiAgICBjb25zdCBzaG91bGRSZW5kZXIgPSBjb21wb25lbnRQcm9wcyA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHN0eWxlID0ge30sXG4gICAgICAgIGV2ZW50cyA9IHt9XG4gICAgICB9ID0gY29tcG9uZW50UHJvcHM7XG4gICAgICBjb25zdCB2aXNpYmxlID0gc3R5bGUuc3Ryb2tlICE9PSBcInRyYW5zcGFyZW50XCIgJiYgc3R5bGUuc3Ryb2tlICE9PSBcIm5vbmVcIiAmJiBzdHlsZS5zdHJva2VXaWR0aCAhPT0gMDtcbiAgICAgIHJldHVybiB2aXNpYmxlIHx8ICEoMCwgX2lzRW1wdHkyLmRlZmF1bHQpKGV2ZW50cyk7XG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5kYXRhS2V5cy5tYXAoKGtleSwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IHRpY2tQcm9wcyA9IHRoaXMuZ2V0Q29tcG9uZW50UHJvcHModGlja0NvbXBvbmVudCwgXCJ0aWNrc1wiLCBpbmRleCk7XG4gICAgICBjb25zdCBCYXNlVGlja0NvbXBvbmVudCA9IC8qI19fUFVSRV9fKi9fcmVhY3QuZGVmYXVsdC5jbG9uZUVsZW1lbnQodGlja0NvbXBvbmVudCwgdGlja1Byb3BzKTtcbiAgICAgIGNvbnN0IFRpY2tDb21wb25lbnQgPSBzaG91bGRSZW5kZXIoQmFzZVRpY2tDb21wb25lbnQucHJvcHMpID8gQmFzZVRpY2tDb21wb25lbnQgOiB1bmRlZmluZWQ7XG4gICAgICBjb25zdCBncmlkUHJvcHMgPSB0aGlzLmdldENvbXBvbmVudFByb3BzKGdyaWRDb21wb25lbnQsIFwiZ3JpZFwiLCBpbmRleCk7XG4gICAgICBjb25zdCBCYXNlR3JpZENvbXBvbmVudCA9IC8qI19fUFVSRV9fKi9fcmVhY3QuZGVmYXVsdC5jbG9uZUVsZW1lbnQoZ3JpZENvbXBvbmVudCwgZ3JpZFByb3BzKTtcbiAgICAgIGNvbnN0IEdyaWRDb21wb25lbnQgPSBzaG91bGRSZW5kZXIoQmFzZUdyaWRDb21wb25lbnQucHJvcHMpID8gQmFzZUdyaWRDb21wb25lbnQgOiB1bmRlZmluZWQ7XG4gICAgICBjb25zdCB0aWNrTGFiZWxQcm9wcyA9IHRoaXMuZ2V0Q29tcG9uZW50UHJvcHModGlja0xhYmVsQ29tcG9uZW50LCBcInRpY2tMYWJlbHNcIiwgaW5kZXgpO1xuICAgICAgY29uc3QgVGlja0xhYmVsID0gLyojX19QVVJFX18qL19yZWFjdC5kZWZhdWx0LmNsb25lRWxlbWVudCh0aWNrTGFiZWxDb21wb25lbnQsIHRpY2tMYWJlbFByb3BzKTtcbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gW0dyaWRDb21wb25lbnQsIFRpY2tDb21wb25lbnQsIFRpY2tMYWJlbF0uZmlsdGVyKEJvb2xlYW4pO1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3QuZGVmYXVsdC5jbG9uZUVsZW1lbnQocHJvcHMuZ3JvdXBDb21wb25lbnQsIHtcbiAgICAgICAga2V5OiBgJHtuYW1lfS10aWNrLWdyb3VwLSR7a2V5fWBcbiAgICAgIH0sIGNoaWxkcmVuKTtcbiAgICB9KTtcbiAgfVxuICBmaXhMYWJlbE92ZXJsYXAoZ3JpZEFuZFRpY2tzLCBwcm9wcykge1xuICAgIGNvbnN0IGlzVmVydGljYWwgPSBfdmljdG9yeUNvcmUuQXhpcy5pc1ZlcnRpY2FsKHByb3BzKTtcbiAgICBjb25zdCBzaXplID0gaXNWZXJ0aWNhbCA/IHByb3BzLmhlaWdodCA6IHByb3BzLndpZHRoO1xuICAgIGNvbnN0IGlzVmljdG9yeUxhYmVsID0gY2hpbGQgPT4gY2hpbGQudHlwZSAmJiBjaGlsZC50eXBlLnJvbGUgPT09IFwibGFiZWxcIjtcbiAgICBjb25zdCBsYWJlbHMgPSBncmlkQW5kVGlja3MubWFwKGdyaWRBbmRUaWNrID0+IGdyaWRBbmRUaWNrLnByb3BzLmNoaWxkcmVuKS5yZWR1Y2UoKGFjY3VtdWxhdG9yLCBjaGlsZEFycikgPT4gYWNjdW11bGF0b3IuY29uY2F0KGNoaWxkQXJyKSwgW10pLmZpbHRlcihpc1ZpY3RvcnlMYWJlbCkubWFwKGNoaWxkID0+IGNoaWxkLnByb3BzKTtcbiAgICBjb25zdCBwYWRkaW5nVG9PYmplY3QgPSBwYWRkaW5nID0+IHR5cGVvZiBwYWRkaW5nID09PSBcIm9iamVjdFwiID8gT2JqZWN0LmFzc2lnbih7fSwge1xuICAgICAgdG9wOiAwLFxuICAgICAgcmlnaHQ6IDAsXG4gICAgICBib3R0b206IDAsXG4gICAgICBsZWZ0OiAwXG4gICAgfSwgcGFkZGluZykgOiB7XG4gICAgICB0b3A6IHBhZGRpbmcsXG4gICAgICByaWdodDogcGFkZGluZyxcbiAgICAgIGJvdHRvbTogcGFkZGluZyxcbiAgICAgIGxlZnQ6IHBhZGRpbmdcbiAgICB9O1xuICAgIGNvbnN0IGxhYmVsc1N1bVNpemUgPSBsYWJlbHMucmVkdWNlKChzdW0sIGxhYmVsKSA9PiB7XG4gICAgICBjb25zdCBwYWRkaW5nID0gcGFkZGluZ1RvT2JqZWN0KGxhYmVsLnN0eWxlLnBhZGRpbmcpO1xuICAgICAgY29uc3QgbGFiZWxTaXplID0gX3ZpY3RvcnlDb3JlLlRleHRTaXplLmFwcHJveGltYXRlVGV4dFNpemUobGFiZWwudGV4dCwge1xuICAgICAgICBhbmdsZTogbGFiZWwuYW5nbGUsXG4gICAgICAgIGZvbnRTaXplOiBsYWJlbC5zdHlsZS5mb250U2l6ZSxcbiAgICAgICAgbGV0dGVyU3BhY2luZzogbGFiZWwuc3R5bGUubGV0dGVyU3BhY2luZyxcbiAgICAgICAgZm9udEZhbWlseTogbGFiZWwuc3R5bGUuZm9udEZhbWlseVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gc3VtICsgKGlzVmVydGljYWwgPyBsYWJlbFNpemUuaGVpZ2h0ICsgcGFkZGluZy50b3AgKyBwYWRkaW5nLmJvdHRvbSA6IGxhYmVsU2l6ZS53aWR0aCArIHBhZGRpbmcucmlnaHQgKyBwYWRkaW5nLmxlZnQpO1xuICAgIH0sIDApO1xuICAgIGNvbnN0IGF2YWlsaWFibGVMYWJlbENvdW50ID0gTWF0aC5mbG9vcihzaXplICogZ3JpZEFuZFRpY2tzLmxlbmd0aCAvIGxhYmVsc1N1bVNpemUpO1xuICAgIGNvbnN0IGRpdmlkZXIgPSBNYXRoLmNlaWwoZ3JpZEFuZFRpY2tzLmxlbmd0aCAvIGF2YWlsaWFibGVMYWJlbENvdW50KSB8fCAxO1xuICAgIGNvbnN0IGdldExhYmVsQ29vcmQgPSBncmlkQW5kVGljayA9PiBncmlkQW5kVGljay5wcm9wcy5jaGlsZHJlbi5maWx0ZXIoaXNWaWN0b3J5TGFiZWwpLnJlZHVjZSgocHJldiwgY2hpbGQpID0+IChpc1ZlcnRpY2FsID8gY2hpbGQucHJvcHMueSA6IGNoaWxkLnByb3BzLngpIHx8IDAsIDApO1xuICAgIGNvbnN0IHNvcnRlZCA9IGdyaWRBbmRUaWNrcy5zb3J0KChhLCBiKSA9PiBpc1ZlcnRpY2FsID8gZ2V0TGFiZWxDb29yZChiKSAtIGdldExhYmVsQ29vcmQoYSkgLy8gb3JkaW5hcnkgYXhpcyBoYXMgdG9wLWJvdHRvbSBvcmllbnRhdGlvblxuICAgIDogZ2V0TGFiZWxDb29yZChhKSAtIGdldExhYmVsQ29vcmQoYikgLy8gb3JkaW5hcnkgYXhpcyBoYXMgbGVmdC1yaWdodCBvcmllbnRhdGlvblxuICAgICk7XG4gICAgcmV0dXJuIHNvcnRlZC5maWx0ZXIoKGdyaWRBbmRUaWNrLCBpbmRleCkgPT4gaW5kZXggJSBkaXZpZGVyID09PSAwKTtcbiAgfVxuXG4gIC8vIE92ZXJyaWRkZW4gaW4gbmF0aXZlIHZlcnNpb25zXG4gIHNob3VsZEFuaW1hdGUoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5wcm9wcy5hbmltYXRlO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBhbmltYXRpb25XaGl0ZWxpc3RcbiAgICB9ID0gVmljdG9yeUF4aXM7XG4gICAgY29uc3QgcHJvcHMgPSBfdmljdG9yeUNvcmUuQXhpcy5tb2RpZnlQcm9wcyh0aGlzLnByb3BzLCBmYWxsYmFja1Byb3BzKTtcbiAgICBjb25zdCB1c2VyUHJvcHMgPSBfdmljdG9yeUNvcmUuVXNlclByb3BzLmdldFNhZmVVc2VyUHJvcHModGhpcy5wcm9wcyk7XG4gICAgaWYgKHRoaXMuc2hvdWxkQW5pbWF0ZSgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5hbmltYXRlQ29tcG9uZW50KHByb3BzLCBhbmltYXRpb25XaGl0ZWxpc3QpO1xuICAgIH1cbiAgICBjb25zdCBncmlkQW5kVGlja3MgPSB0aGlzLnJlbmRlckdyaWRBbmRUaWNrcyhwcm9wcyk7XG4gICAgY29uc3QgbW9kaWZpZWRHcmlkQW5kVGlja3MgPSBwcm9wcy5maXhMYWJlbE92ZXJsYXAgPyB0aGlzLmZpeExhYmVsT3ZlcmxhcChncmlkQW5kVGlja3MsIHByb3BzKSA6IGdyaWRBbmRUaWNrcztcbiAgICBjb25zdCBjaGlsZHJlbiA9IFt0aGlzLnJlbmRlckxpbmUocHJvcHMpLCB0aGlzLnJlbmRlckxhYmVsKHByb3BzKSwgLi4ubW9kaWZpZWRHcmlkQW5kVGlja3NdO1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IC8qI19fUFVSRV9fKi9fcmVhY3QuZGVmYXVsdC5jbG9uZUVsZW1lbnQocHJvcHMuY29udGFpbmVyQ29tcG9uZW50LCB1c2VyUHJvcHMpO1xuICAgIHJldHVybiBwcm9wcy5zdGFuZGFsb25lID8gdGhpcy5yZW5kZXJDb250YWluZXIoY29udGFpbmVyLCBjaGlsZHJlbikgOiAvKiNfX1BVUkVfXyovX3JlYWN0LmRlZmF1bHQuY2xvbmVFbGVtZW50KHByb3BzLmdyb3VwQ29tcG9uZW50LCB1c2VyUHJvcHMsIGNoaWxkcmVuKTtcbiAgfVxufVxuY29uc3QgVmljdG9yeUF4aXMgPSBleHBvcnRzLlZpY3RvcnlBeGlzID0gKDAsIF92aWN0b3J5Q29yZS5hZGRFdmVudHMpKFZpY3RvcnlBeGlzQmFzZSwgb3B0aW9ucyk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/victory-axis/lib/victory-axis.js\n");

/***/ })

};
;