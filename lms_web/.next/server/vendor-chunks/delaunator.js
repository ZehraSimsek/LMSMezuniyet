/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/delaunator";
exports.ids = ["vendor-chunks/delaunator"];
exports.modules = {

/***/ "(ssr)/./node_modules/delaunator/delaunator.js":
/*!***********************************************!*\
  !*** ./node_modules/delaunator/delaunator.js ***!
  \***********************************************/
/***/ (function(module) {

eval("(function (global, factory) {\n     true ? module.exports = factory() :\n    0;\n}(this, function () { 'use strict';\n\n    var EPSILON = Math.pow(2, -52);\n    var EDGE_STACK = new Uint32Array(512);\n\n    var Delaunator = function Delaunator(coords) {\n        var n = coords.length >> 1;\n        if (n > 0 && typeof coords[0] !== 'number') { throw new Error('Expected coords to contain numbers.'); }\n\n        this.coords = coords;\n\n        // arrays that will store the triangulation graph\n        var maxTriangles = Math.max(2 * n - 5, 0);\n        this._triangles = new Uint32Array(maxTriangles * 3);\n        this._halfedges = new Int32Array(maxTriangles * 3);\n\n        // temporary arrays for tracking the edges of the advancing convex hull\n        this._hashSize = Math.ceil(Math.sqrt(n));\n        this._hullPrev = new Uint32Array(n); // edge to prev edge\n        this._hullNext = new Uint32Array(n); // edge to next edge\n        this._hullTri = new Uint32Array(n); // edge to adjacent triangle\n        this._hullHash = new Int32Array(this._hashSize).fill(-1); // angular edge hash\n\n        // temporary arrays for sorting points\n        this._ids = new Uint32Array(n);\n        this._dists = new Float64Array(n);\n\n        this.update();\n    };\n\n    Delaunator.from = function from (points, getX, getY) {\n            if ( getX === void 0 ) getX = defaultGetX;\n            if ( getY === void 0 ) getY = defaultGetY;\n\n        var n = points.length;\n        var coords = new Float64Array(n * 2);\n\n        for (var i = 0; i < n; i++) {\n            var p = points[i];\n            coords[2 * i] = getX(p);\n            coords[2 * i + 1] = getY(p);\n        }\n\n        return new Delaunator(coords);\n    };\n\n    Delaunator.prototype.update = function update () {\n        var ref =  this;\n            var coords = ref.coords;\n            var hullPrev = ref._hullPrev;\n            var hullNext = ref._hullNext;\n            var hullTri = ref._hullTri;\n            var hullHash = ref._hullHash;\n        var n = coords.length >> 1;\n\n        // populate an array of point indices; calculate input data bbox\n        var minX = Infinity;\n        var minY = Infinity;\n        var maxX = -Infinity;\n        var maxY = -Infinity;\n\n        for (var i = 0; i < n; i++) {\n            var x = coords[2 * i];\n            var y = coords[2 * i + 1];\n            if (x < minX) { minX = x; }\n            if (y < minY) { minY = y; }\n            if (x > maxX) { maxX = x; }\n            if (y > maxY) { maxY = y; }\n            this._ids[i] = i;\n        }\n        var cx = (minX + maxX) / 2;\n        var cy = (minY + maxY) / 2;\n\n        var minDist = Infinity;\n        var i0, i1, i2;\n\n        // pick a seed point close to the center\n        for (var i$1 = 0; i$1 < n; i$1++) {\n            var d = dist(cx, cy, coords[2 * i$1], coords[2 * i$1 + 1]);\n            if (d < minDist) {\n                i0 = i$1;\n                minDist = d;\n            }\n        }\n        var i0x = coords[2 * i0];\n        var i0y = coords[2 * i0 + 1];\n\n        minDist = Infinity;\n\n        // find the point closest to the seed\n        for (var i$2 = 0; i$2 < n; i$2++) {\n            if (i$2 === i0) { continue; }\n            var d$1 = dist(i0x, i0y, coords[2 * i$2], coords[2 * i$2 + 1]);\n            if (d$1 < minDist && d$1 > 0) {\n                i1 = i$2;\n                minDist = d$1;\n            }\n        }\n        var i1x = coords[2 * i1];\n        var i1y = coords[2 * i1 + 1];\n\n        var minRadius = Infinity;\n\n        // find the third point which forms the smallest circumcircle with the first two\n        for (var i$3 = 0; i$3 < n; i$3++) {\n            if (i$3 === i0 || i$3 === i1) { continue; }\n            var r = circumradius(i0x, i0y, i1x, i1y, coords[2 * i$3], coords[2 * i$3 + 1]);\n            if (r < minRadius) {\n                i2 = i$3;\n                minRadius = r;\n            }\n        }\n        var i2x = coords[2 * i2];\n        var i2y = coords[2 * i2 + 1];\n\n        if (minRadius === Infinity) {\n            // order collinear points by dx (or dy if all x are identical)\n            // and return the list as a hull\n            for (var i$4 = 0; i$4 < n; i$4++) {\n                this._dists[i$4] = (coords[2 * i$4] - coords[0]) || (coords[2 * i$4 + 1] - coords[1]);\n            }\n            quicksort(this._ids, this._dists, 0, n - 1);\n            var hull = new Uint32Array(n);\n            var j = 0;\n            for (var i$5 = 0, d0 = -Infinity; i$5 < n; i$5++) {\n                var id = this._ids[i$5];\n                if (this._dists[id] > d0) {\n                    hull[j++] = id;\n                    d0 = this._dists[id];\n                }\n            }\n            this.hull = hull.subarray(0, j);\n            this.triangles = new Uint32Array(0);\n            this.halfedges = new Uint32Array(0);\n            return;\n        }\n\n        // swap the order of the seed points for counter-clockwise orientation\n        if (orient(i0x, i0y, i1x, i1y, i2x, i2y)) {\n            var i$6 = i1;\n            var x$1 = i1x;\n            var y$1 = i1y;\n            i1 = i2;\n            i1x = i2x;\n            i1y = i2y;\n            i2 = i$6;\n            i2x = x$1;\n            i2y = y$1;\n        }\n\n        var center = circumcenter(i0x, i0y, i1x, i1y, i2x, i2y);\n        this._cx = center.x;\n        this._cy = center.y;\n\n        for (var i$7 = 0; i$7 < n; i$7++) {\n            this._dists[i$7] = dist(coords[2 * i$7], coords[2 * i$7 + 1], center.x, center.y);\n        }\n\n        // sort the points by distance from the seed triangle circumcenter\n        quicksort(this._ids, this._dists, 0, n - 1);\n\n        // set up the seed triangle as the starting hull\n        this._hullStart = i0;\n        var hullSize = 3;\n\n        hullNext[i0] = hullPrev[i2] = i1;\n        hullNext[i1] = hullPrev[i0] = i2;\n        hullNext[i2] = hullPrev[i1] = i0;\n\n        hullTri[i0] = 0;\n        hullTri[i1] = 1;\n        hullTri[i2] = 2;\n\n        hullHash.fill(-1);\n        hullHash[this._hashKey(i0x, i0y)] = i0;\n        hullHash[this._hashKey(i1x, i1y)] = i1;\n        hullHash[this._hashKey(i2x, i2y)] = i2;\n\n        this.trianglesLen = 0;\n        this._addTriangle(i0, i1, i2, -1, -1, -1);\n\n        for (var k = 0, xp = (void 0), yp = (void 0); k < this._ids.length; k++) {\n            var i$8 = this._ids[k];\n            var x$2 = coords[2 * i$8];\n            var y$2 = coords[2 * i$8 + 1];\n\n            // skip near-duplicate points\n            if (k > 0 && Math.abs(x$2 - xp) <= EPSILON && Math.abs(y$2 - yp) <= EPSILON) { continue; }\n            xp = x$2;\n            yp = y$2;\n\n            // skip seed triangle points\n            if (i$8 === i0 || i$8 === i1 || i$8 === i2) { continue; }\n\n            // find a visible edge on the convex hull using edge hash\n            var start = 0;\n            for (var j$1 = 0, key = this._hashKey(x$2, y$2); j$1 < this._hashSize; j$1++) {\n                start = hullHash[(key + j$1) % this._hashSize];\n                if (start !== -1 && start !== hullNext[start]) { break; }\n            }\n\n            start = hullPrev[start];\n            var e = start, q = (void 0);\n            while (q = hullNext[e], !orient(x$2, y$2, coords[2 * e], coords[2 * e + 1], coords[2 * q], coords[2 * q + 1])) {\n                e = q;\n                if (e === start) {\n                    e = -1;\n                    break;\n                }\n            }\n            if (e === -1) { continue; } // likely a near-duplicate point; skip it\n\n            // add the first triangle from the point\n            var t = this._addTriangle(e, i$8, hullNext[e], -1, -1, hullTri[e]);\n\n            // recursively flip triangles from the point until they satisfy the Delaunay condition\n            hullTri[i$8] = this._legalize(t + 2);\n            hullTri[e] = t; // keep track of boundary triangles on the hull\n            hullSize++;\n\n            // walk forward through the hull, adding more triangles and flipping recursively\n            var n$1 = hullNext[e];\n            while (q = hullNext[n$1], orient(x$2, y$2, coords[2 * n$1], coords[2 * n$1 + 1], coords[2 * q], coords[2 * q + 1])) {\n                t = this._addTriangle(n$1, i$8, q, hullTri[i$8], -1, hullTri[n$1]);\n                hullTri[i$8] = this._legalize(t + 2);\n                hullNext[n$1] = n$1; // mark as removed\n                hullSize--;\n                n$1 = q;\n            }\n\n            // walk backward from the other side, adding more triangles and flipping\n            if (e === start) {\n                while (q = hullPrev[e], orient(x$2, y$2, coords[2 * q], coords[2 * q + 1], coords[2 * e], coords[2 * e + 1])) {\n                    t = this._addTriangle(q, i$8, e, -1, hullTri[e], hullTri[q]);\n                    this._legalize(t + 2);\n                    hullTri[q] = t;\n                    hullNext[e] = e; // mark as removed\n                    hullSize--;\n                    e = q;\n                }\n            }\n\n            // update the hull indices\n            this._hullStart = hullPrev[i$8] = e;\n            hullNext[e] = hullPrev[n$1] = i$8;\n            hullNext[i$8] = n$1;\n\n            // save the two new edges in the hash table\n            hullHash[this._hashKey(x$2, y$2)] = i$8;\n            hullHash[this._hashKey(coords[2 * e], coords[2 * e + 1])] = e;\n        }\n\n        this.hull = new Uint32Array(hullSize);\n        for (var i$9 = 0, e$1 = this._hullStart; i$9 < hullSize; i$9++) {\n            this.hull[i$9] = e$1;\n            e$1 = hullNext[e$1];\n        }\n\n        // trim typed triangle mesh arrays\n        this.triangles = this._triangles.subarray(0, this.trianglesLen);\n        this.halfedges = this._halfedges.subarray(0, this.trianglesLen);\n    };\n\n    Delaunator.prototype._hashKey = function _hashKey (x, y) {\n        return Math.floor(pseudoAngle(x - this._cx, y - this._cy) * this._hashSize) % this._hashSize;\n    };\n\n    Delaunator.prototype._legalize = function _legalize (a) {\n        var ref = this;\n            var triangles = ref._triangles;\n            var halfedges = ref._halfedges;\n            var coords = ref.coords;\n\n        var i = 0;\n        var ar = 0;\n\n        // recursion eliminated with a fixed-size stack\n        while (true) {\n            var b = halfedges[a];\n\n            /* if the pair of triangles doesn't satisfy the Delaunay condition\n             * (p1 is inside the circumcircle of [p0, pl, pr]), flip them,\n             * then do the same check/flip recursively for the new pair of triangles\n             *\n             *       pl                pl\n             *      /||\\              /  \\\n             *   al/ || \\bl        al/\\a\n             *    /  ||  \\          /  \\\n             *   /  a||b  \\flip/___ar___\\\n             * p0\\   ||   /p1   =>   p0\\---bl---/p1\n             *    \\  ||  /          \\  /\n             *   ar\\ || /br         b\\/br\n             *      \\||/              \\  /\n             *       pr                pr\n             */\n            var a0 = a - a % 3;\n            ar = a0 + (a + 2) % 3;\n\n            if (b === -1) { // convex hull edge\n                if (i === 0) { break; }\n                a = EDGE_STACK[--i];\n                continue;\n            }\n\n            var b0 = b - b % 3;\n            var al = a0 + (a + 1) % 3;\n            var bl = b0 + (b + 2) % 3;\n\n            var p0 = triangles[ar];\n            var pr = triangles[a];\n            var pl = triangles[al];\n            var p1 = triangles[bl];\n\n            var illegal = inCircle(\n                coords[2 * p0], coords[2 * p0 + 1],\n                coords[2 * pr], coords[2 * pr + 1],\n                coords[2 * pl], coords[2 * pl + 1],\n                coords[2 * p1], coords[2 * p1 + 1]);\n\n            if (illegal) {\n                triangles[a] = p1;\n                triangles[b] = p0;\n\n                var hbl = halfedges[bl];\n\n                // edge swapped on the other side of the hull (rare); fix the halfedge reference\n                if (hbl === -1) {\n                    var e = this._hullStart;\n                    do {\n                        if (this._hullTri[e] === bl) {\n                            this._hullTri[e] = a;\n                            break;\n                        }\n                        e = this._hullPrev[e];\n                    } while (e !== this._hullStart);\n                }\n                this._link(a, hbl);\n                this._link(b, halfedges[ar]);\n                this._link(ar, bl);\n\n                var br = b0 + (b + 1) % 3;\n\n                // don't worry about hitting the cap: it can only happen on extremely degenerate input\n                if (i < EDGE_STACK.length) {\n                    EDGE_STACK[i++] = br;\n                }\n            } else {\n                if (i === 0) { break; }\n                a = EDGE_STACK[--i];\n            }\n        }\n\n        return ar;\n    };\n\n    Delaunator.prototype._link = function _link (a, b) {\n        this._halfedges[a] = b;\n        if (b !== -1) { this._halfedges[b] = a; }\n    };\n\n    // add a new triangle given vertex indices and adjacent half-edge ids\n    Delaunator.prototype._addTriangle = function _addTriangle (i0, i1, i2, a, b, c) {\n        var t = this.trianglesLen;\n\n        this._triangles[t] = i0;\n        this._triangles[t + 1] = i1;\n        this._triangles[t + 2] = i2;\n\n        this._link(t, a);\n        this._link(t + 1, b);\n        this._link(t + 2, c);\n\n        this.trianglesLen += 3;\n\n        return t;\n    };\n\n    // monotonically increases with real angle, but doesn't need expensive trigonometry\n    function pseudoAngle(dx, dy) {\n        var p = dx / (Math.abs(dx) + Math.abs(dy));\n        return (dy > 0 ? 3 - p : 1 + p) / 4; // [0..1]\n    }\n\n    function dist(ax, ay, bx, by) {\n        var dx = ax - bx;\n        var dy = ay - by;\n        return dx * dx + dy * dy;\n    }\n\n    // return 2d orientation sign if we're confident in it through J. Shewchuk's error bound check\n    function orientIfSure(px, py, rx, ry, qx, qy) {\n        var l = (ry - py) * (qx - px);\n        var r = (rx - px) * (qy - py);\n        return Math.abs(l - r) >= 3.3306690738754716e-16 * Math.abs(l + r) ? l - r : 0;\n    }\n\n    // a more robust orientation test that's stable in a given triangle (to fix robustness issues)\n    function orient(rx, ry, qx, qy, px, py) {\n        var sign = orientIfSure(px, py, rx, ry, qx, qy) ||\n        orientIfSure(rx, ry, qx, qy, px, py) ||\n        orientIfSure(qx, qy, px, py, rx, ry);\n        return sign < 0;\n    }\n\n    function inCircle(ax, ay, bx, by, cx, cy, px, py) {\n        var dx = ax - px;\n        var dy = ay - py;\n        var ex = bx - px;\n        var ey = by - py;\n        var fx = cx - px;\n        var fy = cy - py;\n\n        var ap = dx * dx + dy * dy;\n        var bp = ex * ex + ey * ey;\n        var cp = fx * fx + fy * fy;\n\n        return dx * (ey * cp - bp * fy) -\n               dy * (ex * cp - bp * fx) +\n               ap * (ex * fy - ey * fx) < 0;\n    }\n\n    function circumradius(ax, ay, bx, by, cx, cy) {\n        var dx = bx - ax;\n        var dy = by - ay;\n        var ex = cx - ax;\n        var ey = cy - ay;\n\n        var bl = dx * dx + dy * dy;\n        var cl = ex * ex + ey * ey;\n        var d = 0.5 / (dx * ey - dy * ex);\n\n        var x = (ey * bl - dy * cl) * d;\n        var y = (dx * cl - ex * bl) * d;\n\n        return x * x + y * y;\n    }\n\n    function circumcenter(ax, ay, bx, by, cx, cy) {\n        var dx = bx - ax;\n        var dy = by - ay;\n        var ex = cx - ax;\n        var ey = cy - ay;\n\n        var bl = dx * dx + dy * dy;\n        var cl = ex * ex + ey * ey;\n        var d = 0.5 / (dx * ey - dy * ex);\n\n        var x = ax + (ey * bl - dy * cl) * d;\n        var y = ay + (dx * cl - ex * bl) * d;\n\n        return {x: x, y: y};\n    }\n\n    function quicksort(ids, dists, left, right) {\n        if (right - left <= 20) {\n            for (var i = left + 1; i <= right; i++) {\n                var temp = ids[i];\n                var tempDist = dists[temp];\n                var j = i - 1;\n                while (j >= left && dists[ids[j]] > tempDist) { ids[j + 1] = ids[j--]; }\n                ids[j + 1] = temp;\n            }\n        } else {\n            var median = (left + right) >> 1;\n            var i$1 = left + 1;\n            var j$1 = right;\n            swap(ids, median, i$1);\n            if (dists[ids[left]] > dists[ids[right]]) { swap(ids, left, right); }\n            if (dists[ids[i$1]] > dists[ids[right]]) { swap(ids, i$1, right); }\n            if (dists[ids[left]] > dists[ids[i$1]]) { swap(ids, left, i$1); }\n\n            var temp$1 = ids[i$1];\n            var tempDist$1 = dists[temp$1];\n            while (true) {\n                do { i$1++; } while (dists[ids[i$1]] < tempDist$1);\n                do { j$1--; } while (dists[ids[j$1]] > tempDist$1);\n                if (j$1 < i$1) { break; }\n                swap(ids, i$1, j$1);\n            }\n            ids[left + 1] = ids[j$1];\n            ids[j$1] = temp$1;\n\n            if (right - i$1 + 1 >= j$1 - left) {\n                quicksort(ids, dists, i$1, right);\n                quicksort(ids, dists, left, j$1 - 1);\n            } else {\n                quicksort(ids, dists, left, j$1 - 1);\n                quicksort(ids, dists, i$1, right);\n            }\n        }\n    }\n\n    function swap(arr, i, j) {\n        var tmp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = tmp;\n    }\n\n    function defaultGetX(p) {\n        return p[0];\n    }\n    function defaultGetY(p) {\n        return p[1];\n    }\n\n    return Delaunator;\n\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZGVsYXVuYXRvci9kZWxhdW5hdG9yLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsSUFBSSxLQUE0RDtBQUNoRSxJQUFJLENBQ3dEO0FBQzVELENBQUMscUJBQXFCOztBQUV0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzREFBc0Q7O0FBRXREOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0MsNkNBQTZDO0FBQzdDLDRDQUE0QztBQUM1QyxrRUFBa0U7O0FBRWxFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBLDRCQUE0QjtBQUM1Qiw0QkFBNEI7QUFDNUIsNEJBQTRCO0FBQzVCLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCLFNBQVM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDBCQUEwQixTQUFTO0FBQ25DLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsMEJBQTBCLFNBQVM7QUFDbkMsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFNBQVM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxTQUFTO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Y0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3RlbXAvLi9ub2RlX21vZHVsZXMvZGVsYXVuYXRvci9kZWxhdW5hdG9yLmpzPzVkYTkiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG4gICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcbiAgICAoZ2xvYmFsID0gZ2xvYmFsIHx8IHNlbGYsIGdsb2JhbC5EZWxhdW5hdG9yID0gZmFjdG9yeSgpKTtcbn0odGhpcywgZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgRVBTSUxPTiA9IE1hdGgucG93KDIsIC01Mik7XG4gICAgdmFyIEVER0VfU1RBQ0sgPSBuZXcgVWludDMyQXJyYXkoNTEyKTtcblxuICAgIHZhciBEZWxhdW5hdG9yID0gZnVuY3Rpb24gRGVsYXVuYXRvcihjb29yZHMpIHtcbiAgICAgICAgdmFyIG4gPSBjb29yZHMubGVuZ3RoID4+IDE7XG4gICAgICAgIGlmIChuID4gMCAmJiB0eXBlb2YgY29vcmRzWzBdICE9PSAnbnVtYmVyJykgeyB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGNvb3JkcyB0byBjb250YWluIG51bWJlcnMuJyk7IH1cblxuICAgICAgICB0aGlzLmNvb3JkcyA9IGNvb3JkcztcblxuICAgICAgICAvLyBhcnJheXMgdGhhdCB3aWxsIHN0b3JlIHRoZSB0cmlhbmd1bGF0aW9uIGdyYXBoXG4gICAgICAgIHZhciBtYXhUcmlhbmdsZXMgPSBNYXRoLm1heCgyICogbiAtIDUsIDApO1xuICAgICAgICB0aGlzLl90cmlhbmdsZXMgPSBuZXcgVWludDMyQXJyYXkobWF4VHJpYW5nbGVzICogMyk7XG4gICAgICAgIHRoaXMuX2hhbGZlZGdlcyA9IG5ldyBJbnQzMkFycmF5KG1heFRyaWFuZ2xlcyAqIDMpO1xuXG4gICAgICAgIC8vIHRlbXBvcmFyeSBhcnJheXMgZm9yIHRyYWNraW5nIHRoZSBlZGdlcyBvZiB0aGUgYWR2YW5jaW5nIGNvbnZleCBodWxsXG4gICAgICAgIHRoaXMuX2hhc2hTaXplID0gTWF0aC5jZWlsKE1hdGguc3FydChuKSk7XG4gICAgICAgIHRoaXMuX2h1bGxQcmV2ID0gbmV3IFVpbnQzMkFycmF5KG4pOyAvLyBlZGdlIHRvIHByZXYgZWRnZVxuICAgICAgICB0aGlzLl9odWxsTmV4dCA9IG5ldyBVaW50MzJBcnJheShuKTsgLy8gZWRnZSB0byBuZXh0IGVkZ2VcbiAgICAgICAgdGhpcy5faHVsbFRyaSA9IG5ldyBVaW50MzJBcnJheShuKTsgLy8gZWRnZSB0byBhZGphY2VudCB0cmlhbmdsZVxuICAgICAgICB0aGlzLl9odWxsSGFzaCA9IG5ldyBJbnQzMkFycmF5KHRoaXMuX2hhc2hTaXplKS5maWxsKC0xKTsgLy8gYW5ndWxhciBlZGdlIGhhc2hcblxuICAgICAgICAvLyB0ZW1wb3JhcnkgYXJyYXlzIGZvciBzb3J0aW5nIHBvaW50c1xuICAgICAgICB0aGlzLl9pZHMgPSBuZXcgVWludDMyQXJyYXkobik7XG4gICAgICAgIHRoaXMuX2Rpc3RzID0gbmV3IEZsb2F0NjRBcnJheShuKTtcblxuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH07XG5cbiAgICBEZWxhdW5hdG9yLmZyb20gPSBmdW5jdGlvbiBmcm9tIChwb2ludHMsIGdldFgsIGdldFkpIHtcbiAgICAgICAgICAgIGlmICggZ2V0WCA9PT0gdm9pZCAwICkgZ2V0WCA9IGRlZmF1bHRHZXRYO1xuICAgICAgICAgICAgaWYgKCBnZXRZID09PSB2b2lkIDAgKSBnZXRZID0gZGVmYXVsdEdldFk7XG5cbiAgICAgICAgdmFyIG4gPSBwb2ludHMubGVuZ3RoO1xuICAgICAgICB2YXIgY29vcmRzID0gbmV3IEZsb2F0NjRBcnJheShuICogMik7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwID0gcG9pbnRzW2ldO1xuICAgICAgICAgICAgY29vcmRzWzIgKiBpXSA9IGdldFgocCk7XG4gICAgICAgICAgICBjb29yZHNbMiAqIGkgKyAxXSA9IGdldFkocCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IERlbGF1bmF0b3IoY29vcmRzKTtcbiAgICB9O1xuXG4gICAgRGVsYXVuYXRvci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlICgpIHtcbiAgICAgICAgdmFyIHJlZiA9ICB0aGlzO1xuICAgICAgICAgICAgdmFyIGNvb3JkcyA9IHJlZi5jb29yZHM7XG4gICAgICAgICAgICB2YXIgaHVsbFByZXYgPSByZWYuX2h1bGxQcmV2O1xuICAgICAgICAgICAgdmFyIGh1bGxOZXh0ID0gcmVmLl9odWxsTmV4dDtcbiAgICAgICAgICAgIHZhciBodWxsVHJpID0gcmVmLl9odWxsVHJpO1xuICAgICAgICAgICAgdmFyIGh1bGxIYXNoID0gcmVmLl9odWxsSGFzaDtcbiAgICAgICAgdmFyIG4gPSBjb29yZHMubGVuZ3RoID4+IDE7XG5cbiAgICAgICAgLy8gcG9wdWxhdGUgYW4gYXJyYXkgb2YgcG9pbnQgaW5kaWNlczsgY2FsY3VsYXRlIGlucHV0IGRhdGEgYmJveFxuICAgICAgICB2YXIgbWluWCA9IEluZmluaXR5O1xuICAgICAgICB2YXIgbWluWSA9IEluZmluaXR5O1xuICAgICAgICB2YXIgbWF4WCA9IC1JbmZpbml0eTtcbiAgICAgICAgdmFyIG1heFkgPSAtSW5maW5pdHk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB4ID0gY29vcmRzWzIgKiBpXTtcbiAgICAgICAgICAgIHZhciB5ID0gY29vcmRzWzIgKiBpICsgMV07XG4gICAgICAgICAgICBpZiAoeCA8IG1pblgpIHsgbWluWCA9IHg7IH1cbiAgICAgICAgICAgIGlmICh5IDwgbWluWSkgeyBtaW5ZID0geTsgfVxuICAgICAgICAgICAgaWYgKHggPiBtYXhYKSB7IG1heFggPSB4OyB9XG4gICAgICAgICAgICBpZiAoeSA+IG1heFkpIHsgbWF4WSA9IHk7IH1cbiAgICAgICAgICAgIHRoaXMuX2lkc1tpXSA9IGk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGN4ID0gKG1pblggKyBtYXhYKSAvIDI7XG4gICAgICAgIHZhciBjeSA9IChtaW5ZICsgbWF4WSkgLyAyO1xuXG4gICAgICAgIHZhciBtaW5EaXN0ID0gSW5maW5pdHk7XG4gICAgICAgIHZhciBpMCwgaTEsIGkyO1xuXG4gICAgICAgIC8vIHBpY2sgYSBzZWVkIHBvaW50IGNsb3NlIHRvIHRoZSBjZW50ZXJcbiAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgbjsgaSQxKyspIHtcbiAgICAgICAgICAgIHZhciBkID0gZGlzdChjeCwgY3ksIGNvb3Jkc1syICogaSQxXSwgY29vcmRzWzIgKiBpJDEgKyAxXSk7XG4gICAgICAgICAgICBpZiAoZCA8IG1pbkRpc3QpIHtcbiAgICAgICAgICAgICAgICBpMCA9IGkkMTtcbiAgICAgICAgICAgICAgICBtaW5EaXN0ID0gZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgaTB4ID0gY29vcmRzWzIgKiBpMF07XG4gICAgICAgIHZhciBpMHkgPSBjb29yZHNbMiAqIGkwICsgMV07XG5cbiAgICAgICAgbWluRGlzdCA9IEluZmluaXR5O1xuXG4gICAgICAgIC8vIGZpbmQgdGhlIHBvaW50IGNsb3Nlc3QgdG8gdGhlIHNlZWRcbiAgICAgICAgZm9yICh2YXIgaSQyID0gMDsgaSQyIDwgbjsgaSQyKyspIHtcbiAgICAgICAgICAgIGlmIChpJDIgPT09IGkwKSB7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICB2YXIgZCQxID0gZGlzdChpMHgsIGkweSwgY29vcmRzWzIgKiBpJDJdLCBjb29yZHNbMiAqIGkkMiArIDFdKTtcbiAgICAgICAgICAgIGlmIChkJDEgPCBtaW5EaXN0ICYmIGQkMSA+IDApIHtcbiAgICAgICAgICAgICAgICBpMSA9IGkkMjtcbiAgICAgICAgICAgICAgICBtaW5EaXN0ID0gZCQxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBpMXggPSBjb29yZHNbMiAqIGkxXTtcbiAgICAgICAgdmFyIGkxeSA9IGNvb3Jkc1syICogaTEgKyAxXTtcblxuICAgICAgICB2YXIgbWluUmFkaXVzID0gSW5maW5pdHk7XG5cbiAgICAgICAgLy8gZmluZCB0aGUgdGhpcmQgcG9pbnQgd2hpY2ggZm9ybXMgdGhlIHNtYWxsZXN0IGNpcmN1bWNpcmNsZSB3aXRoIHRoZSBmaXJzdCB0d29cbiAgICAgICAgZm9yICh2YXIgaSQzID0gMDsgaSQzIDwgbjsgaSQzKyspIHtcbiAgICAgICAgICAgIGlmIChpJDMgPT09IGkwIHx8IGkkMyA9PT0gaTEpIHsgY29udGludWU7IH1cbiAgICAgICAgICAgIHZhciByID0gY2lyY3VtcmFkaXVzKGkweCwgaTB5LCBpMXgsIGkxeSwgY29vcmRzWzIgKiBpJDNdLCBjb29yZHNbMiAqIGkkMyArIDFdKTtcbiAgICAgICAgICAgIGlmIChyIDwgbWluUmFkaXVzKSB7XG4gICAgICAgICAgICAgICAgaTIgPSBpJDM7XG4gICAgICAgICAgICAgICAgbWluUmFkaXVzID0gcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgaTJ4ID0gY29vcmRzWzIgKiBpMl07XG4gICAgICAgIHZhciBpMnkgPSBjb29yZHNbMiAqIGkyICsgMV07XG5cbiAgICAgICAgaWYgKG1pblJhZGl1cyA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICAgIC8vIG9yZGVyIGNvbGxpbmVhciBwb2ludHMgYnkgZHggKG9yIGR5IGlmIGFsbCB4IGFyZSBpZGVudGljYWwpXG4gICAgICAgICAgICAvLyBhbmQgcmV0dXJuIHRoZSBsaXN0IGFzIGEgaHVsbFxuICAgICAgICAgICAgZm9yICh2YXIgaSQ0ID0gMDsgaSQ0IDwgbjsgaSQ0KyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kaXN0c1tpJDRdID0gKGNvb3Jkc1syICogaSQ0XSAtIGNvb3Jkc1swXSkgfHwgKGNvb3Jkc1syICogaSQ0ICsgMV0gLSBjb29yZHNbMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcXVpY2tzb3J0KHRoaXMuX2lkcywgdGhpcy5fZGlzdHMsIDAsIG4gLSAxKTtcbiAgICAgICAgICAgIHZhciBodWxsID0gbmV3IFVpbnQzMkFycmF5KG4pO1xuICAgICAgICAgICAgdmFyIGogPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgaSQ1ID0gMCwgZDAgPSAtSW5maW5pdHk7IGkkNSA8IG47IGkkNSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlkID0gdGhpcy5faWRzW2kkNV07XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2Rpc3RzW2lkXSA+IGQwKSB7XG4gICAgICAgICAgICAgICAgICAgIGh1bGxbaisrXSA9IGlkO1xuICAgICAgICAgICAgICAgICAgICBkMCA9IHRoaXMuX2Rpc3RzW2lkXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmh1bGwgPSBodWxsLnN1YmFycmF5KDAsIGopO1xuICAgICAgICAgICAgdGhpcy50cmlhbmdsZXMgPSBuZXcgVWludDMyQXJyYXkoMCk7XG4gICAgICAgICAgICB0aGlzLmhhbGZlZGdlcyA9IG5ldyBVaW50MzJBcnJheSgwKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHN3YXAgdGhlIG9yZGVyIG9mIHRoZSBzZWVkIHBvaW50cyBmb3IgY291bnRlci1jbG9ja3dpc2Ugb3JpZW50YXRpb25cbiAgICAgICAgaWYgKG9yaWVudChpMHgsIGkweSwgaTF4LCBpMXksIGkyeCwgaTJ5KSkge1xuICAgICAgICAgICAgdmFyIGkkNiA9IGkxO1xuICAgICAgICAgICAgdmFyIHgkMSA9IGkxeDtcbiAgICAgICAgICAgIHZhciB5JDEgPSBpMXk7XG4gICAgICAgICAgICBpMSA9IGkyO1xuICAgICAgICAgICAgaTF4ID0gaTJ4O1xuICAgICAgICAgICAgaTF5ID0gaTJ5O1xuICAgICAgICAgICAgaTIgPSBpJDY7XG4gICAgICAgICAgICBpMnggPSB4JDE7XG4gICAgICAgICAgICBpMnkgPSB5JDE7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2VudGVyID0gY2lyY3VtY2VudGVyKGkweCwgaTB5LCBpMXgsIGkxeSwgaTJ4LCBpMnkpO1xuICAgICAgICB0aGlzLl9jeCA9IGNlbnRlci54O1xuICAgICAgICB0aGlzLl9jeSA9IGNlbnRlci55O1xuXG4gICAgICAgIGZvciAodmFyIGkkNyA9IDA7IGkkNyA8IG47IGkkNysrKSB7XG4gICAgICAgICAgICB0aGlzLl9kaXN0c1tpJDddID0gZGlzdChjb29yZHNbMiAqIGkkN10sIGNvb3Jkc1syICogaSQ3ICsgMV0sIGNlbnRlci54LCBjZW50ZXIueSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzb3J0IHRoZSBwb2ludHMgYnkgZGlzdGFuY2UgZnJvbSB0aGUgc2VlZCB0cmlhbmdsZSBjaXJjdW1jZW50ZXJcbiAgICAgICAgcXVpY2tzb3J0KHRoaXMuX2lkcywgdGhpcy5fZGlzdHMsIDAsIG4gLSAxKTtcblxuICAgICAgICAvLyBzZXQgdXAgdGhlIHNlZWQgdHJpYW5nbGUgYXMgdGhlIHN0YXJ0aW5nIGh1bGxcbiAgICAgICAgdGhpcy5faHVsbFN0YXJ0ID0gaTA7XG4gICAgICAgIHZhciBodWxsU2l6ZSA9IDM7XG5cbiAgICAgICAgaHVsbE5leHRbaTBdID0gaHVsbFByZXZbaTJdID0gaTE7XG4gICAgICAgIGh1bGxOZXh0W2kxXSA9IGh1bGxQcmV2W2kwXSA9IGkyO1xuICAgICAgICBodWxsTmV4dFtpMl0gPSBodWxsUHJldltpMV0gPSBpMDtcblxuICAgICAgICBodWxsVHJpW2kwXSA9IDA7XG4gICAgICAgIGh1bGxUcmlbaTFdID0gMTtcbiAgICAgICAgaHVsbFRyaVtpMl0gPSAyO1xuXG4gICAgICAgIGh1bGxIYXNoLmZpbGwoLTEpO1xuICAgICAgICBodWxsSGFzaFt0aGlzLl9oYXNoS2V5KGkweCwgaTB5KV0gPSBpMDtcbiAgICAgICAgaHVsbEhhc2hbdGhpcy5faGFzaEtleShpMXgsIGkxeSldID0gaTE7XG4gICAgICAgIGh1bGxIYXNoW3RoaXMuX2hhc2hLZXkoaTJ4LCBpMnkpXSA9IGkyO1xuXG4gICAgICAgIHRoaXMudHJpYW5nbGVzTGVuID0gMDtcbiAgICAgICAgdGhpcy5fYWRkVHJpYW5nbGUoaTAsIGkxLCBpMiwgLTEsIC0xLCAtMSk7XG5cbiAgICAgICAgZm9yICh2YXIgayA9IDAsIHhwID0gKHZvaWQgMCksIHlwID0gKHZvaWQgMCk7IGsgPCB0aGlzLl9pZHMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgIHZhciBpJDggPSB0aGlzLl9pZHNba107XG4gICAgICAgICAgICB2YXIgeCQyID0gY29vcmRzWzIgKiBpJDhdO1xuICAgICAgICAgICAgdmFyIHkkMiA9IGNvb3Jkc1syICogaSQ4ICsgMV07XG5cbiAgICAgICAgICAgIC8vIHNraXAgbmVhci1kdXBsaWNhdGUgcG9pbnRzXG4gICAgICAgICAgICBpZiAoayA+IDAgJiYgTWF0aC5hYnMoeCQyIC0geHApIDw9IEVQU0lMT04gJiYgTWF0aC5hYnMoeSQyIC0geXApIDw9IEVQU0lMT04pIHsgY29udGludWU7IH1cbiAgICAgICAgICAgIHhwID0geCQyO1xuICAgICAgICAgICAgeXAgPSB5JDI7XG5cbiAgICAgICAgICAgIC8vIHNraXAgc2VlZCB0cmlhbmdsZSBwb2ludHNcbiAgICAgICAgICAgIGlmIChpJDggPT09IGkwIHx8IGkkOCA9PT0gaTEgfHwgaSQ4ID09PSBpMikgeyBjb250aW51ZTsgfVxuXG4gICAgICAgICAgICAvLyBmaW5kIGEgdmlzaWJsZSBlZGdlIG9uIHRoZSBjb252ZXggaHVsbCB1c2luZyBlZGdlIGhhc2hcbiAgICAgICAgICAgIHZhciBzdGFydCA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBqJDEgPSAwLCBrZXkgPSB0aGlzLl9oYXNoS2V5KHgkMiwgeSQyKTsgaiQxIDwgdGhpcy5faGFzaFNpemU7IGokMSsrKSB7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSBodWxsSGFzaFsoa2V5ICsgaiQxKSAlIHRoaXMuX2hhc2hTaXplXTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnQgIT09IC0xICYmIHN0YXJ0ICE9PSBodWxsTmV4dFtzdGFydF0pIHsgYnJlYWs7IH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3RhcnQgPSBodWxsUHJldltzdGFydF07XG4gICAgICAgICAgICB2YXIgZSA9IHN0YXJ0LCBxID0gKHZvaWQgMCk7XG4gICAgICAgICAgICB3aGlsZSAocSA9IGh1bGxOZXh0W2VdLCAhb3JpZW50KHgkMiwgeSQyLCBjb29yZHNbMiAqIGVdLCBjb29yZHNbMiAqIGUgKyAxXSwgY29vcmRzWzIgKiBxXSwgY29vcmRzWzIgKiBxICsgMV0pKSB7XG4gICAgICAgICAgICAgICAgZSA9IHE7XG4gICAgICAgICAgICAgICAgaWYgKGUgPT09IHN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGUgPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGUgPT09IC0xKSB7IGNvbnRpbnVlOyB9IC8vIGxpa2VseSBhIG5lYXItZHVwbGljYXRlIHBvaW50OyBza2lwIGl0XG5cbiAgICAgICAgICAgIC8vIGFkZCB0aGUgZmlyc3QgdHJpYW5nbGUgZnJvbSB0aGUgcG9pbnRcbiAgICAgICAgICAgIHZhciB0ID0gdGhpcy5fYWRkVHJpYW5nbGUoZSwgaSQ4LCBodWxsTmV4dFtlXSwgLTEsIC0xLCBodWxsVHJpW2VdKTtcblxuICAgICAgICAgICAgLy8gcmVjdXJzaXZlbHkgZmxpcCB0cmlhbmdsZXMgZnJvbSB0aGUgcG9pbnQgdW50aWwgdGhleSBzYXRpc2Z5IHRoZSBEZWxhdW5heSBjb25kaXRpb25cbiAgICAgICAgICAgIGh1bGxUcmlbaSQ4XSA9IHRoaXMuX2xlZ2FsaXplKHQgKyAyKTtcbiAgICAgICAgICAgIGh1bGxUcmlbZV0gPSB0OyAvLyBrZWVwIHRyYWNrIG9mIGJvdW5kYXJ5IHRyaWFuZ2xlcyBvbiB0aGUgaHVsbFxuICAgICAgICAgICAgaHVsbFNpemUrKztcblxuICAgICAgICAgICAgLy8gd2FsayBmb3J3YXJkIHRocm91Z2ggdGhlIGh1bGwsIGFkZGluZyBtb3JlIHRyaWFuZ2xlcyBhbmQgZmxpcHBpbmcgcmVjdXJzaXZlbHlcbiAgICAgICAgICAgIHZhciBuJDEgPSBodWxsTmV4dFtlXTtcbiAgICAgICAgICAgIHdoaWxlIChxID0gaHVsbE5leHRbbiQxXSwgb3JpZW50KHgkMiwgeSQyLCBjb29yZHNbMiAqIG4kMV0sIGNvb3Jkc1syICogbiQxICsgMV0sIGNvb3Jkc1syICogcV0sIGNvb3Jkc1syICogcSArIDFdKSkge1xuICAgICAgICAgICAgICAgIHQgPSB0aGlzLl9hZGRUcmlhbmdsZShuJDEsIGkkOCwgcSwgaHVsbFRyaVtpJDhdLCAtMSwgaHVsbFRyaVtuJDFdKTtcbiAgICAgICAgICAgICAgICBodWxsVHJpW2kkOF0gPSB0aGlzLl9sZWdhbGl6ZSh0ICsgMik7XG4gICAgICAgICAgICAgICAgaHVsbE5leHRbbiQxXSA9IG4kMTsgLy8gbWFyayBhcyByZW1vdmVkXG4gICAgICAgICAgICAgICAgaHVsbFNpemUtLTtcbiAgICAgICAgICAgICAgICBuJDEgPSBxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB3YWxrIGJhY2t3YXJkIGZyb20gdGhlIG90aGVyIHNpZGUsIGFkZGluZyBtb3JlIHRyaWFuZ2xlcyBhbmQgZmxpcHBpbmdcbiAgICAgICAgICAgIGlmIChlID09PSBzdGFydCkge1xuICAgICAgICAgICAgICAgIHdoaWxlIChxID0gaHVsbFByZXZbZV0sIG9yaWVudCh4JDIsIHkkMiwgY29vcmRzWzIgKiBxXSwgY29vcmRzWzIgKiBxICsgMV0sIGNvb3Jkc1syICogZV0sIGNvb3Jkc1syICogZSArIDFdKSkge1xuICAgICAgICAgICAgICAgICAgICB0ID0gdGhpcy5fYWRkVHJpYW5nbGUocSwgaSQ4LCBlLCAtMSwgaHVsbFRyaVtlXSwgaHVsbFRyaVtxXSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xlZ2FsaXplKHQgKyAyKTtcbiAgICAgICAgICAgICAgICAgICAgaHVsbFRyaVtxXSA9IHQ7XG4gICAgICAgICAgICAgICAgICAgIGh1bGxOZXh0W2VdID0gZTsgLy8gbWFyayBhcyByZW1vdmVkXG4gICAgICAgICAgICAgICAgICAgIGh1bGxTaXplLS07XG4gICAgICAgICAgICAgICAgICAgIGUgPSBxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gdXBkYXRlIHRoZSBodWxsIGluZGljZXNcbiAgICAgICAgICAgIHRoaXMuX2h1bGxTdGFydCA9IGh1bGxQcmV2W2kkOF0gPSBlO1xuICAgICAgICAgICAgaHVsbE5leHRbZV0gPSBodWxsUHJldltuJDFdID0gaSQ4O1xuICAgICAgICAgICAgaHVsbE5leHRbaSQ4XSA9IG4kMTtcblxuICAgICAgICAgICAgLy8gc2F2ZSB0aGUgdHdvIG5ldyBlZGdlcyBpbiB0aGUgaGFzaCB0YWJsZVxuICAgICAgICAgICAgaHVsbEhhc2hbdGhpcy5faGFzaEtleSh4JDIsIHkkMildID0gaSQ4O1xuICAgICAgICAgICAgaHVsbEhhc2hbdGhpcy5faGFzaEtleShjb29yZHNbMiAqIGVdLCBjb29yZHNbMiAqIGUgKyAxXSldID0gZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaHVsbCA9IG5ldyBVaW50MzJBcnJheShodWxsU2l6ZSk7XG4gICAgICAgIGZvciAodmFyIGkkOSA9IDAsIGUkMSA9IHRoaXMuX2h1bGxTdGFydDsgaSQ5IDwgaHVsbFNpemU7IGkkOSsrKSB7XG4gICAgICAgICAgICB0aGlzLmh1bGxbaSQ5XSA9IGUkMTtcbiAgICAgICAgICAgIGUkMSA9IGh1bGxOZXh0W2UkMV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0cmltIHR5cGVkIHRyaWFuZ2xlIG1lc2ggYXJyYXlzXG4gICAgICAgIHRoaXMudHJpYW5nbGVzID0gdGhpcy5fdHJpYW5nbGVzLnN1YmFycmF5KDAsIHRoaXMudHJpYW5nbGVzTGVuKTtcbiAgICAgICAgdGhpcy5oYWxmZWRnZXMgPSB0aGlzLl9oYWxmZWRnZXMuc3ViYXJyYXkoMCwgdGhpcy50cmlhbmdsZXNMZW4pO1xuICAgIH07XG5cbiAgICBEZWxhdW5hdG9yLnByb3RvdHlwZS5faGFzaEtleSA9IGZ1bmN0aW9uIF9oYXNoS2V5ICh4LCB5KSB7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKHBzZXVkb0FuZ2xlKHggLSB0aGlzLl9jeCwgeSAtIHRoaXMuX2N5KSAqIHRoaXMuX2hhc2hTaXplKSAlIHRoaXMuX2hhc2hTaXplO1xuICAgIH07XG5cbiAgICBEZWxhdW5hdG9yLnByb3RvdHlwZS5fbGVnYWxpemUgPSBmdW5jdGlvbiBfbGVnYWxpemUgKGEpIHtcbiAgICAgICAgdmFyIHJlZiA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgdHJpYW5nbGVzID0gcmVmLl90cmlhbmdsZXM7XG4gICAgICAgICAgICB2YXIgaGFsZmVkZ2VzID0gcmVmLl9oYWxmZWRnZXM7XG4gICAgICAgICAgICB2YXIgY29vcmRzID0gcmVmLmNvb3JkcztcblxuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHZhciBhciA9IDA7XG5cbiAgICAgICAgLy8gcmVjdXJzaW9uIGVsaW1pbmF0ZWQgd2l0aCBhIGZpeGVkLXNpemUgc3RhY2tcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIHZhciBiID0gaGFsZmVkZ2VzW2FdO1xuXG4gICAgICAgICAgICAvKiBpZiB0aGUgcGFpciBvZiB0cmlhbmdsZXMgZG9lc24ndCBzYXRpc2Z5IHRoZSBEZWxhdW5heSBjb25kaXRpb25cbiAgICAgICAgICAgICAqIChwMSBpcyBpbnNpZGUgdGhlIGNpcmN1bWNpcmNsZSBvZiBbcDAsIHBsLCBwcl0pLCBmbGlwIHRoZW0sXG4gICAgICAgICAgICAgKiB0aGVuIGRvIHRoZSBzYW1lIGNoZWNrL2ZsaXAgcmVjdXJzaXZlbHkgZm9yIHRoZSBuZXcgcGFpciBvZiB0cmlhbmdsZXNcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgICAgICBwbCAgICAgICAgICAgICAgICBwbFxuICAgICAgICAgICAgICogICAgICAvfHxcXCAgICAgICAgICAgICAgLyAgXFxcbiAgICAgICAgICAgICAqICAgYWwvIHx8IFxcYmwgICAgICAgIGFsL1xcYVxuICAgICAgICAgICAgICogICAgLyAgfHwgIFxcICAgICAgICAgIC8gIFxcXG4gICAgICAgICAgICAgKiAgIC8gIGF8fGIgIFxcZmxpcC9fX19hcl9fX1xcXG4gICAgICAgICAgICAgKiBwMFxcICAgfHwgICAvcDEgICA9PiAgIHAwXFwtLS1ibC0tLS9wMVxuICAgICAgICAgICAgICogICAgXFwgIHx8ICAvICAgICAgICAgIFxcICAvXG4gICAgICAgICAgICAgKiAgIGFyXFwgfHwgL2JyICAgICAgICAgYlxcL2JyXG4gICAgICAgICAgICAgKiAgICAgIFxcfHwvICAgICAgICAgICAgICBcXCAgL1xuICAgICAgICAgICAgICogICAgICAgcHIgICAgICAgICAgICAgICAgcHJcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmFyIGEwID0gYSAtIGEgJSAzO1xuICAgICAgICAgICAgYXIgPSBhMCArIChhICsgMikgJSAzO1xuXG4gICAgICAgICAgICBpZiAoYiA9PT0gLTEpIHsgLy8gY29udmV4IGh1bGwgZWRnZVxuICAgICAgICAgICAgICAgIGlmIChpID09PSAwKSB7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgYSA9IEVER0VfU1RBQ0tbLS1pXTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGIwID0gYiAtIGIgJSAzO1xuICAgICAgICAgICAgdmFyIGFsID0gYTAgKyAoYSArIDEpICUgMztcbiAgICAgICAgICAgIHZhciBibCA9IGIwICsgKGIgKyAyKSAlIDM7XG5cbiAgICAgICAgICAgIHZhciBwMCA9IHRyaWFuZ2xlc1thcl07XG4gICAgICAgICAgICB2YXIgcHIgPSB0cmlhbmdsZXNbYV07XG4gICAgICAgICAgICB2YXIgcGwgPSB0cmlhbmdsZXNbYWxdO1xuICAgICAgICAgICAgdmFyIHAxID0gdHJpYW5nbGVzW2JsXTtcblxuICAgICAgICAgICAgdmFyIGlsbGVnYWwgPSBpbkNpcmNsZShcbiAgICAgICAgICAgICAgICBjb29yZHNbMiAqIHAwXSwgY29vcmRzWzIgKiBwMCArIDFdLFxuICAgICAgICAgICAgICAgIGNvb3Jkc1syICogcHJdLCBjb29yZHNbMiAqIHByICsgMV0sXG4gICAgICAgICAgICAgICAgY29vcmRzWzIgKiBwbF0sIGNvb3Jkc1syICogcGwgKyAxXSxcbiAgICAgICAgICAgICAgICBjb29yZHNbMiAqIHAxXSwgY29vcmRzWzIgKiBwMSArIDFdKTtcblxuICAgICAgICAgICAgaWYgKGlsbGVnYWwpIHtcbiAgICAgICAgICAgICAgICB0cmlhbmdsZXNbYV0gPSBwMTtcbiAgICAgICAgICAgICAgICB0cmlhbmdsZXNbYl0gPSBwMDtcblxuICAgICAgICAgICAgICAgIHZhciBoYmwgPSBoYWxmZWRnZXNbYmxdO1xuXG4gICAgICAgICAgICAgICAgLy8gZWRnZSBzd2FwcGVkIG9uIHRoZSBvdGhlciBzaWRlIG9mIHRoZSBodWxsIChyYXJlKTsgZml4IHRoZSBoYWxmZWRnZSByZWZlcmVuY2VcbiAgICAgICAgICAgICAgICBpZiAoaGJsID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZSA9IHRoaXMuX2h1bGxTdGFydDtcbiAgICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2h1bGxUcmlbZV0gPT09IGJsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faHVsbFRyaVtlXSA9IGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlID0gdGhpcy5faHVsbFByZXZbZV07XG4gICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKGUgIT09IHRoaXMuX2h1bGxTdGFydCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2xpbmsoYSwgaGJsKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9saW5rKGIsIGhhbGZlZGdlc1thcl0pO1xuICAgICAgICAgICAgICAgIHRoaXMuX2xpbmsoYXIsIGJsKTtcblxuICAgICAgICAgICAgICAgIHZhciBiciA9IGIwICsgKGIgKyAxKSAlIDM7XG5cbiAgICAgICAgICAgICAgICAvLyBkb24ndCB3b3JyeSBhYm91dCBoaXR0aW5nIHRoZSBjYXA6IGl0IGNhbiBvbmx5IGhhcHBlbiBvbiBleHRyZW1lbHkgZGVnZW5lcmF0ZSBpbnB1dFxuICAgICAgICAgICAgICAgIGlmIChpIDwgRURHRV9TVEFDSy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgRURHRV9TVEFDS1tpKytdID0gYnI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMCkgeyBicmVhazsgfVxuICAgICAgICAgICAgICAgIGEgPSBFREdFX1NUQUNLWy0taV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXI7XG4gICAgfTtcblxuICAgIERlbGF1bmF0b3IucHJvdG90eXBlLl9saW5rID0gZnVuY3Rpb24gX2xpbmsgKGEsIGIpIHtcbiAgICAgICAgdGhpcy5faGFsZmVkZ2VzW2FdID0gYjtcbiAgICAgICAgaWYgKGIgIT09IC0xKSB7IHRoaXMuX2hhbGZlZGdlc1tiXSA9IGE7IH1cbiAgICB9O1xuXG4gICAgLy8gYWRkIGEgbmV3IHRyaWFuZ2xlIGdpdmVuIHZlcnRleCBpbmRpY2VzIGFuZCBhZGphY2VudCBoYWxmLWVkZ2UgaWRzXG4gICAgRGVsYXVuYXRvci5wcm90b3R5cGUuX2FkZFRyaWFuZ2xlID0gZnVuY3Rpb24gX2FkZFRyaWFuZ2xlIChpMCwgaTEsIGkyLCBhLCBiLCBjKSB7XG4gICAgICAgIHZhciB0ID0gdGhpcy50cmlhbmdsZXNMZW47XG5cbiAgICAgICAgdGhpcy5fdHJpYW5nbGVzW3RdID0gaTA7XG4gICAgICAgIHRoaXMuX3RyaWFuZ2xlc1t0ICsgMV0gPSBpMTtcbiAgICAgICAgdGhpcy5fdHJpYW5nbGVzW3QgKyAyXSA9IGkyO1xuXG4gICAgICAgIHRoaXMuX2xpbmsodCwgYSk7XG4gICAgICAgIHRoaXMuX2xpbmsodCArIDEsIGIpO1xuICAgICAgICB0aGlzLl9saW5rKHQgKyAyLCBjKTtcblxuICAgICAgICB0aGlzLnRyaWFuZ2xlc0xlbiArPSAzO1xuXG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG5cbiAgICAvLyBtb25vdG9uaWNhbGx5IGluY3JlYXNlcyB3aXRoIHJlYWwgYW5nbGUsIGJ1dCBkb2Vzbid0IG5lZWQgZXhwZW5zaXZlIHRyaWdvbm9tZXRyeVxuICAgIGZ1bmN0aW9uIHBzZXVkb0FuZ2xlKGR4LCBkeSkge1xuICAgICAgICB2YXIgcCA9IGR4IC8gKE1hdGguYWJzKGR4KSArIE1hdGguYWJzKGR5KSk7XG4gICAgICAgIHJldHVybiAoZHkgPiAwID8gMyAtIHAgOiAxICsgcCkgLyA0OyAvLyBbMC4uMV1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkaXN0KGF4LCBheSwgYngsIGJ5KSB7XG4gICAgICAgIHZhciBkeCA9IGF4IC0gYng7XG4gICAgICAgIHZhciBkeSA9IGF5IC0gYnk7XG4gICAgICAgIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgICB9XG5cbiAgICAvLyByZXR1cm4gMmQgb3JpZW50YXRpb24gc2lnbiBpZiB3ZSdyZSBjb25maWRlbnQgaW4gaXQgdGhyb3VnaCBKLiBTaGV3Y2h1aydzIGVycm9yIGJvdW5kIGNoZWNrXG4gICAgZnVuY3Rpb24gb3JpZW50SWZTdXJlKHB4LCBweSwgcngsIHJ5LCBxeCwgcXkpIHtcbiAgICAgICAgdmFyIGwgPSAocnkgLSBweSkgKiAocXggLSBweCk7XG4gICAgICAgIHZhciByID0gKHJ4IC0gcHgpICogKHF5IC0gcHkpO1xuICAgICAgICByZXR1cm4gTWF0aC5hYnMobCAtIHIpID49IDMuMzMwNjY5MDczODc1NDcxNmUtMTYgKiBNYXRoLmFicyhsICsgcikgPyBsIC0gciA6IDA7XG4gICAgfVxuXG4gICAgLy8gYSBtb3JlIHJvYnVzdCBvcmllbnRhdGlvbiB0ZXN0IHRoYXQncyBzdGFibGUgaW4gYSBnaXZlbiB0cmlhbmdsZSAodG8gZml4IHJvYnVzdG5lc3MgaXNzdWVzKVxuICAgIGZ1bmN0aW9uIG9yaWVudChyeCwgcnksIHF4LCBxeSwgcHgsIHB5KSB7XG4gICAgICAgIHZhciBzaWduID0gb3JpZW50SWZTdXJlKHB4LCBweSwgcngsIHJ5LCBxeCwgcXkpIHx8XG4gICAgICAgIG9yaWVudElmU3VyZShyeCwgcnksIHF4LCBxeSwgcHgsIHB5KSB8fFxuICAgICAgICBvcmllbnRJZlN1cmUocXgsIHF5LCBweCwgcHksIHJ4LCByeSk7XG4gICAgICAgIHJldHVybiBzaWduIDwgMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbkNpcmNsZShheCwgYXksIGJ4LCBieSwgY3gsIGN5LCBweCwgcHkpIHtcbiAgICAgICAgdmFyIGR4ID0gYXggLSBweDtcbiAgICAgICAgdmFyIGR5ID0gYXkgLSBweTtcbiAgICAgICAgdmFyIGV4ID0gYnggLSBweDtcbiAgICAgICAgdmFyIGV5ID0gYnkgLSBweTtcbiAgICAgICAgdmFyIGZ4ID0gY3ggLSBweDtcbiAgICAgICAgdmFyIGZ5ID0gY3kgLSBweTtcblxuICAgICAgICB2YXIgYXAgPSBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgICAgICAgdmFyIGJwID0gZXggKiBleCArIGV5ICogZXk7XG4gICAgICAgIHZhciBjcCA9IGZ4ICogZnggKyBmeSAqIGZ5O1xuXG4gICAgICAgIHJldHVybiBkeCAqIChleSAqIGNwIC0gYnAgKiBmeSkgLVxuICAgICAgICAgICAgICAgZHkgKiAoZXggKiBjcCAtIGJwICogZngpICtcbiAgICAgICAgICAgICAgIGFwICogKGV4ICogZnkgLSBleSAqIGZ4KSA8IDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2lyY3VtcmFkaXVzKGF4LCBheSwgYngsIGJ5LCBjeCwgY3kpIHtcbiAgICAgICAgdmFyIGR4ID0gYnggLSBheDtcbiAgICAgICAgdmFyIGR5ID0gYnkgLSBheTtcbiAgICAgICAgdmFyIGV4ID0gY3ggLSBheDtcbiAgICAgICAgdmFyIGV5ID0gY3kgLSBheTtcblxuICAgICAgICB2YXIgYmwgPSBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgICAgICAgdmFyIGNsID0gZXggKiBleCArIGV5ICogZXk7XG4gICAgICAgIHZhciBkID0gMC41IC8gKGR4ICogZXkgLSBkeSAqIGV4KTtcblxuICAgICAgICB2YXIgeCA9IChleSAqIGJsIC0gZHkgKiBjbCkgKiBkO1xuICAgICAgICB2YXIgeSA9IChkeCAqIGNsIC0gZXggKiBibCkgKiBkO1xuXG4gICAgICAgIHJldHVybiB4ICogeCArIHkgKiB5O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNpcmN1bWNlbnRlcihheCwgYXksIGJ4LCBieSwgY3gsIGN5KSB7XG4gICAgICAgIHZhciBkeCA9IGJ4IC0gYXg7XG4gICAgICAgIHZhciBkeSA9IGJ5IC0gYXk7XG4gICAgICAgIHZhciBleCA9IGN4IC0gYXg7XG4gICAgICAgIHZhciBleSA9IGN5IC0gYXk7XG5cbiAgICAgICAgdmFyIGJsID0gZHggKiBkeCArIGR5ICogZHk7XG4gICAgICAgIHZhciBjbCA9IGV4ICogZXggKyBleSAqIGV5O1xuICAgICAgICB2YXIgZCA9IDAuNSAvIChkeCAqIGV5IC0gZHkgKiBleCk7XG5cbiAgICAgICAgdmFyIHggPSBheCArIChleSAqIGJsIC0gZHkgKiBjbCkgKiBkO1xuICAgICAgICB2YXIgeSA9IGF5ICsgKGR4ICogY2wgLSBleCAqIGJsKSAqIGQ7XG5cbiAgICAgICAgcmV0dXJuIHt4OiB4LCB5OiB5fTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBxdWlja3NvcnQoaWRzLCBkaXN0cywgbGVmdCwgcmlnaHQpIHtcbiAgICAgICAgaWYgKHJpZ2h0IC0gbGVmdCA8PSAyMCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IGxlZnQgKyAxOyBpIDw9IHJpZ2h0OyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgdGVtcCA9IGlkc1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgdGVtcERpc3QgPSBkaXN0c1t0ZW1wXTtcbiAgICAgICAgICAgICAgICB2YXIgaiA9IGkgLSAxO1xuICAgICAgICAgICAgICAgIHdoaWxlIChqID49IGxlZnQgJiYgZGlzdHNbaWRzW2pdXSA+IHRlbXBEaXN0KSB7IGlkc1tqICsgMV0gPSBpZHNbai0tXTsgfVxuICAgICAgICAgICAgICAgIGlkc1tqICsgMV0gPSB0ZW1wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIG1lZGlhbiA9IChsZWZ0ICsgcmlnaHQpID4+IDE7XG4gICAgICAgICAgICB2YXIgaSQxID0gbGVmdCArIDE7XG4gICAgICAgICAgICB2YXIgaiQxID0gcmlnaHQ7XG4gICAgICAgICAgICBzd2FwKGlkcywgbWVkaWFuLCBpJDEpO1xuICAgICAgICAgICAgaWYgKGRpc3RzW2lkc1tsZWZ0XV0gPiBkaXN0c1tpZHNbcmlnaHRdXSkgeyBzd2FwKGlkcywgbGVmdCwgcmlnaHQpOyB9XG4gICAgICAgICAgICBpZiAoZGlzdHNbaWRzW2kkMV1dID4gZGlzdHNbaWRzW3JpZ2h0XV0pIHsgc3dhcChpZHMsIGkkMSwgcmlnaHQpOyB9XG4gICAgICAgICAgICBpZiAoZGlzdHNbaWRzW2xlZnRdXSA+IGRpc3RzW2lkc1tpJDFdXSkgeyBzd2FwKGlkcywgbGVmdCwgaSQxKTsgfVxuXG4gICAgICAgICAgICB2YXIgdGVtcCQxID0gaWRzW2kkMV07XG4gICAgICAgICAgICB2YXIgdGVtcERpc3QkMSA9IGRpc3RzW3RlbXAkMV07XG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgIGRvIHsgaSQxKys7IH0gd2hpbGUgKGRpc3RzW2lkc1tpJDFdXSA8IHRlbXBEaXN0JDEpO1xuICAgICAgICAgICAgICAgIGRvIHsgaiQxLS07IH0gd2hpbGUgKGRpc3RzW2lkc1tqJDFdXSA+IHRlbXBEaXN0JDEpO1xuICAgICAgICAgICAgICAgIGlmIChqJDEgPCBpJDEpIHsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICBzd2FwKGlkcywgaSQxLCBqJDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWRzW2xlZnQgKyAxXSA9IGlkc1tqJDFdO1xuICAgICAgICAgICAgaWRzW2okMV0gPSB0ZW1wJDE7XG5cbiAgICAgICAgICAgIGlmIChyaWdodCAtIGkkMSArIDEgPj0gaiQxIC0gbGVmdCkge1xuICAgICAgICAgICAgICAgIHF1aWNrc29ydChpZHMsIGRpc3RzLCBpJDEsIHJpZ2h0KTtcbiAgICAgICAgICAgICAgICBxdWlja3NvcnQoaWRzLCBkaXN0cywgbGVmdCwgaiQxIC0gMSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHF1aWNrc29ydChpZHMsIGRpc3RzLCBsZWZ0LCBqJDEgLSAxKTtcbiAgICAgICAgICAgICAgICBxdWlja3NvcnQoaWRzLCBkaXN0cywgaSQxLCByaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzd2FwKGFyciwgaSwgaikge1xuICAgICAgICB2YXIgdG1wID0gYXJyW2ldO1xuICAgICAgICBhcnJbaV0gPSBhcnJbal07XG4gICAgICAgIGFycltqXSA9IHRtcDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZWZhdWx0R2V0WChwKSB7XG4gICAgICAgIHJldHVybiBwWzBdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWZhdWx0R2V0WShwKSB7XG4gICAgICAgIHJldHVybiBwWzFdO1xuICAgIH1cblxuICAgIHJldHVybiBEZWxhdW5hdG9yO1xuXG59KSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/delaunator/delaunator.js\n");

/***/ })

};
;